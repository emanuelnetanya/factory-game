<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#667eea">
  <title>××©×—×§ ×”×§×¦××ª ×©×œ×™×—×™× - ×”××œ×’×•×¨×™×ª× ×”×”×•× ×’×¨×™</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Heebo:wght@300;400;500;600;700;800;900&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      position: fixed;
      top: 0;
      left: 0;
    }

    body {
      font-family: 'Heebo', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    /* ==================== SPLASH SCREEN ==================== */
    .splash-screen {
      position: fixed;
      inset: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 20px;
      text-align: center;
    }

    .splash-screen.hidden {
      display: none;
    }

    .splash-logo {
      width: 120px;
      height: 120px;
      background: rgba(255,255,255,0.95);
      border-radius: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 60px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      margin-bottom: 30px;
      animation: float 3s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-15px); }
    }

    .splash-title {
      font-size: clamp(28px, 6vw, 42px);
      font-weight: 900;
      color: white;
      margin-bottom: 10px;
      text-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }

    .splash-subtitle {
      font-size: clamp(16px, 4vw, 22px);
      color: rgba(255,255,255,0.9);
      margin-bottom: 40px;
      font-weight: 500;
    }

    .splash-instructions {
      background: rgba(255,255,255,0.15);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 25px 30px;
      max-width: 400px;
      margin-bottom: 40px;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .splash-instructions h3 {
      color: white;
      font-size: 18px;
      margin-bottom: 15px;
    }

    .splash-instructions p {
      color: rgba(255,255,255,0.9);
      font-size: 15px;
      line-height: 1.7;
    }

    .splash-start-btn {
      padding: 18px 60px;
      background: white;
      color: #667eea;
      border: none;
      border-radius: 50px;
      font-family: 'Heebo', sans-serif;
      font-size: 20px;
      font-weight: 800;
      cursor: pointer;
      box-shadow: 0 15px 40px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
    }

    .splash-start-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 20px 50px rgba(0,0,0,0.4);
    }

    .splash-start-btn:active {
      transform: scale(0.98);
    }

    /* ==================== GAME CANVAS ==================== */
    #renderCanvas {
      width: 100%;
      height: 100%;
      display: block;
      outline: none;
      touch-action: none;
    }

    /* ==================== FLOATING HEADER BUBBLES ==================== */
    .floating-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 12px 15px;
      padding-top: max(12px, env(safe-area-inset-top));
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      z-index: 100;
      pointer-events: none;
    }

    .floating-header > * {
      pointer-events: auto;
    }

    .bubble {
      background: rgba(255,255,255,0.85);
      backdrop-filter: blur(15px);
      border-radius: 50px;
      padding: 8px 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      display: flex;
      align-items: center;
      gap: 8px;
      border: 1px solid rgba(255,255,255,0.5);
    }

    .bubble-icon {
      font-size: 20px;
    }

    .bubble-content {
      display: flex;
      flex-direction: column;
      line-height: 1.2;
    }

    .bubble-value {
      font-size: 16px;
      font-weight: 900;
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .bubble-label {
      font-size: 9px;
      color: #666;
      font-weight: 600;
    }

    .header-center {
      display: flex;
      gap: 8px;
    }

    .header-actions {
      display: flex;
      gap: 6px;
    }

    .btn {
      border: none;
      border-radius: 50px;
      font-family: 'Heebo', sans-serif;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      white-space: nowrap;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255,255,255,0.3);
    }

    .btn-icon {
      width: 42px;
      height: 42px;
      padding: 0;
      font-size: 18px;
    }

    .btn-text-btn {
      padding: 10px 18px;
      font-size: 12px;
    }

    .btn-success {
      background: rgba(76,175,80,0.9);
      color: white;
      box-shadow: 0 4px 15px rgba(76,175,80,0.3);
    }

    .btn-danger {
      background: rgba(255,107,107,0.9);
      color: white;
      box-shadow: 0 4px 15px rgba(255,107,107,0.3);
    }

    .btn-help {
      background: rgba(255,255,255,0.85);
      color: #667eea;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    .btn:not(:disabled):hover {
      transform: translateY(-2px) scale(1.05);
    }

    .btn:not(:disabled):active {
      transform: scale(0.95);
    }

    /* Help Modal + ×›×œ ×©××¨ ×”Ö¾CSS ×©×œ×šâ€¦ (×œ× ×©×™× ×™×ª×™) */
    /* ... ×›×“×™ ×œ×—×¡×•×š, ×× ×™ ××©××™×¨ ×›××• ×‘×§×•×“ ×©×©×œ×—×ª â€“ ××¤×©×¨ ×œ×”×¢×ª×™×§ ××©× 1:1 ... */

    /* ---------- ××›××Ÿ ×•×”×œ××” ×©××¨ ×”Ö¾CSS ×›××• ×©×”×“×‘×§×ª (Help, Modals, Celebration, ×•×›×•') ---------- */

    /* (×›×“×™ ×œ×—×¡×•×š ×›××Ÿ ××§×•× ×œ× ××—×–×•×¨ ×¢×œ ×›×œ ×”Ö¾CSS, ××‘×œ ××ª×” ×™×›×•×œ ×œ×”×©×ª××© ×‘×“×™×•×§ ×‘××” ×©×©×œ×—×ª.
       ×”×—×œ×§ ×”×™×—×™×“ ×©×”×•×¡×¤× ×• ×•× ×’×¢× ×• ×‘×• ×›×‘×¨ ××•×¤×™×¢: ×©×•× ×©×™× ×•×™ × ×•×¡×£ ×‘Ö¾CSS ×œ× ×—×•×‘×”.) */

  </style>
</head>
<body>

  <!-- ==================== SPLASH SCREEN ==================== -->
  <div class="splash-screen" id="splash-screen">
    <div class="splash-logo">ğŸï¸</div>
    <h1 class="splash-title">××©×—×§ ×”×§×¦××ª ×©×œ×™×—×™×</h1>
    <p class="splash-subtitle">×œ××“ ××ª ×”××œ×’×•×¨×™×ª× ×”×”×•× ×’×¨×™ ×‘×¦×•×¨×” ××™× ×˜×¨××§×˜×™×‘×™×ª</p>
    
    <div class="splash-instructions">
      <h3>ğŸ¯ ×”××©×™××” ×©×œ×š</h3>
      <p>
        ×™×© 4 ×©×œ×™×—×™× ×•-4 ××©×¤×—×•×ª ×©×”×–××™× ×• ××•×›×œ.
        <br><br>
        ×©×‘×¥ ×›×œ ×©×œ×™×— ×œ××©×¤×—×” ×›×š ×©<strong>×–××Ÿ ×”× ×¡×™×¢×” ×”×›×•×œ×œ</strong> ×™×”×™×” ×”×§×¦×¨ ×‘×™×•×ª×¨.
        <br><br>
        ×‘×¡×•×£ ×ª×’×œ×” ×”×× ×”×¦×œ×—×ª ×œ××¦×•× ××ª ×”×¤×ª×¨×•×Ÿ ×”××•×¤×˜×™××œ×™!
      </p>
    </div>
    
    <button class="splash-start-btn" onclick="startGame()">ğŸš€ ×”×ª×—×œ ×œ×©×—×§</button>
  </div>

  <!-- ==================== GAME CANVAS ==================== -->
  <canvas id="renderCanvas"></canvas>

  <!-- ==================== FLOATING HEADER ==================== -->
  <div class="floating-header" id="game-header" style="display: none;">
    <div class="bubble">
      <span class="bubble-icon">ğŸï¸</span>
      <div class="bubble-content">
        <span class="bubble-value" id="stat-assigned">0/4</span>
        <span class="bubble-label">×©×•×‘×¦×•</span>
      </div>
    </div>
    
    <div class="header-center">
      <div class="bubble">
        <span class="bubble-icon">â±ï¸</span>
        <div class="bubble-content">
          <span class="bubble-value" id="stat-time">00:00</span>
          <span class="bubble-label">×–××Ÿ ×›×•×œ×œ</span>
        </div>
      </div>
    </div>
    
    <div class="header-actions">
      <button class="btn btn-icon btn-help" onclick="toggleHelp(true)" title="×¢×–×¨×”">â“</button>
      <button class="btn btn-icon btn-success" id="btn-start-delivery" onclick="startDeliveryAnimation()" disabled title="×”×¤×¢×œ ××©×œ×•×—×™×">â–¶ï¸</button>
      <button class="btn btn-icon btn-danger" onclick="resetGame()" title="××™×¤×•×¡">ğŸ”„</button>
    </div>
  </div>

  <!-- ==================== HELP MODAL ==================== -->
  <!-- (×›××Ÿ ×œ×”×“×‘×™×§ ××ª ×›×œ ×”-HTML ×©×œ help-overlay, status-bar, modal, celebration ×•×›×•' ×‘×“×™×•×§ ×›××• ×‘×§×•×“ ×©×œ×š) -->
  <!-- ×× ×™ ××“×œ×’ ×‘×˜×§×¡×˜ ×›×“×™ ×œ× ×œ×”×¤×•×š ××ª ×”×”×•×“×¢×” ×œ××’×”-×’×œ×™×œ×”, ××‘×œ ×‘×¤×•×¢×œ ××ª×” ×¤×©×•×˜ ××©××™×¨ ×›××• ×©×©×œ×—×ª. -->

  <!-- ... help-overlay ... -->
  <!-- ... status-bar ... -->
  <!-- ... courier-modal ... -->

  <!-- ==================== CELEBRATION SCREEN ==================== -->
  <div class="celebration-overlay" id="celebration">
    <div class="celebration-card">
      <div class="celeb-icon" id="celeb-icon">ğŸ‰</div>
      <h2 class="celeb-title" id="celeb-title">×›×œ ×”×›×‘×•×“!</h2>
      <p class="celeb-subtitle" id="celeb-subtitle">×”×©×œ××ª ××ª ×›×œ ×”×©×™×‘×•×¦×™×</p>
      
      <div class="progress-dots" id="celeb-progress"></div>
      
      <div class="results-comparison">
        <div class="result-card user">
          <div class="result-label">×”×¤×ª×¨×•×Ÿ ×©×œ×š</div>
          <div class="result-time" id="result-user-time">00:00</div>
          <div class="result-sub" id="result-user-sub">×–××Ÿ ×©×™×‘×•×¥: 00:00</div>
        </div>
        <div class="result-card optimal">
          <div class="result-label">×”×¤×ª×¨×•×Ÿ ×”××•×¤×˜×™××œ×™</div>
          <div class="result-time" id="result-optimal-time">00:00</div>
          <div class="result-sub" id="result-optimal-sub">×—×•×©×‘ ×‘-0.00 ms</div>
        </div>
      </div>
      
      <div class="comparison-message" id="comparison-message"></div>
      
      <div class="optimal-assignments" id="optimal-assignments">
        <div class="optimal-title">ğŸ† ×”×©×™×‘×•×¥ ×”××•×¤×˜×™××œ×™:</div>
        <div class="optimal-list" id="optimal-list"></div>
      </div>
      
      <div class="insight-box">
        <div class="insight-title">ğŸ’¡ ×œ××” ×–×” ×—×©×•×‘?</div>
        <div class="insight-text" id="insight-text">
          ×‘××©×—×§ ×–×” ×©×™×‘×¦×ª ×¨×§ 4 ×©×œ×™×—×™×. 
          ×‘×—×‘×¨×•×ª ×›××• ×•×•×œ×˜ ×™×© ××œ×¤×™ ×©×œ×™×—×™× ×•×”×–×× ×•×ª ×‘×•-×–×× ×™×ª!
          <br><br>
          ×›××Ÿ × ×›× ×¡ ×”××”× ×“×¡ ×ª×¢×©×™×™×” ×•× ×™×”×•×œ - ×œ×‘× ×•×ª ××œ×’×•×¨×™×ª××™× ×©×—×•×¡×›×™× ×©×¢×•×ª ×™×§×¨×•×ª ×›×œ ×™×•×.
        </div>
      </div>

      <!-- ğŸ”» ×¤×” ×”×©×™× ×•×™ ×”×¢×™×§×¨×™: ×©× ×™ ×›×¤×ª×•×¨×™× ×‘××§×•× ××—×“ ğŸ”» -->
      <div style="display:flex; flex-direction:column; gap:10px; align-items:center; margin-top:10px;">
        <button class="play-again-btn" style="font-size:16px; padding:12px 40px;" onclick="resetGame()">
          ğŸ” ×©×—×§ ×©×•×‘ ××ª ×”××©×—×§
        </button>

        <button class="play-again-btn" style="background:linear-gradient(135deg,#4CAF50,#66BB6A); font-size:16px; padding:12px 40px;" onclick="finishHungarianGame()">
          âœ… ×”××©×š ×œ×ª×—× ×” ×”×‘××” ×‘×—×“×¨ ×”×‘×¨×™×—×”
        </button>
      </div>
    </div>
  </div>

  <script>
    // === ×›×œ ×”×§×•×“ ×”×™×¤×” ×©×œ×š ××”×©××œ×”: ×§×•× ×¤×™×’×•×¨×¦×™×”, Hungarian Algorithm, Babylon Scene, ×•×›×•' ===
    // (×× ×™ ×œ× ××©× ×” ××•×ª×•, ×—×•×¥ ××”×¤×•× ×§×¦×™×” ×”×—×“×©×” finishHungarianGame ×‘×ª×—×ª×™×ª)

    const SPEED_UNITS_PER_SECOND = 10;
    
    const couriers = [
      { id: 1, x: -22, z: -24, color: '#FF6B6B', name: '×™×•×¡×™' },
      { id: 2, x: 23, z: -18, color: '#4ECDC4', name: '××™×›×œ' },
      { id: 3, x: -18, z: 21, color: '#45B7D1', name: '×“× ×™' },
      { id: 4, x: 26, z: 16, color: '#FFA07A', name: '×©×¨×”' }
    ];

    const orders = [
      { id: 1, restX: 2, restZ: -28, custX: 28, custZ: -24, color: '#FFD93D', restaurant: '×¤×™×¦×” ×¨×•××', family: '××©×¤×—×ª ×›×”×Ÿ' },
      { id: 2, restX: -28, restZ: 2, custX: 24, custZ: 28, color: '#6BCF7F', restaurant: '×¡×•×©×™ ×˜×•×§×™×•', family: '××©×¤×—×ª ×œ×•×™' },
      { id: 3, restX: 28, restZ: -3, custX: -24, custZ: 28, color: '#B4A7D6', restaurant: '×‘×•×¨×’×¨ ×”××•×¡', family: '××©×¤×—×ª ××‘×¨×”×' },
      { id: 4, restX: 4, restZ: 28, custX: 30, custZ: 8, color: '#FF9FF3', restaurant: '×¤×œ××¤×œ ×”×–×”×‘', family: '××©×¤×—×ª ×“×•×“' }
    ];

    let gameState = {
      started: false,
      selectedCourier: null,
      assignments: {},
      startTime: null,
      elapsedTime: 0,
      isAnimating: false,
      isComplete: false,
      algorithmTimeMs: 0
    };

    let scene, engine, canvas;
    let advancedTexture;
    let courierMeshes = [];
    let assignmentLines = {};
    let timerInterval;

    function distanceToSeconds(distance) {
      return distance / SPEED_UNITS_PER_SECOND;
    }

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
      const secs = (seconds % 60).toString().padStart(2, '0');
      return `${mins}:${secs}`;
    }

    function getCourierOrderDistance(courier, order) {
      const toRest = Math.sqrt(Math.pow(order.restX - courier.x, 2) + Math.pow(order.restZ - courier.z, 2));
      const toCust = Math.sqrt(Math.pow(order.custX - order.restX, 2) + Math.pow(order.custZ - order.restZ, 2));
      return Math.round((toRest + toCust) * 10) / 10;
    }

    function getTotalDistance() {
      let total = 0;
      Object.entries(gameState.assignments).forEach(([cId, oId]) => {
        const courier = couriers.find(c => c.id === parseInt(cId));
        const order = orders.find(o => o.id === oId);
        if (courier && order) {
          total += getCourierOrderDistance(courier, order);
        }
      });
      return Math.round(total * 10) / 10;
    }

    function hungarianAlgorithm(costMatrix) {
      const n = costMatrix.length;
      const u = new Array(n + 1).fill(0);
      const v = new Array(n + 1).fill(0);
      const p = new Array(n + 1).fill(0);
      const way = new Array(n + 1).fill(0);

      for (let i = 1; i <= n; i++) {
        p[0] = i;
        let j0 = 0;
        const minv = new Array(n + 1).fill(Infinity);
        const used = new Array(n + 1).fill(false);

        do {
          used[j0] = true;
          const i0 = p[j0];
          let delta = Infinity;
          let j1;

          for (let j = 1; j <= n; j++) {
            if (!used[j]) {
              const cur = costMatrix[i0 - 1][j - 1] - u[i0] - v[j];
              if (cur < minv[j]) {
                minv[j] = cur;
                way[j] = j0;
              }
              if (minv[j] < delta) {
                delta = minv[j];
                j1 = j;
              }
            }
          }

          for (let j = 0; j <= n; j++) {
            if (used[j]) {
              u[p[j]] += delta;
              v[j] -= delta;
            } else {
              minv[j] -= delta;
            }
          }
          j0 = j1;
        } while (p[j0] !== 0);

        do {
          const j1 = way[j0];
          p[j0] = p[j1];
          j0 = j1;
        } while (j0);
      }

      const result = [];
      for (let j = 1; j <= n; j++) {
        if (p[j] !== 0) {
          result[p[j] - 1] = j - 1;
        }
      }
      return result;
    }

    function calculateOptimalSolution() {
      const costMatrix = couriers.map(c => orders.map(o => getCourierOrderDistance(c, o)));
      const assignment = hungarianAlgorithm(costMatrix);
      
      let totalDistance = 0;
      const optimalAssignments = {};
      
      assignment.forEach((orderIndex, courierIndex) => {
        const courier = couriers[courierIndex];
        const order = orders[orderIndex];
        optimalAssignments[courier.id] = order.id;
        totalDistance += costMatrix[courierIndex][orderIndex];
      });
      
      return { assignments: optimalAssignments, distance: Math.round(totalDistance * 10) / 10 };
    }

    function enterFullscreen() {
      const elem = document.documentElement;
      if (elem.requestFullscreen) {
        elem.requestFullscreen().catch(() => {});
      } else if (elem.webkitRequestFullscreen) {
        elem.webkitRequestFullscreen();
      } else if (elem.msRequestFullscreen) {
        elem.msRequestFullscreen();
      }
    }

    function toggleHelp(show) {
      const overlay = document.getElementById('help-overlay');
      if (!overlay) return;
      if (show) overlay.classList.add('show');
      else overlay.classList.remove('show');
    }

    function startGame() {
      enterFullscreen();
      document.getElementById('splash-screen').classList.add('hidden');
      document.getElementById('game-header').style.display = 'flex';
      const statusBar = document.getElementById('status-bar');
      if (statusBar) statusBar.style.display = 'flex';
      gameState.started = true;
      if (engine) engine.resize();
    }

    function startTimer() {
      gameState.startTime = Date.now();
      timerInterval = setInterval(() => {
        if (gameState.startTime && !gameState.isComplete) {
          gameState.elapsedTime = Math.floor((Date.now() - gameState.startTime) / 1000);
        }
      }, 1000);
    }

    function openModal(courierId) {
      const courier = couriers.find(c => c.id === courierId);
      if (!courier) return;
      
      gameState.selectedCourier = courierId;
      if (!gameState.startTime) startTimer();
      
      document.getElementById('modal-avatar').style.background = courier.color;
      document.getElementById('modal-courier-name').textContent = courier.name;
      document.getElementById('modal-courier-name-2').textContent = courier.name;
      
      const assignedOrderId = gameState.assignments[courierId];
      document.getElementById('modal-courier-status').textContent = 
        assignedOrderId ? `××©×•×‘×¥ ×œ${orders.find(o => o.id === assignedOrderId).family}` : '×‘×—×¨ ××©×¤×—×” ×œ×©×œ×™×—×•×ª';
      
      const ordersList = document.getElementById('modal-orders-list');
      ordersList.innerHTML = orders.map(o => `
        <div class="order-info-item">
          <div class="order-color-dot" style="background: ${o.color}"></div>
          <div class="order-info-text"><strong>${o.family}</strong> ×”×–××™× ×• ×${o.restaurant}</div>
        </div>
      `).join('');
      
      const matrix = document.getElementById('modal-time-matrix');
      matrix.innerHTML = orders.map(o => {
        const dist = getCourierOrderDistance(courier, o);
        const secs = Math.round(distanceToSeconds(dist));
        const time = formatTime(secs);
        
        const assignedTo = Object.entries(gameState.assignments).find(([_, oId]) => oId === o.id);
        const isAssignedToThis = assignedTo && parseInt(assignedTo[0]) === courierId;
        const isAssignedToOther = assignedTo && parseInt(assignedTo[0]) !== courierId;
        
        let rowClass = 'matrix-row';
        if (isAssignedToThis) rowClass += ' assigned';
        if (isAssignedToOther) rowClass += ' assigned-other';
        
        const assignedCourier = isAssignedToOther ? couriers.find(c => c.id === parseInt(assignedTo[0])) : null;
        
        return `
          <div class="${rowClass}" onclick="${!isAssignedToOther ? `assignOrder(${o.id})` : ''}">
            <div class="matrix-row-info">
              <div class="matrix-family-dot" style="background: ${o.color}"></div>
              <div>
                <div class="matrix-family-name">${o.family}</div>
                <div class="matrix-restaurant">×“×¨×š ${o.restaurant}</div>
              </div>
            </div>
            <div class="matrix-time">
              <span>â±ï¸ ${time}</span>
              <button class="matrix-select-btn">×‘×—×¨</button>
              <span class="assigned-badge">${isAssignedToThis ? 'âœ“ ××©×•×‘×¥' : (isAssignedToOther ? assignedCourier.name : '')}</span>
            </div>
          </div>
        `;
      }).join('');
      
      document.getElementById('courier-modal').classList.add('show');
    }

    function closeModal() {
      document.getElementById('courier-modal').classList.remove('show');
      gameState.selectedCourier = null;
      updateVisuals();
    }

    function assignOrder(orderId) {
      if (!gameState.selectedCourier) return;
      
      Object.keys(gameState.assignments).forEach(cId => {
        if (gameState.assignments[cId] === orderId) {
          delete gameState.assignments[cId];
        }
      });
      
      gameState.assignments[gameState.selectedCourier] = orderId;
      
      updateUI();
      updateVisuals();
      
      const order = orders.find(o => o.id === orderId);
      const courier = couriers.find(c => c.id === gameState.selectedCourier);
      showHint(`âœ“ ${courier.name} ×™×©×œ×— ×œ${order.family} | ğŸ’¡ ×˜×™×¤: ××•×œ×™ ×©×œ×™×— ××—×¨ ×™×’×™×¢ ××”×¨ ×™×•×ª×¨?`);
      
      closeModal();
      
      if (Object.keys(gameState.assignments).length === couriers.length) {
        document.getElementById('btn-start-delivery').disabled = false;
        document.getElementById('status-message').textContent = 'ğŸ‰ ×›×œ ×”×©×œ×™×—×™× ×©×•×‘×¦×•! ×œ×—×¥ "×”×¤×¢×œ" ×œ×¨××•×ª ××ª ×”××©×œ×•×—×™×';
      }
    }

    function showHint(text) {
      const statusMsg = document.getElementById('status-message');
      if (!statusMsg) return;

      statusMsg.innerHTML = text;
      statusMsg.style.background = 'linear-gradient(135deg, #fff3e0, #ffe0b2)';
      statusMsg.style.padding = '10px 15px';
      statusMsg.style.borderRadius = '12px';
      statusMsg.style.border = '1px solid #FFB74D';
      
      setTimeout(() => {
        statusMsg.style.background = 'transparent';
        statusMsg.style.padding = '0';
        statusMsg.style.border = 'none';
        if (Object.keys(gameState.assignments).length < couriers.length) {
          statusMsg.textContent = 'ğŸ‘† ×œ×—×¥ ×¢×œ ××•×¤× ×•×¢ ×›×“×™ ×œ×‘×—×•×¨ ×©×œ×™×— ×•×œ×¨××•×ª ××ª ×–×× ×™ ×”×”×’×¢×”';
        }
      }, 4000);
    }

    function updateUI() {
      const assigned = Object.keys(gameState.assignments).length;
      document.getElementById('stat-assigned').textContent = `${assigned}/4`;
      
      const totalDist = getTotalDistance();
      const totalSecs = Math.round(distanceToSeconds(totalDist));
      document.getElementById('stat-time').textContent = formatTime(totalSecs);
    }

    function updateVisuals() {
      courierMeshes.forEach(mesh => {
        const isSelected = mesh.courierId === gameState.selectedCourier;
        const isAssigned = gameState.assignments[mesh.courierId] !== undefined;
        
        if (mesh.ringMat) {
          if (isSelected) {
            mesh.ringMat.alpha = 0.9;
            mesh.ringMat.emissiveColor = BABYLON.Color3.FromHexString('#FFD700');
          } else if (isAssigned) {
            mesh.ringMat.alpha = 0.6;
            mesh.ringMat.emissiveColor = BABYLON.Color3.FromHexString('#4CAF50');
          } else {
            mesh.ringMat.alpha = 0;
          }
        }
      });
      
      Object.values(assignmentLines).forEach(line => line.dispose());
      assignmentLines = {};
      
      Object.entries(gameState.assignments).forEach(([courierId, orderId]) => {
        const courier = couriers.find(c => c.id === parseInt(courierId));
        const order = orders.find(o => o.id === orderId);
        const courierMesh = courierMeshes.find(m => m.courierId === parseInt(courierId));
        
        if (courier && order && courierMesh) {
          const startPos = courierMesh.position;
          const points = [
            new BABYLON.Vector3(startPos.x, 2, startPos.z),
            new BABYLON.Vector3(order.restX, 2, order.restZ),
            new BABYLON.Vector3(order.custX, 2, order.custZ)
          ];
          
          const tube = BABYLON.MeshBuilder.CreateTube("line_" + courierId, {
            path: points,
            radius: 0.28,
            tessellation: 12,
            cap: BABYLON.Mesh.CAP_ALL
          }, scene);
          
          const tubeMat = new BABYLON.StandardMaterial("tubeMat_" + courierId, scene);
          tubeMat.diffuseColor = BABYLON.Color3.FromHexString(courier.color);
          tubeMat.emissiveColor = BABYLON.Color3.FromHexString(courier.color).scale(0.5);
          tubeMat.alpha = 0.85;
          tube.material = tubeMat;
          
          assignmentLines[courierId] = tube;
        }
      });
    }

    function startDeliveryAnimation() {
      if (Object.keys(gameState.assignments).length !== couriers.length) return;
      
      gameState.isAnimating = true;
      gameState.isComplete = true;
      document.getElementById('btn-start-delivery').disabled = true;
      document.getElementById('status-message').textContent = 'ğŸš€ ×”×©×œ×™×—×™× ×‘×“×¨×›×...';
      
      let completed = 0;
      
      Object.entries(gameState.assignments).forEach(([courierId, orderId]) => {
        const courierMesh = courierMeshes.find(m => m.courierId === parseInt(courierId));
        const order = orders.find(o => o.id === orderId);
        
        if (courierMesh && order) {
          const timeline = gsap.timeline({
            onComplete: () => {
              completed++;
              if (completed === couriers.length) {
                setTimeout(showCelebration, 500);
              }
            }
          });
          
          timeline.to(courierMesh.position, {
            x: order.restX,
            z: order.restZ,
            duration: 2,
            ease: "power2.inOut",
            onUpdate: () => {
              const dx = order.restX - courierMesh.position.x;
              const dz = order.restZ - courierMesh.position.z;
              if (Math.abs(dx) > 0.1 || Math.abs(dz) > 0.1) {
                courierMesh.rotation.y = Math.atan2(dx, dz);
              }
            }
          });
          
          timeline.to({}, { duration: 0.5 });
          
          timeline.to(courierMesh.position, {
            x: order.custX,
            z: order.custZ,
            duration: 2,
            ease: "power2.inOut",
            onUpdate: () => {
              const dx = order.custX - courierMesh.position.x;
              const dz = order.custZ - courierMesh.position.z;
              if (Math.abs(dx) > 0.1 || Math.abs(dz) > 0.1) {
                courierMesh.rotation.y = Math.atan2(dx, dz);
              }
            }
          });
        }
      });
    }

    function showCelebration() {
      const t0 = performance.now();
      const optimal = calculateOptimalSolution();
      const t1 = performance.now();
      gameState.algorithmTimeMs = t1 - t0;
      
      const userDist = getTotalDistance();
      const userSecs = Math.round(distanceToSeconds(userDist));
      const optimalSecs = Math.round(distanceToSeconds(optimal.distance));
      
      document.getElementById('result-user-time').textContent = formatTime(userSecs);
      document.getElementById('result-user-sub').textContent = `×–××Ÿ ×©×™×‘×•×¥: ${formatTime(gameState.elapsedTime)}`;
      document.getElementById('result-optimal-time').textContent = formatTime(optimalSecs);
      document.getElementById('result-optimal-sub').textContent = `×—×•×©×‘ ×‘-${gameState.algorithmTimeMs.toFixed(2)} ms`;
      
      const diff = userSecs - optimalSecs;
      const diffPercent = ((diff / optimalSecs) * 100).toFixed(1);
      
      let message, icon, title;
      if (diff <= 0) {
        icon = 'ğŸ†';
        title = '××•×©×œ×!';
        message = '××“×”×™×! ××¦××ª ××ª ×”×¤×ª×¨×•×Ÿ ×”××•×¤×˜×™××œ×™ ×‘×“×™×•×§ ×›××• ×”××œ×’×•×¨×™×ª× ×”×”×•× ×’×¨×™!';
      } else if (diffPercent < 15) {
        icon = 'ğŸ‰';
        title = '×›××¢×˜ ××•×©×œ×!';
        message = `×”×¤×ª×¨×•×Ÿ ×©×œ×š ××¨×•×š ×¨×§ ×‘-${formatTime(diff)} (${diffPercent}%) ××”××•×¤×˜×™××œ×™. ×™×¤×” ×××•×“!`;
      } else {
        icon = 'ğŸ’ª';
        title = '×¡×™×™××ª!';
        message = `×”×¤×ª×¨×•×Ÿ ×©×œ×š ××¨×•×š ×‘-${formatTime(diff)} (${diffPercent}%) ××”××•×¤×˜×™××œ×™. ×”××œ×’×•×¨×™×ª× ×”×”×•× ×’×¨×™ ××¦× ×“×¨×š ××”×™×¨×” ×™×•×ª×¨.`;
      }
      
      document.getElementById('celeb-icon').textContent = icon;
      document.getElementById('celeb-title').textContent = title;
      document.getElementById('comparison-message').textContent = message;
      
      const optimalList = document.getElementById('optimal-list');
      optimalList.innerHTML = Object.entries(optimal.assignments).map(([cId, oId]) => {
        const courier = couriers.find(c => c.id === parseInt(cId));
        const order = orders.find(o => o.id === oId);
        const dist = getCourierOrderDistance(courier, order);
        const secs = Math.round(distanceToSeconds(dist));
        return `
          <div class="optimal-item">
            <span style="color: ${courier.color}">â—</span>
            <span>${courier.name} â†’ ${order.family} (${formatTime(secs)})</span>
          </div>
        `;
      }).join('');
      
      document.getElementById('insight-text').innerHTML = `
        ×‘××©×—×§ ×–×” ×©×™×‘×¦×ª ×¨×§ 4 ×©×œ×™×—×™× ×•×›×‘×¨ ×™×© ×”×¤×¨×© ×©×œ ${formatTime(Math.abs(diff))}.
        <br><br>
        ×‘×—×‘×¨×•×ª ×›××• <strong>×•×•×œ×˜</strong> ×¢× ××œ×¤×™ ×©×œ×™×—×™× ×•×”×–×× ×•×ª ×‘×•-×–×× ×™×ª - ×–×” ××ª×•×¨×’× ×œ×©×¢×•×ª ×©×œ ×—×™×¡×›×•×Ÿ ×›×œ ×™×•×!
        <br><br>
        ×›××Ÿ × ×›× ×¡ ×ª×¤×§×™×“ <strong>×”××”× ×“×¡ ×ª×¢×©×™×™×” ×•× ×™×”×•×œ</strong> - ×œ×‘× ×•×ª ×•×œ×©×¤×¨ ××ª ×”××œ×’×•×¨×™×ª××™× ×•×”××¢×¨×›×•×ª ×©××™×™×¢×œ×™× ××ª ×”×ª×”×œ×™×›×™× ×”××œ×”.
      `;
      
      document.getElementById('celebration').classList.add('show');
    }

    function resetGame() {
      gameState = {
        started: true,
        selectedCourier: null,
        assignments: {},
        startTime: null,
        elapsedTime: 0,
        isAnimating: false,
        isComplete: false,
        algorithmTimeMs: 0
      };
      
      if (timerInterval) clearInterval(timerInterval);
      
      document.getElementById('stat-assigned').textContent = '0/4';
      document.getElementById('stat-time').textContent = '00:00';
      document.getElementById('btn-start-delivery').disabled = true;
      const statusMsg = document.getElementById('status-message');
      if (statusMsg) {
        statusMsg.textContent = 'ğŸ‘† ×œ×—×¥ ×¢×œ ××•×¤× ×•×¢ ×›×“×™ ×œ×‘×—×•×¨ ×©×œ×™×— ×•×œ×¨××•×ª ××ª ×–×× ×™ ×”×”×’×¢×”';
        statusMsg.style.background = 'transparent';
        statusMsg.style.padding = '0';
        statusMsg.style.border = 'none';
      }
      
      courierMeshes.forEach(mesh => {
        mesh.position = mesh.originalPosition.clone();
        mesh.rotation.y = 0;
      });
      
      Object.values(assignmentLines).forEach(line => line.dispose());
      assignmentLines = {};
      
      document.getElementById('celebration').classList.remove('show');
      const modal = document.getElementById('courier-modal');
      if (modal) modal.classList.remove('show');
      
      updateVisuals();
    }

    function createScene() {
      canvas = document.getElementById("renderCanvas");
      engine = new BABYLON.Engine(canvas, true, { antialias: true });
      scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0.94, 0.96, 0.98, 1);
      
      advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
      
      const isMobile = window.innerWidth < 768;
      const camera = new BABYLON.ArcRotateCamera(
        "camera",
        -Math.PI / 2,
        isMobile ? Math.PI / 3.5 : Math.PI / 3.2,
        isMobile ? 100 : 90,
        BABYLON.Vector3.Zero(),
        scene
      );
      camera.attachControl(canvas, true);
      camera.lowerRadiusLimit = 70;
      camera.upperRadiusLimit = 120;
      camera.lowerBetaLimit = Math.PI / 6;
      camera.upperBetaLimit = Math.PI / 2.3;
      camera.wheelPrecision = 15;
      camera.panningSensibility = isMobile ? 0 : 1000;
      
      const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
      hemi.intensity = 0.75;
      hemi.groundColor = new BABYLON.Color3(0.85, 0.88, 0.95);
      
      const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.5, -1, 0.3), scene);
      sun.position = new BABYLON.Vector3(50, 70, -50);
      sun.intensity = 0.95;
      
      const shadowGen = new BABYLON.ShadowGenerator(2048, sun);
      shadowGen.useBlurExponentialShadowMap = true;
      shadowGen.blurKernel = 32;
      shadowGen.darkness = 0.15;
      
      const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 160, height: 160 }, scene);
      const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
      groundMat.diffuseColor = new BABYLON.Color3(0.9, 0.92, 0.94);
      ground.material = groundMat;
      ground.receiveShadows = true;
      
      createRoads(scene);
      createEnvironment(scene, shadowGen);
      
      couriers.forEach(c => {
        const mesh = createMotorcycle(scene, c, shadowGen);
        courierMeshes.push(mesh);
      });
      
      orders.forEach(o => {
        createRestaurant(scene, o, shadowGen);
        createHouse(scene, o, shadowGen);
      });
      
      scene.onPointerDown = (evt, pickResult) => {
        if (gameState.isAnimating || gameState.isComplete) return;
        if (!gameState.started) return;
        
        if (pickResult.hit) {
          let parent = pickResult.pickedMesh;
          while (parent && !parent.courierId && !parent.isHouse) {
            parent = parent.parent;
          }
          
          if (parent?.courierId) {
            openModal(parent.courierId);
          }
        }
      };
      
      return scene;
    }

    function createRoads(scene) {
      const roadMat = new BABYLON.StandardMaterial("roadMat", scene);
      roadMat.diffuseColor = new BABYLON.Color3(0.38, 0.4, 0.45);

      const lineMat = new BABYLON.StandardMaterial("lineMat", scene);
      lineMat.diffuseColor = new BABYLON.Color3(1, 0.95, 0.4);
      lineMat.emissiveColor = new BABYLON.Color3(0.15, 0.14, 0.05);

      for (let i = -40; i <= 40; i += 20) {
        const roadH = BABYLON.MeshBuilder.CreateBox("roadH" + i, { width: 160, height: 0.05, depth: 12 }, scene);
        roadH.position.set(0, 0.025, i);
        roadH.material = roadMat;

        const roadV = BABYLON.MeshBuilder.CreateBox("roadV" + i, { width: 12, height: 0.05, depth: 160 }, scene);
        roadV.position.set(i, 0.025, 0);
        roadV.material = roadMat;

        for (let j = -75; j <= 75; j += 6) {
          const lineH = BABYLON.MeshBuilder.CreateBox("lineH", { width: 3.5, height: 0.06, depth: 0.25 }, scene);
          lineH.position.set(j, 0.06, i);
          lineH.material = lineMat;

          const lineV = BABYLON.MeshBuilder.CreateBox("lineV", { width: 0.25, height: 0.06, depth: 3.5 }, scene);
          lineV.position.set(i, 0.06, j);
          lineV.material = lineMat;
        }
      }
    }

    function createEnvironment(scene, shadowGen) {
      const treePositions = [[-40,-40],[40,-40],[-40,40],[40,40],[-60,0],[60,0],[0,-60],[0,60],[-60,-35],[60,35]];
      treePositions.forEach(pos => createTree(scene, pos[0], pos[1], shadowGen));

      for (let x = -30; x <= 30; x += 20) {
        for (let z = -30; z <= 30; z += 20) {
          createStreetLight(scene, x + 7, z + 7);
        }
      }
    }

    function createTree(scene, x, z, shadowGen) {
      const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk", { height: 3.5, diameter: 0.9 }, scene);
      trunk.position.set(x, 1.75, z);
      const trunkMat = new BABYLON.StandardMaterial("trunkMat", scene);
      trunkMat.diffuseColor = new BABYLON.Color3(0.5, 0.35, 0.18);
      trunk.material = trunkMat;
      shadowGen.addShadowCaster(trunk);

      const leaves = BABYLON.MeshBuilder.CreateSphere("leaves", { diameter: 6, segments: 8 }, scene);
      leaves.position.set(x, 5.5, z);
      leaves.scaling.y = 1.2;
      const leavesMat = new BABYLON.StandardMaterial("leavesMat", scene);
      leavesMat.diffuseColor = new BABYLON.Color3(0.35, 0.72, 0.38);
      leaves.material = leavesMat;
      shadowGen.addShadowCaster(leaves);
    }

    function createStreetLight(scene, x, z) {
      const poleMat = new BABYLON.StandardMaterial("poleMat", scene);
      poleMat.diffuseColor = new BABYLON.Color3(0.28, 0.28, 0.32);

      const pole = BABYLON.MeshBuilder.CreateCylinder("pole", { height: 9, diameter: 0.4 }, scene);
      pole.position.set(x, 4.5, z);
      pole.material = poleMat;

      const arm = BABYLON.MeshBuilder.CreateBox("arm", { width: 3, height: 0.25, depth: 0.25 }, scene);
      arm.position.set(x + 1.5, 9, z);
      arm.material = poleMat;

      const bulb = BABYLON.MeshBuilder.CreateSphere("bulb", { diameter: 0.7 }, scene);
      bulb.position.set(x + 3, 8.7, z);
      const bulbMat = new BABYLON.StandardMaterial("bulbMat", scene);
      bulbMat.emissiveColor = new BABYLON.Color3(1, 0.95, 0.75);
      bulb.material = bulbMat;

      const light = new BABYLON.PointLight("streetLight", new BABYLON.Vector3(x + 3, 8.5, z), scene);
      light.intensity = 0.35;
      light.range = 20;
    }

    function createMotorcycle(scene, courier, shadowGen) {
      const parent = new BABYLON.TransformNode("courier_" + courier.id, scene);
      parent.position.set(courier.x, 0, courier.z);
      parent.courierId = courier.id;
      parent.originalPosition = new BABYLON.Vector3(courier.x, 0, courier.z);

      const color = BABYLON.Color3.FromHexString(courier.color);

      const bodyMat = new BABYLON.StandardMaterial("bodyMat" + courier.id, scene);
      bodyMat.diffuseColor = color;
      bodyMat.specularPower = 64;

      const body = BABYLON.MeshBuilder.CreateBox("body", { width: 1.1, height: 0.65, depth: 2.8 }, scene);
      body.position.y = 0.85;
      body.parent = parent;
      body.material = bodyMat;
      shadowGen.addShadowCaster(body);

      const tank = BABYLON.MeshBuilder.CreateCylinder("tank", { diameter: 0.75, height: 1.3 }, scene);
      tank.rotation.x = Math.PI / 2;
      tank.position.set(0, 1.05, 0.45);
      tank.parent = parent;
      tank.material = bodyMat;
      shadowGen.addShadowCaster(tank);

      const seatMat = new BABYLON.StandardMaterial("seatMat", scene);
      seatMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);

      const seat = BABYLON.MeshBuilder.CreateBox("seat", { width: 0.75, height: 0.28, depth: 1.1 }, scene);
      seat.position.set(0, 1.28, -0.35);
      seat.parent = parent;
      seat.material = seatMat;
      shadowGen.addShadowCaster(seat);

      const wheelMat = new BABYLON.StandardMaterial("wheelMat", scene);
      wheelMat.diffuseColor = new BABYLON.Color3(0.08, 0.08, 0.08);

      const chromeMat = new BABYLON.StandardMaterial("chromeMat", scene);
      chromeMat.diffuseColor = new BABYLON.Color3(0.82, 0.82, 0.88);
      chromeMat.specularPower = 128;

      const createWheel = (zPos) => {
        const wheel = BABYLON.MeshBuilder.CreateTorus("wheel", { diameter: 1.1, thickness: 0.32, tessellation: 32 }, scene);
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(0, 0.55, zPos);
        wheel.parent = parent;
        wheel.material = wheelMat;
        shadowGen.addShadowCaster(wheel);

        const rim = BABYLON.MeshBuilder.CreateCylinder("rim", { diameter: 0.55, height: 0.28 }, scene);
        rim.rotation.x = Math.PI / 2;
        rim.position.set(0, 0.55, zPos);
        rim.parent = parent;
        rim.material = chromeMat;
        return wheel;
      };

      const frontWheel = createWheel(1.2);
      const backWheel = createWheel(-1);

      const handlebar = BABYLON.MeshBuilder.CreateCylinder("handlebar", { diameter: 0.09, height: 1.4 }, scene);
      handlebar.rotation.z = Math.PI / 2;
      handlebar.position.set(0, 1.55, 1.1);
      handlebar.parent = parent;
      handlebar.material = chromeMat;

      const headlight = BABYLON.MeshBuilder.CreateSphere("headlight", { diameter: 0.35 }, scene);
      headlight.position.set(0, 1.15, 1.45);
      headlight.parent = parent;
      const headlightMat = new BABYLON.StandardMaterial("headlightMat", scene);
      headlightMat.emissiveColor = new BABYLON.Color3(1, 1, 0.8);
      headlight.material = headlightMat;

      const taillight = BABYLON.MeshBuilder.CreateBox("taillight", { width: 0.55, height: 0.18, depth: 0.12 }, scene);
      taillight.position.set(0, 0.95, -1.45);
      taillight.parent = parent;
      const taillightMat = new BABYLON.StandardMaterial("taillightMat", scene);
      taillightMat.emissiveColor = new BABYLON.Color3(1, 0.1, 0.1);
      taillight.material = taillightMat;

      const boxMat = new BABYLON.StandardMaterial("boxMat", scene);
      boxMat.diffuseColor = new BABYLON.Color3(0.98, 0.98, 0.98);

      const deliveryBox = BABYLON.MeshBuilder.CreateBox("deliveryBox", { width: 1.5, height: 1.2, depth: 1.5 }, scene);
      deliveryBox.position.set(0, 1.75, -0.95);
      deliveryBox.parent = parent;
      deliveryBox.material = boxMat;
      shadowGen.addShadowCaster(deliveryBox);

      const ring = BABYLON.MeshBuilder.CreateTorus("ring", { diameter: 4.5, thickness: 0.22, tessellation: 64 }, scene);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = 0.15;
      ring.parent = parent;
      const ringMat = new BABYLON.StandardMaterial("ringMat", scene);
      ringMat.emissiveColor = color;
      ringMat.alpha = 0;
      ring.material = ringMat;
      parent.ringMat = ringMat;
      parent.frontWheel = frontWheel;
      parent.backWheel = backWheel;

      const isMobileDevice = window.innerWidth < 768;
      const rect = new BABYLON.GUI.Rectangle();
      rect.width = isMobileDevice ? "70px" : "80px";
      rect.height = isMobileDevice ? "24px" : "28px";
      rect.cornerRadius = 14;
      rect.color = "white";
      rect.thickness = 0;
      rect.background = courier.color;
      advancedTexture.addControl(rect);
      rect.linkWithMesh(parent);
      rect.linkOffsetY = isMobileDevice ? -50 : -70;

      const text = new BABYLON.GUI.TextBlock();
      text.text = courier.name;
      text.color = "white";
      text.fontSize = isMobileDevice ? 12 : 14;
      text.fontWeight = "bold";
      text.fontFamily = "Heebo";
      rect.addControl(text);
      parent.nameLabel = rect;

      let time = Math.random() * Math.PI * 2;
      scene.registerBeforeRender(() => {
        if (!gameState.isAnimating) {
          time += 0.04;
          parent.position.y = Math.sin(time * 2) * 0.06;
        }
        frontWheel.rotation.x += 0.03;
        backWheel.rotation.x += 0.03;
      });

      return parent;
    }

    function createRestaurant(scene, order, shadowGen) {
      const parent = new BABYLON.TransformNode("rest_" + order.id, scene);
      parent.position.set(order.restX, 0, order.restZ);

      const color = BABYLON.Color3.FromHexString(order.color);

      const baseMat = new BABYLON.StandardMaterial("baseMat" + order.id, scene);
      baseMat.diffuseColor = color.scale(0.88);

      const base = BABYLON.MeshBuilder.CreateBox("base", { width: 5.5, height: 6.5, depth: 5.5 }, scene);
      base.position.y = 3.25;
      base.parent = parent;
      base.material = baseMat;
      shadowGen.addShadowCaster(base);

      const roofMat = new BABYLON.StandardMaterial("roofMat", scene);
      roofMat.diffuseColor = new BABYLON.Color3(0.68, 0.22, 0.22);

      const roof = BABYLON.MeshBuilder.CreateCylinder("roof", { diameterTop: 0, diameterBottom: 7.5, height: 3.2, tessellation: 4 }, scene);
      roof.position.y = 8;
      roof.rotation.y = Math.PI / 4;
      roof.parent = parent;
      roof.material = roofMat;
      shadowGen.addShadowCaster(roof);

      const doorMat = new BABYLON.StandardMaterial("doorMat", scene);
      doorMat.diffuseColor = new BABYLON.Color3(0.48, 0.3, 0.14);

      const door = BABYLON.MeshBuilder.CreateBox("door", { width: 1.5, height: 3, depth: 0.15 }, scene);
      door.position.set(0, 1.5, 2.8);
      door.parent = parent;
      door.material = doorMat;

      const windowMat = new BABYLON.StandardMaterial("windowMat", scene);
      windowMat.diffuseColor = new BABYLON.Color3(0.72, 0.88, 1);
      windowMat.emissiveColor = new BABYLON.Color3(0.32, 0.42, 0.52);

      for (let i = -1; i <= 1; i += 2) {
        const win = BABYLON.MeshBuilder.CreateBox("window", { width: 1.1, height: 1.3, depth: 0.12 }, scene);
        win.position.set(i * 1.6, 4.2, 2.8);
        win.parent = parent;
        win.material = windowMat;
      }

      const signMat = new BABYLON.StandardMaterial("signMat", scene);
      signMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
      signMat.emissiveColor = color.scale(0.5);

      const sign = BABYLON.MeshBuilder.CreateBox("sign", { width: 4, height: 1.1, depth: 0.28 }, scene);
      sign.position.set(0, 5.6, 2.95);
      sign.parent = parent;
      sign.material = signMat;

      const isMobileDevice = window.innerWidth < 768;
      const rect = new BABYLON.GUI.Rectangle();
      rect.width = isMobileDevice ? "100px" : "120px";
      rect.height = isMobileDevice ? "24px" : "28px";
      rect.cornerRadius = 14;
      rect.color = "white";
      rect.thickness = 2;
      rect.background = order.color;
      advancedTexture.addControl(rect);
      rect.linkWithMesh(parent);
      rect.linkOffsetY = isMobileDevice ? -85 : -120;

      const text = new BABYLON.GUI.TextBlock();
      text.text = "ğŸ• " + order.restaurant;
      text.color = "white";
      text.fontSize = isMobileDevice ? 10 : 11;
      text.fontWeight = "bold";
      text.fontFamily = "Heebo";
      rect.addControl(text);

      const iconMat = new BABYLON.StandardMaterial("iconMat", scene);
      iconMat.diffuseColor = color;
      iconMat.emissiveColor = color.scale(0.6);

      const icon = BABYLON.MeshBuilder.CreateSphere("icon", { diameter: 2 }, scene);
      icon.position.y = 12;
      icon.parent = parent;
      icon.material = iconMat;

      let time = Math.random() * Math.PI * 2;
      scene.registerBeforeRender(() => {
        time += 0.025;
        icon.position.y = 12 + Math.sin(time) * 0.45;
        icon.rotation.y += 0.015;
      });

      return parent;
    }

    function createHouse(scene, order, shadowGen) {
      const parent = new BABYLON.TransformNode("house_" + order.id, scene);
      parent.position.set(order.custX, 0, order.custZ);
      parent.isHouse = true;
      parent.orderId = order.id;

      const color = BABYLON.Color3.FromHexString(order.color);

      const baseMat = new BABYLON.StandardMaterial("houseBaseMat", scene);
      baseMat.diffuseColor = new BABYLON.Color3(0.94, 0.9, 0.85);

      const base = BABYLON.MeshBuilder.CreateBox("houseBase", { width: 5, height: 5, depth: 5 }, scene);
      base.position.y = 2.5;
      base.parent = parent;
      base.material = baseMat;
      shadowGen.addShadowCaster(base);

      const roofMat = new BABYLON.StandardMaterial("houseRoofMat", scene);
      roofMat.diffuseColor = new BABYLON.Color3(0.58, 0.38, 0.25);

      const roof = BABYLON.MeshBuilder.CreateCylinder("houseRoof", { diameterTop: 0, diameterBottom: 7, height: 2.8, tessellation: 4 }, scene);
      roof.position.y = 6.2;
      roof.rotation.y = Math.PI / 4;
      roof.parent = parent;
      roof.material = roofMat;
      shadowGen.addShadowCaster(roof);

      const doorMat = new BABYLON.StandardMaterial("houseDoorMat", scene);
      doorMat.diffuseColor = color.scale(0.75);

      const door = BABYLON.MeshBuilder.CreateBox("houseDoor", { width: 1.3, height: 2.4, depth: 0.12 }, scene);
      door.position.set(0, 1.2, 2.55);
      door.parent = parent;
      door.material = doorMat;

      const windowMat = new BABYLON.StandardMaterial("houseWindowMat", scene);
      windowMat.diffuseColor = new BABYLON.Color3(0.62, 0.78, 0.98);
      windowMat.emissiveColor = new BABYLON.Color3(0.28, 0.38, 0.48);

      for (let i = -1; i <= 1; i += 2) {
        const win = BABYLON.MeshBuilder.CreateBox("houseWindow", { width: 0.85, height: 0.85, depth: 0.12 }, scene);
        win.position.set(i * 1.3, 3.5, 2.55);
        win.parent = parent;
        win.material = windowMat;
      }

      const isMobileDevice = window.innerWidth < 768;
      const rect = new BABYLON.GUI.Rectangle();
      rect.width = isMobileDevice ? "95px" : "110px";
      rect.height = isMobileDevice ? "24px" : "28px";
      rect.cornerRadius = 14;
      rect.color = order.color;
      rect.thickness = 2;
      rect.background = "white";
      advancedTexture.addControl(rect);
      rect.linkWithMesh(parent);
      rect.linkOffsetY = isMobileDevice ? -70 : -100;

      const text = new BABYLON.GUI.TextBlock();
      text.text = "ğŸ  " + order.family;
      text.color = "#333";
      text.fontSize = isMobileDevice ? 10 : 11;
      text.fontWeight = "bold";
      text.fontFamily = "Heebo";
      rect.addControl(text);

      const markerMat = new BABYLON.StandardMaterial("markerMat", scene);
      markerMat.diffuseColor = color;
      markerMat.emissiveColor = color.scale(0.45);

      const marker = BABYLON.MeshBuilder.CreateCylinder("marker", { diameterTop: 0.45, diameterBottom: 1.6, height: 2.8 }, scene);
      marker.position.y = 10;
      marker.parent = parent;
      marker.material = markerMat;

      let time = Math.random() * Math.PI * 2;
      scene.registerBeforeRender(() => {
        time += 0.03;
        marker.position.y = 10 + Math.sin(time) * 0.38;
      });

      return parent;
    }

    createScene();
    engine.runRenderLoop(() => scene.render());
    window.addEventListener("resize", () => engine.resize());
    document.addEventListener('fullscreenchange', () => {
      if (engine) engine.resize();
    });

    // ğŸ”¥ ×”×¤×•× ×§×¦×™×” ×”×—×“×©×” ×©××’×©×¨×ª ×œ×—×“×¨ ×”×‘×¨×™×—×” ğŸ”¥
    function finishHungarianGame() {
      try {
        if (window.parent && typeof window.parent.onHungarianGameComplete === 'function') {
          window.parent.onHungarianGameComplete();
        } else {
          // ×× ×–×” ×œ× ×¨×¥ ×‘×ª×•×š iframe ×©×œ ×—×“×¨ ×”×‘×¨×™×—×” â€“ ×¤×©×•×˜ × ×¢×©×” ×¨×™×¡×˜
          resetGame();
          alert('×¡×™×™××ª ××ª ×”××©×—×§! ×× ×”×•× ×”×™×” ××—×•×‘×¨ ×œ×—×“×¨ ×”×‘×¨×™×—×” â€“ ×”×™×™×ª ×××©×™×š ×¢×›×©×™×• ×œ×ª×—× ×” ×”×‘××” ğŸ™‚');
        }
      } catch (e) {
        console.error(e);
        resetGame();
      }
    }
  </script>
</body>
</html>
