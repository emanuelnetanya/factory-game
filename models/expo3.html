<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>×¡×™×•×¨ ×‘××¤×¢×œ ×ª×¢×©×™×™×ª×™ - ××•×‘×™×™×œ</title>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Heebo:wght@300;400;500;600;700;900&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    body {
      font-family: 'Heebo', sans-serif;
      overflow: hidden;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      position: fixed;
      width: 100%;
      height: 100%;
      overscroll-behavior: none;
    }

    #renderCanvas {
      width: 100%;
      height: 100%;
      position: fixed;
      top: 0;
      left: 0;
      outline: none;
    }

    /* Start Screen - Mobile */
    #start-screen {
      position: fixed;
      inset: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 15px;
    }

    #start-screen.hidden {
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.8s ease-out;
    }

    .start-content {
      text-align: center;
      padding: 30px 20px;
      background: rgba(255, 255, 255, 0.98);
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      max-width: 95%;
      width: 340px;
    }

    .factory-icon {
      font-size: 50px;
      margin-bottom: 15px;
      animation: bounce 2s infinite;
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    h1 {
      font-size: 26px;
      font-weight: 700;
      color: #2c3e50;
      margin-bottom: 10px;
      letter-spacing: -0.5px;
    }

    .subtitle {
      font-size: 14px;
      color: #7f8c8d;
      margin-bottom: 20px;
      font-weight: 400;
      line-height: 1.5;
    }

    #start-btn {
      padding: 14px 35px;
      font-size: 16px;
      font-weight: 600;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 30px;
      box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
      transition: all 0.3s ease;
      font-family: 'Heebo', sans-serif;
    }

    #start-btn:active {
      transform: scale(0.95);
    }

    /* Station Info - Mobile */
    .station-info {
      position: fixed;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(255, 255, 255, 0.94));
      padding: 12px 20px;
      border-radius: 18px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
      display: none;
      backdrop-filter: blur(10px);
      z-index: 100;
      text-align: center;
      max-width: 90%;
      border: 2px solid rgba(102, 126, 234, 0.2);
    }

    .station-info.show {
      display: block;
      animation: slideDown 0.5s ease;
    }

    @keyframes slideDown {
      from { 
        transform: translateX(-50%) translateY(-15px); 
        opacity: 0; 
      }
      to { 
        transform: translateX(-50%) translateY(0); 
        opacity: 1; 
      }
    }

    .station-name {
      font-size: 18px;
      margin-bottom: 6px;
      color: #667eea;
      font-weight: 700;
    }

    .station-desc {
      font-size: 12px;
      font-weight: 400;
      color: #7f8c8d;
      line-height: 1.3;
    }

    /* Instructions */
    .instructions {
      position: fixed;
      bottom: 85px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      padding: 8px 16px;
      border-radius: 18px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
      font-size: 12px;
      font-weight: 500;
      color: #7f8c8d;
      display: none;
      backdrop-filter: blur(10px);
      z-index: 99;
    }

    .instructions.show {
      display: block;
    }

    /* Next Button - Mobile Touch */
    #next-btn {
      position: fixed;
      bottom: 25px;
      left: 50%;
      transform: translateX(-50%);
      padding: 16px 40px;
      font-size: 15px;
      font-weight: 600;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 30px;
      box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
      font-family: 'Heebo', sans-serif;
      z-index: 101;
      display: none;
    }

    #next-btn.show {
      display: block;
      animation: fadeInPulse 0.6s ease;
    }

    #next-btn:active {
      transform: translateX(-50%) scale(0.92);
    }

    @keyframes fadeInPulse {
      0% { 
        opacity: 0; 
        transform: translateX(-50%) translateY(20px);
      }
      100% { 
        opacity: 1; 
        transform: translateX(-50%) translateY(0);
      }
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <!-- Start Screen -->
  <div id="start-screen">
    <div class="start-content">
      <div class="factory-icon">ğŸ­</div>
      <h1>×¡×™×•×¨ ×‘××¤×¢×œ ×ª×¢×©×™×™×ª×™</h1>
      <div class="subtitle">
        ×”×ª× ×¡×•×ª ×•×™×¨×˜×•××œ×™×ª ×‘××¤×¢×œ ×™×™×¦×•×¨ ××ª×§×“×<br/>
        ×¢×§×•×‘ ××—×¨×™ ×”×ª×—× ×•×ª ×•×œ××“ ×¢×œ ×”×ª×”×œ×™×š
      </div>
      <button id="start-btn">ğŸš€ ×”×ª×—×œ ×¡×™×•×¨</button>
    </div>
  </div>

  <!-- Station Info -->
  <div class="station-info" id="station-info">
    <div class="station-name" id="station-name"></div>
    <div class="station-desc" id="station-desc"></div>
  </div>

  <!-- Instructions -->
  <div class="instructions" id="instructions">
    ğŸ‘† ×œ×—×¥ ×¢×œ ×”×›×¤×ª×•×¨ ×œ××¢×‘×¨ ×œ×ª×—× ×” ×”×‘××”
  </div>

  <!-- Next Button for Mobile -->
  <button id="next-btn">â¤ ×”××©×š ×œ×ª×—× ×” ×”×‘××”</button>

  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true, { 
      preserveDrawingBuffer: true, 
      stencil: true,
      antialias: true 
    });

    // Mobile Scale - ×§×˜×Ÿ ×™×•×ª×¨ ×œ××•×‘×™×™×œ
    const SCALE = 0.35;

    // ========= GAME STATE =========
    const gameState = {
      isActive: false,
      currentStation: 0,
      isMoving: false,
      walkSpeed: 0.05,
      rotationSpeed: 0.12,
      waitingForInput: false
    };

    // ×ª×—× ×•×ª ×”×¡×™×•×¨
    const stations = [
      {
        position: new BABYLON.Vector3(0, 0, -20 * SCALE),
        name: "ğŸ­ ×›× ×™×¡×” ×œ××¤×¢×œ",
        description: "×‘×¨×•×›×™× ×”×‘××™× ×œ××¤×¢×œ ×”×ª×¢×©×™×™×ª×™ ×”××ª×§×“×",
        hasInfo: false
      },
      {
        position: new BABYLON.Vector3(0, 0, -12 * SCALE),
        name: "ğŸ“‹ ××–×•×¨ ×§×‘×œ×”",
        description: "×›××Ÿ ××ª×—×™×œ ×ª×”×œ×™×š ×”×™×™×¦×•×¨",
        hasInfo: true
      },
      {
        position: new BABYLON.Vector3(-12 * SCALE, 0, -6 * SCALE),
        name: "ğŸ”§ ××›×•× ×ª CNC",
        description: "××›×•× ×ª ×›×¨×¡×•× ×××•×—×©×‘×ª ×œ×¢×™×‘×•×“ ××“×•×™×§",
        hasInfo: true
      },
      {
        position: new BABYLON.Vector3(-12 * SCALE, 0, 3 * SCALE),
        name: "ğŸ“¦ ×§×• ×™×™×¦×•×¨",
        description: "××¡×•×¢ ××•×˜×•××˜×™ ×œ×”×¢×‘×¨×ª ××•×¦×¨×™×",
        hasInfo: true
      },
      {
        position: new BABYLON.Vector3(-12 * SCALE, 5.5 * SCALE, 12 * SCALE),
        name: "ğŸ¤– ×¨×•×‘×•×˜ ×¨×™×ª×•×š",
        description: "×–×¨×•×¢ ×¨×•×‘×•×˜×™×ª ×œ×¨×™×ª×•×š ××“×•×™×§",
        hasInfo: true
      },
      {
        position: new BABYLON.Vector3(0, 5.5 * SCALE, 14 * SCALE),
        name: "ğŸŒ‰ ×’×©×¨ ×ª×¦×¤×™×ª",
        description: "× ×§×•×“×ª ×ª×¦×¤×™×ª ×¢×œ ×¨×¦×¤×ª ×”×™×™×¦×•×¨",
        hasInfo: false
      },
      {
        position: new BABYLON.Vector3(12 * SCALE, 5.5 * SCALE, 12 * SCALE),
        name: "ğŸ“¦ ××¨×™×–×” ××•×˜×•××˜×™×ª",
        description: "××¢×¨×›×ª ××¨×™×–×” ×××•×—×©×‘×ª",
        hasInfo: true
      },
      {
        position: new BABYLON.Vector3(12 * SCALE, 0, 3 * SCALE),
        name: "ğŸ” ×‘×§×¨×ª ××™×›×•×ª",
        description: "×‘×“×™×§×” ×•××™×•×Ÿ ××•×¦×¨×™×",
        hasInfo: true
      },
      {
        position: new BABYLON.Vector3(12 * SCALE, 0, -6 * SCALE),
        name: "ğŸ“¦ ××—×¡×Ÿ ×—×›×",
        description: "××—×¡×•×Ÿ ××•×˜×•××˜×™ ×©×œ ××•×¦×¨×™×",
        hasInfo: true
      },
      {
        position: new BABYLON.Vector3(0, 0, -12 * SCALE),
        name: "ğŸ ×¡×™×•× ×”×¡×™×•×¨",
        description: "×ª×•×“×” ×©×‘×™×§×¨×ª× ×‘××¤×¢×œ ×©×œ× ×•!",
        hasInfo: true
      }
    ];

    let scene, camera, playerRoot, playerBody, playerHead;
    let leftArm, rightArm, leftLeg, rightLeg;
    let advancedTexture;

    // ×“×œ×ª ×•×¤×œ×’ ×™×¦×™××”
    let entranceDoor = null;
    let exitStationAdded = false;

    // ========= CREATE SCENE =========
    function createScene() {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3(0.92, 0.94, 0.97);
      
      // ×¢×¨×¤×œ ××˜××•×¡×¤×¨×™
      scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
      scene.fogDensity = 0.015;
      scene.fogColor = new BABYLON.Color3(0.9, 0.92, 0.95);

      // ×ª××•×¨×”
      const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
      hemi.intensity = 0.8;
      hemi.diffuse = new BABYLON.Color3(1, 1, 1);
      hemi.groundColor = new BABYLON.Color3(0.5, 0.5, 0.55);

      const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.5, -1, 0.5), scene);
      sun.intensity = 1.2;
      sun.position = new BABYLON.Vector3(20 * SCALE, 30 * SCALE, -20 * SCALE);

      // ××¦×œ××” ×××—×•×¨×”/××¢×œ ×”×©×—×§×Ÿ
      camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(0, 10 * SCALE, -18 * SCALE), scene);
      camera.setTarget(new BABYLON.Vector3(0, 0, 0));
      scene.activeCamera = camera;

      // GUI
      advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

      // ×¨×¦×¤×” ×¢× ×˜×§×¡×˜×•×¨×”
      createFloor(scene);

      // ×‘× ×™×™×Ÿ ×”××¤×¢×œ
      createBuilding(scene);

      // ××“×¨×’×•×ª ××ª×•×§× ×•×ª
      createStairs(scene);

      // ××›×•× ×•×ª ××©×•×¤×¨×•×ª
      createMachines(scene);

      // ×“××•×ª ×”×©×—×§×Ÿ
      createPlayer(scene);

      return scene;
    }

    // ========= ×¨×¦×¤×” ×¢× ×˜×§×¡×˜×•×¨×” =========
    function createFloor(scene) {
      const ground = BABYLON.MeshBuilder.CreateGround("ground", { 
        width: 60 * SCALE, 
        height: 60 * SCALE 
      }, scene);
      
      const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
      groundMat.diffuseColor = new BABYLON.Color3(0.75, 0.78, 0.82);
      groundMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
      
      // ×˜×§×¡×˜×•×¨×ª ×¨×¦×¤×ª ×‘×˜×•×Ÿ
      const groundTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/floor.png", scene);
      groundTexture.uScale = 12;
      groundTexture.vScale = 12;
      groundMat.diffuseTexture = groundTexture;
      groundMat.bumpTexture = groundTexture;
      groundMat.bumpTexture.level = 0.3;
      
      ground.material = groundMat;
      ground.receiveShadows = true;

      // ×§×•×•×™ ×¡×™××•×Ÿ ×¦×”×•×‘×™×
      for (let i = -2; i <= 2; i++) {
        if (i !== 0) {
          const line = BABYLON.MeshBuilder.CreateBox("line" + i, {
            width: 40 * SCALE,
            height: 0.02 * SCALE,
            depth: 0.15 * SCALE
          }, scene);
          line.position = new BABYLON.Vector3(i * 6 * SCALE, 0.01 * SCALE, 0);
          
          const lineMat = new BABYLON.StandardMaterial("lineMat", scene);
          lineMat.diffuseColor = new BABYLON.Color3(1, 0.85, 0);
          lineMat.emissiveColor = new BABYLON.Color3(0.5, 0.4, 0);
          line.material = lineMat;
        }
      }
    }

    // ========= ×‘× ×™×™×Ÿ ×”××¤×¢×œ =========
    function createBuilding(scene) {
      const wallHeight = 15 * SCALE;
      const wallMat = new BABYLON.StandardMaterial("wallMat", scene);
      wallMat.diffuseColor = new BABYLON.Color3(0.95, 0.95, 0.97);
      wallMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);

      // ×§×™×¨×•×ª
      const walls = [
        { width: 0.5 * SCALE, height: wallHeight, depth: 45 * SCALE, x: -20 * SCALE, z: 0 },
        { width: 0.5 * SCALE, height: wallHeight, depth: 45 * SCALE, x: 20 * SCALE, z: 0 },
        { width: 40 * SCALE, height: wallHeight, depth: 0.5 * SCALE, x: 0, z: 18 * SCALE },
        { width: 13 * SCALE, height: wallHeight, depth: 0.5 * SCALE, x: -13.5 * SCALE, z: -18 * SCALE },
        { width: 13 * SCALE, height: wallHeight, depth: 0.5 * SCALE, x: 13.5 * SCALE, z: -18 * SCALE }
      ];

      walls.forEach((w, i) => {
        const wall = BABYLON.MeshBuilder.CreateBox("wall" + i, w, scene);
        wall.position = new BABYLON.Vector3(w.x, wallHeight / 2, w.z);
        wall.material = wallMat;
      });

      // ×›×™×ª×•×‘×™× ×¢×œ ×”×§×™×¨×•×ª - ××©×•×•××•×ª ×™×™×¦×•×¨
      createWallTexts(scene, wallHeight);

      // ×©×¢×¨ ×›× ×™×¡×” ×¢× ×©×œ×˜ ×ª×œ×ª ××™××“×™ + ×“×œ×ª
      createEntrance(scene);

      // ×ª×§×¨×” ×©×§×•×¤×”
      const roof = BABYLON.MeshBuilder.CreateBox("roof", { 
        width: 40 * SCALE, 
        height: 0.3 * SCALE, 
        depth: 45 * SCALE 
      }, scene);
      roof.position.y = wallHeight;
      
      const roofMat = new BABYLON.StandardMaterial("roofMat", scene);
      roofMat.diffuseColor = new BABYLON.Color3(0.8, 0.85, 0.9);
      roofMat.alpha = 0.2;
      roofMat.specularColor = new BABYLON.Color3(1, 1, 1);
      roof.material = roofMat;

      // ×—×œ×•× ×•×ª
      createWindows(scene, wallHeight);
    }

    // ×©×¢×¨ ×›× ×™×¡×” ××¨×©×™× + ×“×œ×ª
    function createEntrance(scene) {
      // ××¡×’×¨×ª ×”×©×¢×¨
      const entranceFrame = BABYLON.MeshBuilder.CreateBox("entranceFrame", {
        width: 12 * SCALE,
        height: 5 * SCALE,
        depth: 0.4 * SCALE
      }, scene);
      entranceFrame.position = new BABYLON.Vector3(0, 7.5 * SCALE, -18.2 * SCALE);
      
      const frameMat = new BABYLON.StandardMaterial("frameMat", scene);
      frameMat.diffuseColor = new BABYLON.Color3(0.2, 0.3, 0.6);
      frameMat.metallic = 0.9;
      entranceFrame.material = frameMat;

      // ×©×œ×˜ ×ª×œ×ª ××™××“×™ - "××¤×¢×œ ×˜×›× ×•×œ×•×’×™×•×ª ××ª×§×“××•×ª"
      const signBoard = BABYLON.MeshBuilder.CreateBox("signBoard", {
        width: 10 * SCALE,
        height: 2 * SCALE,
        depth: 0.3 * SCALE
      }, scene);
      signBoard.position = new BABYLON.Vector3(0, 9 * SCALE, -18.35 * SCALE);
      
      const signMat = new BABYLON.StandardMaterial("signMat", scene);
      signMat.diffuseColor = new BABYLON.Color3(0.15, 0.35, 0.75);
      signMat.emissiveColor = new BABYLON.Color3(0.1, 0.2, 0.4);
      signBoard.material = signMat;

      // ×˜×§×¡×˜ ×¢×œ ×”×©×œ×˜
      const signText = new BABYLON.GUI.TextBlock();
      signText.text = "ğŸ­ ××¤×¢×œ ×˜×›× ×•×œ×•×’×™×•×ª ××ª×§×“××•×ª ğŸ­";
      signText.color = "white";
      signText.fontSize = 24;
      signText.fontWeight = "bold";
      signText.fontFamily = "Heebo";
      
      const rect = new BABYLON.GUI.Rectangle();
      rect.width = "300px";
      rect.height = "50px";
      rect.thickness = 0;
      rect.background = "transparent";
      rect.addControl(signText);
      
      advancedTexture.addControl(rect);
      rect.linkWithMesh(signBoard);
      rect.linkOffsetY = 0;

      /* === ×“×œ×ª ×¤×™×–×™×ª ×¢× ×›×™×ª×•×‘ "×›× ×™×¡×”" === */
      entranceDoor = BABYLON.MeshBuilder.CreateBox("entranceDoor", {
        width: 6 * SCALE,
        height: 4.5 * SCALE,
        depth: 0.3 * SCALE
      }, scene);
      entranceDoor.position = new BABYLON.Vector3(0, 4.5 * SCALE, -18 * SCALE + 0.2 * SCALE);

      const doorMat = new BABYLON.StandardMaterial("doorMat", scene);
      doorMat.diffuseColor = new BABYLON.Color3(0.22, 0.32, 0.55);
      doorMat.specularColor = new BABYLON.Color3(0.6, 0.6, 0.8);
      entranceDoor.material = doorMat;

      // ×¦×™×¨ ×‘×¦×“ ×™××™×Ÿ
      entranceDoor.setPivotPoint(new BABYLON.Vector3(3 * SCALE, 0, 0));

      // ×›×™×ª×•×‘ ×¢×œ ×”×“×œ×ª
      const doorText = new BABYLON.GUI.TextBlock();
      doorText.text = "×›× ×™×¡×”";
      doorText.color = "white";
      doorText.fontSize = 26;
      doorText.fontWeight = "bold";
      doorText.fontFamily = "Heebo";

      const doorRect = new BABYLON.GUI.Rectangle();
      doorRect.width = "120px";
      doorRect.height = "40px";
      doorRect.thickness = 0;
      doorRect.background = "transparent";
      doorRect.addControl(doorText);

      advancedTexture.addControl(doorRect);
      doorRect.linkWithMesh(entranceDoor);
      doorRect.linkOffsetY = -40;
    }

    // ×¤×•× ×§×¦×™×•×ª ×œ×¤×ª×™×—×ª/×¡×’×™×¨×ª ×“×œ×ª
    function openDoor() {
      if (!entranceDoor) return;
      gsap.to(entranceDoor.rotation, {
        y: -Math.PI / 2,
        duration: 0.9,
        ease: "power2.inOut"
      });
    }

    function closeDoor() {
      if (!entranceDoor) return;
      gsap.to(entranceDoor.rotation, {
        y: 0,
        duration: 0.9,
        ease: "power2.inOut"
      });
    }

    // ×›×™×ª×•×‘×™× ×¢×œ ×§×™×¨×•×ª
    function createWallTexts(scene, wallHeight) {
      // ××©×•×•××•×ª ×™×™×¦×•×¨ ×¢×œ ×”×§×™×¨ ×”×©×××œ×™
      const equations = [
        "OEE = A Ã— P Ã— Q",
        "Takt Time = Available Time / Customer Demand",
        "Cp = (USL - LSL) / 6Ïƒ",
        "Lead Time = WIP / Throughput"
      ];

      equations.forEach((eq, i) => {
        const textPlane = BABYLON.MeshBuilder.CreatePlane("equation" + i, {
          width: 4 * SCALE,
          height: 1 * SCALE
        }, scene);
        textPlane.position = new BABYLON.Vector3(-19.9 * SCALE, (10 - i * 2) * SCALE, (-10 + i * 5) * SCALE);
        textPlane.rotation.y = Math.PI / 2;
        
        const textMat = new BABYLON.StandardMaterial("textMat" + i, scene);
        textMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.3);
        textMat.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.15);
        textPlane.material = textMat;
        
        // GUI text
        const text = new BABYLON.GUI.TextBlock();
        text.text = eq;
        text.color = "white";
        text.fontSize = 16;
        text.fontFamily = "monospace";
        
        const textRect = new BABYLON.GUI.Rectangle();
        textRect.width = "200px";
        textRect.height = "40px";
        textRect.thickness = 0;
        textRect.addControl(text);
        
        advancedTexture.addControl(textRect);
        textRect.linkWithMesh(textPlane);
      });
    }

    // ========= ×—×œ×•× ×•×ª =========
    function createWindows(scene, wallHeight) {
      const windowMat = new BABYLON.StandardMaterial("windowMat", scene);
      windowMat.diffuseColor = new BABYLON.Color3(0.7, 0.85, 1);
      windowMat.alpha = 0.4;
      windowMat.specularColor = new BABYLON.Color3(1, 1, 1);

      for (let i = 0; i < 3; i++) {
        // ×—×œ×•× ×•×ª ×©×××œ
        const winL = BABYLON.MeshBuilder.CreateBox("winL" + i, {
          width: 0.1 * SCALE,
          height: 3 * SCALE,
          depth: 4 * SCALE
        }, scene);
        winL.position = new BABYLON.Vector3(-20 * SCALE, 7 * SCALE, (-10 + i * 10) * SCALE);
        winL.material = windowMat;

        // ×—×œ×•× ×•×ª ×™××™×Ÿ
        const winR = BABYLON.MeshBuilder.CreateBox("winR" + i, {
          width: 0.1 * SCALE,
          height: 3 * SCALE,
          depth: 4 * SCALE
        }, scene);
        winR.position = new BABYLON.Vector3(20 * SCALE, 7 * SCALE, (-10 + i * 10) * SCALE);
        winR.material = windowMat;
      }
    }

    // ========= ××“×¨×’×•×ª =========
    function createStairs(scene) {
      const stairMat = new BABYLON.StandardMaterial("stairMat", scene);
      stairMat.diffuseColor = new BABYLON.Color3(0.55, 0.57, 0.6);
      stairMat.metallic = 0.7;

      const stairCount = 14;
      const stairHeight = 0.25 * SCALE;
      const stairDepth = 0.6 * SCALE;
      const stairWidth = 3.5 * SCALE;
      const platformHeight = 3.5 * SCALE; // ×’×•×‘×” ×”×’×©×¨ ××•×’×‘×”

      // ××“×¨×’×•×ª ×©×××œ - ×¢×•×œ×•×ª
      for (let i = 0; i < stairCount; i++) {
        const stair = BABYLON.MeshBuilder.CreateBox("stairL" + i, {
          width: stairWidth,
          height: stairHeight,
          depth: stairDepth
        }, scene);
        stair.position = new BABYLON.Vector3(
          -12 * SCALE, 
          stairHeight / 2 + i * stairHeight, 
          7 * SCALE + i * stairDepth
        );
        stair.material = stairMat;
      }

      // ××“×¨×’×•×ª ×™××™×Ÿ - ×™×•×¨×“×•×ª ××”×’×©×¨ (×ª×™×§×•×Ÿ ××œ×)
      for (let i = 0; i < stairCount; i++) {
        const stair = BABYLON.MeshBuilder.CreateBox("stairR" + i, {
          width: stairWidth,
          height: stairHeight,
          depth: stairDepth
        }, scene);
        // ×”××“×¨×’×•×ª ××ª×—×™×œ×•×ª ××”×’×©×¨ ×•×™×•×¨×“×•×ª ×œ××˜×”
        stair.position = new BABYLON.Vector3(
          12 * SCALE, 
          platformHeight - stairHeight / 2 - i * stairHeight, 
          14.5 * SCALE - i * stairDepth  // ××ª×—×™×œ ××”×’×©×¨ ×•×™×•×¨×“ ××—×•×¨×”
        );
        stair.material = stairMat;
      }

      // ×¤×œ×˜×¤×•×¨××” ×¢×œ×™×•× ×” (×’×©×¨ ××•×’×‘×”)
      const platform = BABYLON.MeshBuilder.CreateBox("platform", {
        width: 30 * SCALE,
        height: 0.3 * SCALE,
        depth: 7 * SCALE
      }, scene);
      platform.position = new BABYLON.Vector3(0, platformHeight, 14 * SCALE);
      platform.material = stairMat;

      // ×¨×¦×¤×ª ×¨×©×ª ×¢×œ ×”×’×©×¨
      const meshFloor = BABYLON.MeshBuilder.CreateBox("meshFloor", {
        width: 28 * SCALE,
        height: 0.05 * SCALE,
        depth: 6.5 * SCALE
      }, scene);
      meshFloor.position = new BABYLON.Vector3(0, platformHeight + 0.17 * SCALE, 14 * SCALE);
      
      const meshMat = new BABYLON.StandardMaterial("meshMat", scene);
      meshMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.45);
      meshMat.alpha = 0.8;
      meshMat.wireframe = true;
      meshFloor.material = meshMat;

      // ××¢×§×•×ª ×‘×˜×™×—×•×ª
      createRailings(scene, stairCount, stairHeight, stairDepth, platformHeight);
    }

    // ××¢×§×•×ª
    function createRailings(scene, stairCount, stairHeight, stairDepth, platformHeight) {
      const railMat = new BABYLON.StandardMaterial("railMat", scene);
      railMat.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.85);
      railMat.metallic = 0.95;

      // ××¢×§×” ×©×××œ
      for (let i = 0; i <= stairCount; i++) {
        const rail = BABYLON.MeshBuilder.CreateCylinder("railL" + i, {
          height: 1.2 * SCALE,
          diameter: 0.08 * SCALE
        }, scene);
        rail.position = new BABYLON.Vector3(
          -14 * SCALE, 
          0.6 * SCALE + i * stairHeight, 
          7 * SCALE + i * stairDepth
        );
        rail.material = railMat;
      }

      // ××¢×§×” ×™××™×Ÿ
      for (let i = 0; i <= stairCount; i++) {
        const rail = BABYLON.MeshBuilder.CreateCylinder("railR" + i, {
          height: 1.2 * SCALE,
          diameter: 0.08 * SCALE
        }, scene);
        rail.position = new BABYLON.Vector3(
          14 * SCALE,
          platformHeight + 0.6 * SCALE - i * stairHeight,
          14.5 * SCALE - i * stairDepth
        );
        rail.material = railMat;
      }

      // ××¢×§×” ×’×©×¨
      for (let side of [-1, 1]) {
        for (let i = 0; i < 10; i++) {
          const bridgeRail = BABYLON.MeshBuilder.CreateCylinder("bridgeRail", {
            height: 1 * SCALE,
            diameter: 0.08 * SCALE
          }, scene);
          bridgeRail.position = new BABYLON.Vector3(
            side * 14 * SCALE,
            platformHeight + 0.5 * SCALE,
            10 * SCALE + i * 0.8 * SCALE
          );
          bridgeRail.material = railMat;
        }
      }
    }

    // ========= ××›×•× ×•×ª =========
    function createMachines(scene) {
      // ××›×•× ×ª CNC
      createCNCMachine(scene, new BABYLON.Vector3(-12 * SCALE, 0, -6 * SCALE));
      
      // ×§×• ×™×™×¦×•×¨
      createConveyorBelt(scene, new BABYLON.Vector3(-12 * SCALE, 0, 3 * SCALE));
      
      // ×¨×•×‘×•×˜ ×¨×™×ª×•×š
      createWeldingRobot(scene, new BABYLON.Vector3(-12 * SCALE, 3.5 * SCALE, 12 * SCALE));
      
      // ××›×•× ×ª ××¨×™×–×”
      createPackagingMachine(scene, new BABYLON.Vector3(12 * SCALE, 3.5 * SCALE, 12 * SCALE));
      
      // ×‘×§×¨×ª ××™×›×•×ª
      createQualityControl(scene, new BABYLON.Vector3(12 * SCALE, 0, 3 * SCALE));
      
      // ××—×¡×Ÿ ×¨×•×‘×•×˜×™
      createWarehouse(scene, new BABYLON.Vector3(12 * SCALE, 0, -6 * SCALE));
    }

    // ××›×•× ×ª CNC ×¢× ×¤×¨×˜×™× ××©×•×¤×¨×™×
    function createCNCMachine(scene, position) {
      const machine = new BABYLON.TransformNode("cnc", scene);
      machine.position = position;

      // ×‘×¡×™×¡ ××¡×™×‘×™
      const base = BABYLON.MeshBuilder.CreateBox("cncBase", { 
        width: 3.5 * SCALE, 
        height: 0.7 * SCALE, 
        depth: 2.5 * SCALE 
      }, scene);
      base.position.y = 0.35 * SCALE;
      base.parent = machine;
      
      const baseMat = new BABYLON.StandardMaterial("cncBaseMat", scene);
      baseMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.25);
      baseMat.metallic = 0.9;
      baseMat.roughness = 0.2;
      base.material = baseMat;

      // ×’×•×£ ×”××›×•× ×”
      const body = BABYLON.MeshBuilder.CreateBox("cncBody", { 
        width: 3 * SCALE, 
        height: 2.5 * SCALE, 
        depth: 2 * SCALE 
      }, scene);
      body.position.y = 1.8 * SCALE;
      body.parent = machine;
      
      const bodyMat = new BABYLON.StandardMaterial("cncBodyMat", scene);
      bodyMat.diffuseColor = new BABYLON.Color3(0.9, 0.92, 0.95);
      bodyMat.specularColor = new BABYLON.Color3(0.6, 0.6, 0.6);
      body.material = bodyMat;

      // === ×ª×•×¡×¤×ª: ×—×œ×•×Ÿ ×§×“××™ + ×©×•×œ×—×Ÿ ×¤× ×™××™ + ×—×•××¨ ×’×œ× ===
      const windowPlane = BABYLON.MeshBuilder.CreatePlane("cncWindow", {
        width: 2.4 * SCALE,
        height: 1.4 * SCALE
      }, scene);
      windowPlane.position = new BABYLON.Vector3(0, 2.0 * SCALE, 1.05 * SCALE);
      windowPlane.parent = machine;

      const windowMat = new BABYLON.StandardMaterial("cncWindowMat", scene);
      windowMat.diffuseColor = new BABYLON.Color3(0.5, 0.7, 1);
      windowMat.alpha = 0.45;
      windowMat.specularColor = new BABYLON.Color3(1, 1, 1);
      windowPlane.material = windowMat;

      const workTable = BABYLON.MeshBuilder.CreateBox("cncWorkTable", {
        width: 2.2 * SCALE,
        height: 0.12 * SCALE,
        depth: 1.0 * SCALE
      }, scene);
      workTable.position = new BABYLON.Vector3(0, 1.2 * SCALE, 0.4 * SCALE);
      workTable.parent = machine;

      const workTableMat = new BABYLON.StandardMaterial("workTableMat", scene);
      workTableMat.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.3);
      workTableMat.metallic = 0.7;
      workTable.material = workTableMat;

      const workPiece = BABYLON.MeshBuilder.CreateBox("cncWorkPiece", {
        width: 0.7 * SCALE,
        height: 0.25 * SCALE,
        depth: 0.7 * SCALE
      }, scene);
      workPiece.position = new BABYLON.Vector3(-0.7 * SCALE, 1.35 * SCALE, 0.4 * SCALE);
      workPiece.parent = machine;

      const workPieceMat = new BABYLON.StandardMaterial("workPieceMat", scene);
      workPieceMat.diffuseColor = new BABYLON.Color3(0.8, 0.7, 0.5);
      workPiece.material = workPieceMat;
      // === ×¡×•×£ ×ª×•×¡×¤×ª ×—×œ×•×Ÿ ×•×©×•×œ×—×Ÿ ===

      // ×¨××© ×›×¨×¡×•× ××¡×ª×•×‘×‘ ×¢× ×›×œ×™ ×—×™×ª×•×š
      const head = BABYLON.MeshBuilder.CreateCylinder("cncHead", { 
        height: 1 * SCALE, 
        diameter: 0.5 * SCALE 
      }, scene);
      head.position = new BABYLON.Vector3(0, 3.3 * SCALE, 0);
      head.parent = machine;
      
      const headMat = new BABYLON.StandardMaterial("cncHeadMat", scene);
      headMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.45);
      headMat.metallic = 1;
      headMat.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.15);
      head.material = headMat;

      // ×›×œ×™ ×—×™×ª×•×š
      const tool = BABYLON.MeshBuilder.CreateCylinder("cncTool", { 
        height: 0.6 * SCALE, 
        diameterTop: 0.05 * SCALE,
        diameterBottom: 0.15 * SCALE
      }, scene);
      tool.position = new BABYLON.Vector3(0, 3 * SCALE, 0);
      tool.parent = machine;
      tool.material = headMat;

      // ×× ×™××¦×™×” ×§×™×™××ª: ×¡×™×‘×•×‘ ×¨××© ×•×›×œ×™
      gsap.to(head.rotation, {
        y: Math.PI * 2,
        duration: 2,
        repeat: -1,
        ease: "none"
      });

      gsap.to(tool.rotation, {
        y: -Math.PI * 4,
        duration: 1,
        repeat: -1,
        ease: "none"
      });

      // ×ª×•×¡×¤×ª: ×ª× ×•×¢×” ×‘×¦×™×¨ X ×›××• ××›×•× ×” ×©×¢×•×‘×“×ª
      const cncTimeline = gsap.timeline({ repeat: -1, yoyo: true });
      cncTimeline.to([head.position, tool.position], {
        x: 0.9 * SCALE,
        duration: 1.8,
        ease: "power1.inOut"
      }).to([head.position, tool.position], {
        x: -0.9 * SCALE,
        duration: 1.8,
        ease: "power1.inOut"
      });

      gsap.to(workPiece.position, {
        z: 0.1 * SCALE,
        duration: 1.5,
        repeat: -1,
        yoyo: true,
        ease: "sine.inOut"
      });

      // ×¤×× ×œ ×‘×§×¨×” ×“×™×’×™×˜×œ×™ ×¢× ××¡×š
      const panel = BABYLON.MeshBuilder.CreateBox("cncPanel", { 
        width: 1.2 * SCALE, 
        height: 1.5 * SCALE, 
        depth: 0.15 * SCALE 
      }, scene);
      panel.position = new BABYLON.Vector3(1.8 * SCALE, 1.3 * SCALE, 0);
      panel.parent = machine;
      
      const panelMat = new BABYLON.StandardMaterial("cncPanelMat", scene);
      panelMat.diffuseColor = new BABYLON.Color3(0.05, 0.05, 0.1);
      panelMat.emissiveColor = new BABYLON.Color3(0, 0.2, 0.4);
      panel.material = panelMat;

      // ××¡×š ×“×™×’×™×˜×œ×™
      const screen = BABYLON.MeshBuilder.CreatePlane("cncScreen", {
        width: 1 * SCALE,
        height: 0.8 * SCALE
      }, scene);
      screen.position = new BABYLON.Vector3(1.85 * SCALE, 1.5 * SCALE, 0);
      screen.parent = machine;
      
      const screenMat = new BABYLON.StandardMaterial("screenMat", scene);
      screenMat.emissiveColor = new BABYLON.Color3(0, 0.5, 0.8);
      screen.material = screenMat;

      // × ×•×¨×•×ª LED ××”×‘×”×‘×•×ª ×‘×¦×‘×¢×™× ×©×•× ×™×
      const ledColors = [
        new BABYLON.Color3(0, 1, 0.3),    // ×™×¨×•×§
        new BABYLON.Color3(1, 0.5, 0),     // ×›×ª×•×
        new BABYLON.Color3(0, 0.5, 1),     // ×›×—×•×œ
        new BABYLON.Color3(1, 0, 0)        // ××“×•×
      ];

      for (let i = 0; i < 4; i++) {
        const led = BABYLON.MeshBuilder.CreateSphere("led" + i, { 
          diameter: 0.1 * SCALE 
        }, scene);
        led.position = new BABYLON.Vector3(1.9 * SCALE, (1.7 - i * 0.25) * SCALE, 0);
        led.parent = machine;
        
        const ledMat = new BABYLON.StandardMaterial("ledMat" + i, scene);
        ledMat.emissiveColor = ledColors[i];
        led.material = ledMat;
        
        // ×× ×™××¦×™×™×ª ×”×‘×”×•×‘ ××ª×•×××ª
        gsap.to(ledMat.emissiveColor, {
          r: ledColors[i].r * 0.2,
          g: ledColors[i].g * 0.2,
          b: ledColors[i].b * 0.2,
          duration: 0.5 + i * 0.1,
          repeat: -1,
          yoyo: true,
          ease: "power2.inOut"
        });
      }

      // ×©×‘×‘×™ ××ª×›×ª
      createMetalChips(scene, position);
    }

    // ×©×‘×‘×™ ××ª×›×ª ××ª×¢×•×¤×¤×™×
    function createMetalChips(scene, position) {
      for (let i = 0; i < 5; i++) {
        const chip = BABYLON.MeshBuilder.CreateBox("chip" + i, {
          width: 0.05 * SCALE,
          height: 0.02 * SCALE,
          depth: 0.05 * SCALE
        }, scene);
        chip.position = position.add(new BABYLON.Vector3(
          (Math.random() - 0.5) * SCALE,
          0.1 * SCALE,
          (Math.random() - 0.5) * SCALE
        ));
        
        const chipMat = new BABYLON.StandardMaterial("chipMat", scene);
        chipMat.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.75);
        chipMat.metallic = 1;
        chip.material = chipMat;

        // ×× ×™××¦×™×™×ª × ×¤×™×œ×”
        gsap.to(chip.position, {
          y: 0,
          x: position.x + (Math.random() - 0.5) * 2 * SCALE,
          z: position.z + (Math.random() - 0.5) * 2 * SCALE,
          duration: 1 + Math.random(),
          repeat: -1,
          ease: "bounce.out",
          delay: Math.random() * 2
        });
      }
    }

    // ×§×• ×™×™×¦×•×¨ ×¢× ××¡×•×¢ × ×¢
    function createConveyorBelt(scene, position) {
      const conveyor = new BABYLON.TransformNode("conveyor", scene);
      conveyor.position = position;

      // ×‘×¡×™×¡ ×”××¡×•×¢
      const base = BABYLON.MeshBuilder.CreateBox("conveyorBase", { 
        width: 6 * SCALE, 
        height: 0.4 * SCALE, 
        depth: 1.8 * SCALE 
      }, scene);
      base.position.y = 0.2 * SCALE;
      base.parent = conveyor;
      
      const baseMat = new BABYLON.StandardMaterial("conveyorBaseMat", scene);
      baseMat.diffuseColor = new BABYLON.Color3(0.35, 0.35, 0.4);
      base.material = baseMat;

      // ×—×’×•×¨×ª ×”××¡×•×¢
      const belt = BABYLON.MeshBuilder.CreateBox("conveyorBelt", { 
        width: 5.8 * SCALE, 
        height: 0.15 * SCALE, 
        depth: 1.6 * SCALE 
      }, scene);
      belt.position.y = 0.5 * SCALE;
      belt.parent = conveyor;
      
      const beltMat = new BABYLON.StandardMaterial("conveyorBeltMat", scene);
      beltMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.15);
      beltMat.roughness = 0.8;
      
      // ×˜×§×¡×˜×•×¨×ª ××¡×•×¢
      const beltTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/floor.png", scene);
      beltTexture.uScale = 10;
      beltTexture.vScale = 2;
      beltMat.diffuseTexture = beltTexture;
      belt.material = beltMat;

      // ×× ×™××¦×™×™×ª ×˜×§×¡×˜×•×¨×” × ×¢×”
      scene.registerBeforeRender(() => {
        if (beltTexture) {
          beltTexture.uOffset += 0.005;
        }
      });

      // ×’×œ×’×œ×™ ××¡×•×¢
      for (let i = 0; i < 2; i++) {
        const roller = BABYLON.MeshBuilder.CreateCylinder("roller" + i, {
          height: 1.8 * SCALE,
          diameter: 0.3 * SCALE
        }, scene);
        roller.position = new BABYLON.Vector3((i * 5 - 2.5) * SCALE, 0.3 * SCALE, 0);
        roller.rotation.x = Math.PI / 2;
        roller.parent = conveyor;
        
        const rollerMat = new BABYLON.StandardMaterial("rollerMat", scene);
        rollerMat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.55);
        rollerMat.metallic = 0.9;
        roller.material = rollerMat;

        // ×¡×™×‘×•×‘ ×’×œ×’×œ×™×
        gsap.to(roller.rotation, {
          z: Math.PI * 2,
          duration: 2,
          repeat: -1,
          ease: "none"
        });
      }

      // ×§×•×¤×¡××•×ª ×¢×œ ×”××¡×•×¢ ×¢× ×ª×•×•×™×•×ª
      for (let i = 0; i < 4; i++) {
        const box = BABYLON.MeshBuilder.CreateBox("conveyorBox" + i, { 
          width: 0.6 * SCALE, 
          height: 0.6 * SCALE, 
          depth: 0.6 * SCALE 
        }, scene);
        box.position = new BABYLON.Vector3((-2 + i * 1.5) * SCALE, 0.9 * SCALE, 0);
        box.parent = conveyor;
        
        const boxMat = new BABYLON.StandardMaterial("boxMat" + i, scene);
        boxMat.diffuseColor = new BABYLON.Color3(0.8, 0.6, 0.4);
        box.material = boxMat;

        // ×ª×•×•×™×ª ×¢×œ ×”×§×•×¤×¡×
        const label = BABYLON.MeshBuilder.CreatePlane("label" + i, {
          width: 0.4 * SCALE,
          height: 0.2 * SCALE
        }, scene);
        label.position = new BABYLON.Vector3((-2 + i * 1.5) * SCALE, 0.9 * SCALE, 0.31 * SCALE);
        label.parent = conveyor;
        
        const labelMat = new BABYLON.StandardMaterial("labelMat", scene);
        labelMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
        labelMat.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.2);
        label.material = labelMat;
        
        // ×× ×™××¦×™×™×ª ×ª× ×•×¢×” ××¢×’×œ×™×ª
        const timeline = gsap.timeline({ repeat: -1 });
        timeline.to(box.position, {
          x: 2.5 * SCALE,
          duration: 3,
          ease: "none"
        }).to(box.position, {
          x: -2.5 * SCALE,
          duration: 0.01
        });
        
        timeline.to(label.position, {
          x: 2.5 * SCALE,
          duration: 3,
          ease: "none"
        }, 0).to(label.position, {
          x: -2.5 * SCALE,
          duration: 0.01
        }, 3);
      }
    }

    // ×¨×•×‘×•×˜ ×¨×™×ª×•×š ××ª×§×“× ×¢× × ×™×¦×•×¦×•×ª
    function createWeldingRobot(scene, position) {
      const robot = new BABYLON.TransformNode("robot", scene);
      robot.position = position;

      // ×‘×¡×™×¡ ×”×¨×•×‘×•×˜
      const base = BABYLON.MeshBuilder.CreateCylinder("robotBase", { 
        height: 0.6 * SCALE, 
        diameter: 1.8 * SCALE 
      }, scene);
      base.position.y = 0.3 * SCALE;
      base.parent = robot;
      
      const baseMat = new BABYLON.StandardMaterial("robotBaseMat", scene);
      baseMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.35);
      baseMat.metallic = 0.95;
      base.material = baseMat;

      // ×’×•×£ ×”×¨×•×‘×•×˜
      const body = BABYLON.MeshBuilder.CreateCylinder("robotBody", { 
        height: 1.2 * SCALE, 
        diameter: 0.8 * SCALE 
      }, scene);
      body.position.y = 1.2 * SCALE;
      body.parent = robot;
      
      const bodyMat = new BABYLON.StandardMaterial("robotBodyMat", scene);
      bodyMat.diffuseColor = new BABYLON.Color3(1, 0.6, 0.2);
      bodyMat.specularColor = new BABYLON.Color3(0.7, 0.7, 0.7);
      body.material = bodyMat;

      // ×–×¨×•×¢ ×¨××©×•× ×”
      const arm1 = BABYLON.MeshBuilder.CreateBox("robotArm1", { 
        width: 0.3 * SCALE,
        height: 1.5 * SCALE,
        depth: 0.3 * SCALE
      }, scene);
      arm1.position = new BABYLON.Vector3(0, 2.2 * SCALE, 0);
      arm1.rotation.z = Math.PI / 6;
      arm1.parent = robot;
      
      const armMat = new BABYLON.StandardMaterial("robotArmMat", scene);
      armMat.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.92);
      armMat.metallic = 1;
      arm1.material = armMat;

      // ×–×¨×•×¢ ×©× ×™×™×”
      const arm2 = BABYLON.MeshBuilder.CreateBox("robotArm2", { 
        width: 0.25 * SCALE,
        height: 1.2 * SCALE,
        depth: 0.25 * SCALE
      }, scene);
      arm2.position = new BABYLON.Vector3(0.8 * SCALE, 2.8 * SCALE, 0);
      arm2.rotation.z = -Math.PI / 4;
      arm2.parent = robot;
      arm2.material = armMat;

      // ×¨××© ×¨×™×ª×•×š
      const weldHead = BABYLON.MeshBuilder.CreateCylinder("weldHead", { 
        height: 0.4 * SCALE, 
        diameter: 0.25 * SCALE 
      }, scene);
      weldHead.position = new BABYLON.Vector3(1.2 * SCALE, 3 * SCALE, 0);
      weldHead.parent = robot;
      
      const weldMat = new BABYLON.StandardMaterial("weldMat", scene);
      weldMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.15);
      weldMat.emissiveColor = new BABYLON.Color3(0.3, 0.5, 1);
      weldHead.material = weldMat;

      // ×× ×™××¦×™×™×ª ×–×¨×•×¢×•×ª
      const tl = gsap.timeline({ repeat: -1 });
      tl.to(arm1.rotation, {
        z: -Math.PI / 6,
        duration: 2,
        ease: "power2.inOut"
      }).to(arm1.rotation, {
        z: Math.PI / 6,
        duration: 2,
        ease: "power2.inOut"
      });

      tl.to(arm2.rotation, {
        z: -Math.PI / 8,
        duration: 1.5,
        ease: "power2.inOut"
      }, 0).to(arm2.rotation, {
        z: -Math.PI / 4,
        duration: 1.5,
        ease: "power2.inOut"
      }, 1.5);

      // ××¤×§×˜ × ×™×¦×•×¦×•×ª ×¨×™×ª×•×š
      const sparks = new BABYLON.ParticleSystem("sparks", 50, scene);
      sparks.particleTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/flare.png", scene);
      sparks.emitter = weldHead;
      sparks.minEmitBox = new BABYLON.Vector3(-0.1 * SCALE, 0, -0.1 * SCALE);
      sparks.maxEmitBox = new BABYLON.Vector3(0.1 * SCALE, 0, 0.1 * SCALE);
      sparks.color1 = new BABYLON.Color4(1, 0.8, 0.2, 1);
      sparks.color2 = new BABYLON.Color4(1, 0.5, 0, 1);
      sparks.colorDead = new BABYLON.Color4(0.5, 0.2, 0, 0);
      sparks.minSize = 0.02 * SCALE;
      sparks.maxSize = 0.05 * SCALE;
      sparks.minLifeTime = 0.1;
      sparks.maxLifeTime = 0.3;
      sparks.emitRate = 30;
      sparks.gravity = new BABYLON.Vector3(0, -9.81 * SCALE, 0);
      sparks.direction1 = new BABYLON.Vector3(-1, 1, -1);
      sparks.direction2 = new BABYLON.Vector3(1, 1, 1);
      sparks.minEmitPower = 1 * SCALE;
      sparks.maxEmitPower = 3 * SCALE;
      sparks.start();

      // ××•×¨ ×¨×™×ª×•×š ××”×‘×”×‘
      const weldLight = new BABYLON.PointLight("weldLight", position.add(new BABYLON.Vector3(1.2 * SCALE, 3 * SCALE, 0)), scene);
      weldLight.diffuse = new BABYLON.Color3(0.6, 0.8, 1);
      weldLight.intensity = 8;
      weldLight.range = 10 * SCALE;

      gsap.to(weldLight, {
        intensity: 15,
        duration: 0.1,
        repeat: -1,
        yoyo: true,
        ease: "rough({ template: none.out, strength: 1, points: 20, taper: 'none', randomize: true, clamp: false})"
      });
    }

    // ××›×•× ×ª ××¨×™×–×” ×¢× ××¡×•×¢ ×™×¦×™××”
    function createPackagingMachine(scene, position) {
      const packager = new BABYLON.TransformNode("packager", scene);
      packager.position = position;

      // ××¡×’×¨×ª ×”××›×•× ×”
      const frame = BABYLON.MeshBuilder.CreateBox("packagerFrame", { 
        width: 2.5 * SCALE, 
        height: 3 * SCALE, 
        depth: 2 * SCALE 
      }, scene);
      frame.position.y = 1.5 * SCALE;
      frame.parent = packager;
      
      const frameMat = new BABYLON.StandardMaterial("packagerFrameMat", scene);
      frameMat.diffuseColor = new BABYLON.Color3(0.85, 0.87, 0.9);
      frameMat.alpha = 0.3;
      frameMat.wireframe = true;
      frame.material = frameMat;

      // ×’×•×£ ×¤× ×™××™
      const inner = BABYLON.MeshBuilder.CreateBox("packagerInner", { 
        width: 2.3 * SCALE, 
        height: 2.8 * SCALE, 
        depth: 1.8 * SCALE 
      }, scene);
      inner.position.y = 1.5 * SCALE;
      inner.parent = packager;
      
      const innerMat = new BABYLON.StandardMaterial("packagerInnerMat", scene);
      innerMat.diffuseColor = new BABYLON.Color3(0.75, 0.78, 0.82);
      inner.material = innerMat;

      // ××¡×•×¢ ×™×¦×™××”
      const exitConveyor = BABYLON.MeshBuilder.CreateBox("exitConveyor", {
        width: 3 * SCALE,
        height: 0.1 * SCALE,
        depth: 1 * SCALE
      }, scene);
      exitConveyor.position = new BABYLON.Vector3(2 * SCALE, 0.5 * SCALE, 0);
      exitConveyor.parent = packager;
      
      const exitConveyorMat = new BABYLON.StandardMaterial("exitConveyorMat", scene);
      exitConveyorMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.35);
      exitConveyor.material = exitConveyorMat;

      // ×–×¨×•×¢×•×ª ××¨×™×–×”
      for (let i = 0; i < 2; i++) {
        const arm = BABYLON.MeshBuilder.CreateBox("packArm" + i, { 
          width: 0.25 * SCALE, 
          height: 1.5 * SCALE, 
          depth: 0.25 * SCALE 
        }, scene);
        arm.position = new BABYLON.Vector3((i - 0.5) * 1.5 * SCALE, 2 * SCALE, 0);
        arm.parent = packager;
        
        const armMat = new BABYLON.StandardMaterial("packArmMat", scene);
        armMat.diffuseColor = new BABYLON.Color3(0.4, 0.6, 0.85);
        armMat.metallic = 0.8;
        arm.material = armMat;

        // ×¤×™×¡×˜×•×Ÿ ×‘×§×¦×”
        const piston = BABYLON.MeshBuilder.CreateCylinder("piston" + i, {
          height: 0.3 * SCALE,
          diameter: 0.15 * SCALE
        }, scene);
        piston.position = new BABYLON.Vector3((i - 0.5) * 1.5 * SCALE, 1.2 * SCALE, 0);
        piston.parent = packager;
        piston.material = armMat;
        
        // ×× ×™××¦×™×™×ª ×–×¨×•×¢×•×ª
        gsap.to(arm.position, {
          y: 1 * SCALE,
          duration: 1.2,
          delay: i * 0.6,
          repeat: -1,
          yoyo: true,
          ease: "power2.inOut"
        });

        gsap.to(piston.position, {
          y: 0.2 * SCALE,
          duration: 1.2,
          delay: i * 0.6,
          repeat: -1,
          yoyo: true,
          ease: "power2.inOut"
        });
      }

      // ×§×•×¤×¡××•×ª ××¨×•×–×•×ª ×™×•×¦××•×ª
      for (let i = 0; i < 2; i++) {
        const packedBox = BABYLON.MeshBuilder.CreateBox("packedBox" + i, {
          width: 0.5 * SCALE,
          height: 0.5 * SCALE,
          depth: 0.5 * SCALE
        }, scene);
        packedBox.position = new BABYLON.Vector3((1.5 + i * 0.8) * SCALE, 0.8 * SCALE, 0);
        packedBox.parent = packager;
        
        const packedBoxMat = new BABYLON.StandardMaterial("packedBoxMat", scene);
        packedBoxMat.diffuseColor = new BABYLON.Color3(0.6, 0.8, 0.4);
        packedBox.material = packedBoxMat;

        // ×ª× ×•×¢×” ×¢×œ ×”××¡×•×¢
        gsap.to(packedBox.position, {
          x: 4 * SCALE,
          duration: 3,
          delay: i * 1.5,
          repeat: -1,
          ease: "none",
          onRepeat: function() {
            packedBox.position.x = 0;
          }
        });
      }
    }

    // ×‘×§×¨×ª ××™×›×•×ª ×¢× ×¡×•×¨×§ ×œ×™×™×–×¨
    function createQualityControl(scene, position) {
      const qc = new BABYLON.TransformNode("qc", scene);
      qc.position = position;

      // ×©×•×œ×—×Ÿ ×‘×“×™×§×”
      const desk = BABYLON.MeshBuilder.CreateBox("qcDesk", { 
        width: 2.5 * SCALE, 
        height: 0.7 * SCALE, 
        depth: 1.5 * SCALE 
      }, scene);
      desk.position.y = 0.35 * SCALE;
      desk.parent = qc;
      
      const deskMat = new BABYLON.StandardMaterial("qcDeskMat", scene);
      deskMat.diffuseColor = new BABYLON.Color3(0.95, 0.95, 0.97);
      desk.material = deskMat;

      // ××¡×š ×‘×§×¨×” ×¢× ×§
      const screen = BABYLON.MeshBuilder.CreateBox("qcScreen", { 
        width: 1.5 * SCALE, 
        height: 1 * SCALE, 
        depth: 0.08 * SCALE 
      }, scene);
      screen.position = new BABYLON.Vector3(0, 1.3 * SCALE, 0);
      screen.parent = qc;
      
      const screenMat = new BABYLON.StandardMaterial("qcScreenMat", scene);
      screenMat.diffuseColor = new BABYLON.Color3(0.05, 0.05, 0.1);
      screenMat.emissiveColor = new BABYLON.Color3(0.1, 0.3, 0.5);
      screen.material = screenMat;

      // ×’×¨×¤×™× ×¢×œ ×”××¡×š
      const graph = BABYLON.MeshBuilder.CreatePlane("graph", {
        width: 1.3 * SCALE,
        height: 0.8 * SCALE
      }, scene);
      graph.position = new BABYLON.Vector3(0, 1.3 * SCALE, 0.05 * SCALE);
      graph.parent = qc;
      
      const graphMat = new BABYLON.StandardMaterial("graphMat", scene);
      graphMat.emissiveColor = new BABYLON.Color3(0, 0.8, 0.4);
      graphMat.alpha = 0.7;
      graph.material = graphMat;

      // ×× ×™××¦×™×™×ª ××¡×š
      gsap.to(screenMat.emissiveColor, {
        r: 0.2,
        g: 0.5,
        b: 0.8,
        duration: 2,
        repeat: -1,
        yoyo: true,
        ease: "sine.inOut"
      });

      // ×¡×•×¨×§ ×œ×™×™×–×¨ 3D
      const scanner = BABYLON.MeshBuilder.CreateCylinder("scanner", { 
        height: 0.6 * SCALE, 
        diameter: 0.25 * SCALE 
      }, scene);
      scanner.position = new BABYLON.Vector3(-0.7 * SCALE, 1 * SCALE, 0.4 * SCALE);
      scanner.parent = qc;
      
      const scannerMat = new BABYLON.StandardMaterial("scannerMat", scene);
      scannerMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.35);
      scannerMat.emissiveColor = new BABYLON.Color3(1, 0, 0);
      scanner.material = scannerMat;

      // ×§×¨×Ÿ ×œ×™×™×–×¨
      const laser = BABYLON.MeshBuilder.CreateCylinder("laser", { 
        height: 0.01 * SCALE, 
        diameter: 1.5 * SCALE 
      }, scene);
      laser.position = new BABYLON.Vector3(-0.7 * SCALE, 0.8 * SCALE, 0.4 * SCALE);
      laser.rotation.z = Math.PI / 2;
      laser.parent = qc;
      
      const laserMat = new BABYLON.StandardMaterial("laserMat", scene);
      laserMat.emissiveColor = new BABYLON.Color3(1, 0, 0);
      laserMat.alpha = 0.6;
      laser.material = laserMat;
      
      // ×× ×™××¦×™×™×ª ×¡×¨×™×§×” ××•×¨×›×‘×ª
      const scanTimeline = gsap.timeline({ repeat: -1 });
      scanTimeline.to(laser.position, {
        z: -0.4 * SCALE,
        duration: 2,
        ease: "none"
      }).to(laser.position, {
        z: 0.4 * SCALE,
        duration: 2,
        ease: "none"
      });

      scanTimeline.to(scanner.rotation, {
        y: Math.PI,
        duration: 4,
        ease: "none"
      }, 0);

      // ××™×§×¨×•×¡×§×•×¤ ×“×™×’×™×˜×œ×™
      const microscope = BABYLON.MeshBuilder.CreateCylinder("microscope", {
        height: 0.8 * SCALE,
        diameter: 0.2 * SCALE
      }, scene);
      microscope.position = new BABYLON.Vector3(0.6 * SCALE, 1 * SCALE, -0.3 * SCALE);
      microscope.parent = qc;
      
      const microscopeMat = new BABYLON.StandardMaterial("microscopeMat", scene);
      microscopeMat.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.95);
      microscopeMat.metallic = 0.95;
      microscope.material = microscopeMat;
    }

    // ××—×¡×Ÿ ×¨×•×‘×•×˜×™ ×—×›×
    function createWarehouse(scene, position) {
      const warehouse = new BABYLON.TransformNode("warehouse", scene);
      warehouse.position = position;

      // ××“×¤×™× ××•×˜×•××˜×™×™×
      for (let row = 0; row < 2; row++) {
        for (let level = 0; level < 4; level++) {
          const shelf = BABYLON.MeshBuilder.CreateBox("shelf" + row + level, { 
            width: 2 * SCALE, 
            height: 0.08 * SCALE, 
            depth: 1.2 * SCALE 
          }, scene);
          shelf.position = new BABYLON.Vector3(
            (row - 0.5) * 2.5 * SCALE, 
            0.4 * SCALE + level * 0.8 * SCALE, 
            0
          );
          shelf.parent = warehouse;
          
          const shelfMat = new BABYLON.StandardMaterial("shelfMat", scene);
          shelfMat.diffuseColor = new BABYLON.Color3(0.7, 0.5, 0.3);
          shelf.material = shelfMat;

          // ×§×•×¤×¡××•×ª ×¢×œ ×”××“×¤×™×
          if (level > 0) {
            for (let b = 0; b < 3; b++) {
              const box = BABYLON.MeshBuilder.CreateBox("shelfBox", { 
                width: 0.4 * SCALE, 
                height: 0.35 * SCALE, 
                depth: 0.35 * SCALE 
              }, scene);
              box.position = new BABYLON.Vector3(
                (row - 0.5) * 2.5 * SCALE + (b - 1) * 0.5 * SCALE, 
                0.6 * SCALE + level * 0.8 * SCALE, 
                0
              );
              box.parent = warehouse;
              
              const boxMat = new BABYLON.StandardMaterial("shelfBoxMat", scene);
              const colors = [
                new BABYLON.Color3(0.85, 0.65, 0.45),
                new BABYLON.Color3(0.45, 0.65, 0.85),
                new BABYLON.Color3(0.65, 0.85, 0.45)
              ];
              boxMat.diffuseColor = colors[b % 3];
              box.material = boxMat;
            }
          }
        }

        // ×¢××•×“×™×
        for (let i = 0; i < 3; i++) {
          const pole = BABYLON.MeshBuilder.CreateCylinder("pole", { 
            height: 3.5 * SCALE, 
            diameter: 0.12 * SCALE 
          }, scene);
          pole.position = new BABYLON.Vector3(
            (row - 0.5) * 2.5 * SCALE + (i - 1) * SCALE, 
            1.75 * SCALE, 
            0
          );
          pole.parent = warehouse;
          
          const poleMat = new BABYLON.StandardMaterial("poleMat", scene);
          poleMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.45);
          poleMat.metallic = 0.9;
          pole.material = poleMat;
        }
      }

      // ×¨×•×‘×•×˜ ××—×¡×Ÿ × ×¢
      const warehouseRobot = BABYLON.MeshBuilder.CreateBox("warehouseRobot", {
        width: 0.4 * SCALE,
        height: 0.6 * SCALE,
        depth: 0.4 * SCALE
      }, scene);
      warehouseRobot.position = new BABYLON.Vector3(0, 0.3 * SCALE, 1 * SCALE);
      warehouseRobot.parent = warehouse;
      
      const robotMat = new BABYLON.StandardMaterial("warehouseRobotMat", scene);
      robotMat.diffuseColor = new BABYLON.Color3(0.2, 0.6, 0.9);
      robotMat.emissiveColor = new BABYLON.Color3(0.1, 0.3, 0.5);
      warehouseRobot.material = robotMat;

      // ×ª× ×•×¢×ª ×¨×•×‘×•×˜
      gsap.to(warehouseRobot.position, {
        z: -1 * SCALE,
        duration: 4,
        repeat: -1,
        yoyo: true,
        ease: "power2.inOut"
      });

      gsap.to(warehouseRobot.position, {
        x: 1.5 * SCALE,
        duration: 2,
        repeat: -1,
        yoyo: true,
        ease: "power2.inOut"
      });
    }

    // ========= ×“××•×ª ×”×©×—×§×Ÿ =========
    function createPlayer(scene) {
      playerRoot = new BABYLON.TransformNode("playerRoot", scene);
      playerRoot.position = stations[0].position.clone();

      // ×’×•×£
      playerBody = BABYLON.MeshBuilder.CreateCylinder("playerBody", { 
        height: 0.8 * SCALE, 
        diameterTop: 0.28 * SCALE,
        diameterBottom: 0.32 * SCALE
      }, scene);
      playerBody.position.y = 0.6 * SCALE;
      playerBody.parent = playerRoot;
      
      const bodyMat = new BABYLON.StandardMaterial("playerBodyMat", scene);
      bodyMat.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.8);
      bodyMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
      playerBody.material = bodyMat;

      // ×¨××©
      playerHead = BABYLON.MeshBuilder.CreateSphere("playerHead", { 
        diameter: 0.28 * SCALE 
      }, scene);
      playerHead.position.y = 1.12 * SCALE;
      playerHead.parent = playerRoot;
      
      const headMat = new BABYLON.StandardMaterial("playerHeadMat", scene);
      headMat.diffuseColor = new BABYLON.Color3(0.95, 0.85, 0.75);
      playerHead.material = headMat;

      // ×§×¡×“×ª ×‘×˜×™×—×•×ª
      const helmet = BABYLON.MeshBuilder.CreateSphere("helmet", {
        diameter: 0.32 * SCALE,
        arc: 0.5
      }, scene);
      helmet.position.y = 1.15 * SCALE;
      helmet.rotation.x = Math.PI;
      helmet.parent = playerRoot;
      
      const helmetMat = new BABYLON.StandardMaterial("helmetMat", scene);
      helmetMat.diffuseColor = new BABYLON.Color3(1, 0.8, 0);
      helmetMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
      helmet.material = helmetMat;

      // ×¢×™× ×™×™×
      for (let side of [-1, 1]) {
        const eye = BABYLON.MeshBuilder.CreateSphere("eye", { diameter: 0.05 * SCALE }, scene);
        eye.position = new BABYLON.Vector3(side * 0.06 * SCALE, 1.13 * SCALE, 0.1 * SCALE);
        eye.parent = playerRoot;
        const eyeMat = new BABYLON.StandardMaterial("eyeMat", scene);
        eyeMat.diffuseColor = new BABYLON.Color3(0.05, 0.05, 0.1);
        eye.material = eyeMat;
      }

      // ×–×¨×•×¢×•×ª
      leftArm = BABYLON.MeshBuilder.CreateCylinder("leftArm", { 
        height: 0.55 * SCALE, 
        diameter: 0.1 * SCALE
      }, scene);
      leftArm.position = new BABYLON.Vector3(-0.22 * SCALE, 0.76 * SCALE, 0);
      leftArm.parent = playerRoot;
      leftArm.material = bodyMat;
      leftArm.metadata = { swingPhase: 0 };

      rightArm = BABYLON.MeshBuilder.CreateCylinder("rightArm", { 
        height: 0.55 * SCALE, 
        diameter: 0.1 * SCALE
      }, scene);
      rightArm.position = new BABYLON.Vector3(0.22 * SCALE, 0.76 * SCALE, 0);
      rightArm.parent = playerRoot;
      rightArm.material = bodyMat;
      rightArm.metadata = { swingPhase: Math.PI };

      // ×¨×’×œ×™×™×
      leftLeg = BABYLON.MeshBuilder.CreateCylinder("leftLeg", { 
        height: 0.65 * SCALE, 
        diameter: 0.12 * SCALE
      }, scene);
      leftLeg.position = new BABYLON.Vector3(-0.1 * SCALE, 0.32 * SCALE, 0);
      leftLeg.parent = playerRoot;
      leftLeg.material = bodyMat;
      leftLeg.metadata = { swingPhase: 0 };

      rightLeg = BABYLON.MeshBuilder.CreateCylinder("rightLeg", { 
        height: 0.65 * SCALE, 
        diameter: 0.12 * SCALE
      }, scene);
      rightLeg.position = new BABYLON.Vector3(0.1 * SCALE, 0.32 * SCALE, 0);
      rightLeg.parent = playerRoot;
      rightLeg.material = bodyMat;
      rightLeg.metadata = { swingPhase: Math.PI };
    }

    // ========= ×¢×“×›×•×Ÿ ××¦×œ××” ××©×•×¤×¨ × ×’×“ ×§×™×¨ =========
    function updateCamera() {
      if (!playerRoot || !camera) return;
      
      const targetPos = playerRoot.position.clone();

      // ×× ×”×©×—×§×Ÿ ×¢×œ ×”×’×©×¨ / ×’×‘×•×” â€“ ××¨×™××™× ××ª ×”××¦×œ××” ×›×“×™ ×©×”×§×™×¨ ×œ× ×™×¡×ª×™×¨
      const baseHeight = playerRoot.position.y > 2 * SCALE ? 12 * SCALE : 8 * SCALE;
      const cameraOffset = new BABYLON.Vector3(0, baseHeight, -15 * SCALE);
      
      // ×—×™×©×•×‘ ××™×§×•× ×”××¦×œ××” ×‘×”×ª×× ×œ×¡×™×‘×•×‘ ×”×©×—×§×Ÿ
      const rotMatrix = BABYLON.Matrix.RotationY(playerRoot.rotation.y);
      const rotatedOffset = BABYLON.Vector3.TransformCoordinates(cameraOffset, rotMatrix);
      const newCameraPos = targetPos.add(rotatedOffset);
      
      // ×ª× ×•×¢×” ×—×œ×§×” ×©×œ ×”××¦×œ××” ×¢× GSAP (× ×©××¨ ×›××• ×‘××§×•×¨)
      gsap.to(camera.position, {
        x: newCameraPos.x,
        y: newCameraPos.y,
        z: newCameraPos.z,
        duration: 0.3,
        ease: "power2.out"
      });
      
      // ×”××¦×œ××” ××¡×ª×›×œ×ª ×¢×œ ×”×©×—×§×Ÿ
      camera.setTarget(targetPos.add(new BABYLON.Vector3(0, 0.5 * SCALE, 2 * SCALE)));
    }

    // ========= ×ª× ×•×¢×ª ×”×©×—×§×Ÿ =========
    function movePlayerToStation(deltaTime) {
      if (!gameState.isMoving || !playerRoot) return;

      const targetStation = stations[gameState.currentStation];
      const target = targetStation.position;
      const direction = target.subtract(playerRoot.position);
      direction.y = 0;
      const distance = direction.length();

      // ×”×’×¢× ×• ×œ×ª×—× ×”
      if (distance < 0.12 * SCALE) {
        playerRoot.position.x = target.x;
        playerRoot.position.z = target.z;
        
        // ×”×ª×× ×’×•×‘×” ×‘×¦×•×¨×” ×—×œ×§×” ×œ×’×©×¨/××“×¨×’×•×ª
        gsap.to(playerRoot.position, {
          y: target.y,
          duration: 0.6,
          ease: "power2.inOut"
        });

        gameState.isMoving = false;

        // ×× ×–×• ×ª×—× ×ª ×”×§×‘×œ×” ×”×¨××©×•× ×” ×‘×¤× ×™× - × ×¡×’×•×¨ ××ª ×”×“×œ×ª ××—×¨×™ ×©× ×›× ×¡
        if (gameState.currentStation === 1) {
          setTimeout(() => {
            closeDoor();
          }, 800);
        }

        // ×× ×–×• ×ª×—× ×ª ×”×™×¦×™××” (××—×•×¥ ×œ××¤×¢×œ) - ××¡×™×™××™× ××ª ×”××©×—×§
        if (exitStationAdded && gameState.currentStation === stations.length - 1) {
          gameState.waitingForInput = false;
          stopWalkAnimation();

          document.getElementById('instructions').textContent = 'ğŸ‰ ×”×¡×™×•×¨ ×”×¡×ª×™×™× ×‘×”×¦×œ×—×”! ×™×¦××ª× ××”××¤×¢×œ.';
          document.getElementById('next-btn').style.display = 'none';

          createFireworks(scene);
          gameState.isActive = false;
          return;
        }

        gameState.waitingForInput = true;

        // ×”×¦×’ ××™×“×¢ ×•×œ×—×¦×Ÿ
        if (targetStation.hasInfo) {
          showStationInfo(targetStation);
        }
        document.getElementById('next-btn').classList.add('show');

        stopWalkAnimation();
        return;
      }

      // ×ª× ×•×¢×” ×—×œ×§×”
      const moveDir = direction.normalize();
      const speed = gameState.walkSpeed * deltaTime * 60;
      
      playerRoot.position.addInPlace(moveDir.scale(speed));

      // ×”×ª×××ª ×’×•×‘×” ×”×“×¨×’×ª×™×ª ×‘×¢×ª ×”×œ×™×›×” ×¢×œ ××“×¨×’×•×ª
      if (Math.abs(playerRoot.position.y - target.y) > 0.02) {
        playerRoot.position.y = BABYLON.Scalar.Lerp(playerRoot.position.y, target.y, 0.08);
      }

      // ×¡×™×‘×•×‘ ×œ×›×™×•×•×Ÿ ×”×ª× ×•×¢×”
      const targetAngle = Math.atan2(moveDir.x, moveDir.z);
      const currentAngle = playerRoot.rotation.y;
      let angleDiff = targetAngle - currentAngle;
      
      while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
      while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
      
      playerRoot.rotation.y += angleDiff * gameState.rotationSpeed;

      // ×× ×™××¦×™×™×ª ×”×œ×™×›×”
      animateWalk(deltaTime, distance);
    }

    // ×× ×™××¦×™×™×ª ×”×œ×™×›×” ×—×œ×§×”
    function animateWalk(deltaTime, distance) {
      const walkSpeed = Math.min(distance * 5, 7);
      
      if (leftArm) {
        leftArm.metadata.swingPhase += deltaTime * walkSpeed;
        leftArm.rotation.x = Math.sin(leftArm.metadata.swingPhase) * 0.25;
      }
      
      if (rightArm) {
        rightArm.metadata.swingPhase += deltaTime * walkSpeed;
        rightArm.rotation.x = Math.sin(rightArm.metadata.swingPhase) * 0.25;
      }
      
      if (leftLeg) {
        leftLeg.metadata.swingPhase += deltaTime * walkSpeed;
        leftLeg.rotation.x = Math.sin(leftLeg.metadata.swingPhase) * 0.35;
      }
      
      if (rightLeg) {
        rightLeg.metadata.swingPhase += deltaTime * walkSpeed;
        rightLeg.rotation.x = Math.sin(rightLeg.metadata.swingPhase) * 0.35;
      }

      // ×ª× ×•×¢×ª ×’×•×£
      const bob = Math.abs(Math.sin(Date.now() * 0.004 * walkSpeed)) * 0.03 * SCALE;
      if (playerBody) playerBody.position.y = 0.6 * SCALE + bob;
      if (playerHead) playerHead.position.y = 1.12 * SCALE + bob * 0.7;
    }

    // ×¢×¦×•×¨ ×× ×™××¦×™×”
    function stopWalkAnimation() {
      gsap.to([leftArm.rotation, rightArm.rotation, leftLeg.rotation, rightLeg.rotation], {
        x: 0,
        duration: 0.3,
        ease: "power2.out"
      });
      
      gsap.to(playerBody.position, { y: 0.6 * SCALE, duration: 0.3 });
      gsap.to(playerHead.position, { y: 1.12 * SCALE, duration: 0.3 });
    }

    // ×”×¦×’ ××™×“×¢ ×¢×œ ×ª×—× ×”
    function showStationInfo(station) {
      document.getElementById('station-name').textContent = station.name;
      document.getElementById('station-desc').textContent = station.description;
      
      const stationInfo = document.getElementById('station-info');
      stationInfo.classList.add('show');
      
      // ×× ×™××¦×™×” ×¢× GSAP
      gsap.from(stationInfo, {
        y: -20,
        opacity: 0,
        duration: 0.5,
        ease: "back.out(1.7)"
      });
    }

    // ×”×¡×ª×¨ ××™×“×¢
    function hideStationInfo() {
      document.getElementById('station-info').classList.remove('show');
    }

    // ========= ××¢×‘×¨ ×œ×ª×—× ×” ×”×‘××” =========
    function moveToNextStation() {
      if (!gameState.waitingForInput || gameState.isMoving) return;

      hideStationInfo();
      document.getElementById('next-btn').classList.remove('show');

      // ×× ×× ×—× ×• ×‘×ª×—× ×” ×”××—×¨×•× ×” ×”××•×’×“×¨×ª ×‘×¤× ×™× ×•×¢×“×™×™×Ÿ ×œ× ×”×•×¡×¤× ×• ×ª×—× ×ª ×™×¦×™××”
      if (gameState.currentStation === stations.length - 1 && !exitStationAdded) {
        exitStationAdded = true;

        const lastPos = stations[stations.length - 1].position.clone();
        const exitPos = lastPos.add(new BABYLON.Vector3(0, 0, -8 * SCALE)); // ×§×¦×ª ××—×•×¥ ×œ××¤×¢×œ

        stations.push({
          position: exitPos,
          name: "ğŸš¶â€â™‚ï¸ ×™×¦×™××” ××”××¤×¢×œ",
          description: "×¡×™×™××ª ××ª ×”×¡×™×•×¨ ×•×™×¦××ª ××”××¤×¢×œ, ×›×œ ×”×›×‘×•×“!",
          hasInfo: false
        });

        // ×¤×•×ª×—×™× ××ª ×”×“×œ×ª ×œ×™×¦×™××”
        openDoor();

        gameState.currentStation = stations.length - 1; // ×ª×—× ×ª ×”×™×¦×™××” ×”×—×“×©×”
        gameState.waitingForInput = false;
        gameState.isMoving = true;
        return;
      }

      // ××¢×‘×¨ ×¨×’×™×œ ×œ×ª×—× ×” ×”×‘××”
      gameState.currentStation++;
      
      if (gameState.currentStation >= stations.length) {
        document.getElementById('instructions').textContent = 'ğŸ‰ ×”×¡×™×•×¨ ×”×¡×ª×™×™× ×‘×”×¦×œ×—×”!';
        document.getElementById('next-btn').style.display = 'none';
        gameState.isActive = false;
        
        createFireworks(scene);
        return;
      }

      gameState.waitingForInput = false;
      gameState.isMoving = true;
    }

    // ×–×™×§×•×§×™× ×‘×¡×™×•×
    function createFireworks(scene) {
      const fireworks = new BABYLON.ParticleSystem("fireworks", 100, scene);
      fireworks.particleTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/flare.png", scene);
      fireworks.emitter = new BABYLON.Vector3(0, 5 * SCALE, 0);
      fireworks.minEmitBox = new BABYLON.Vector3(-5 * SCALE, 0, -5 * SCALE);
      fireworks.maxEmitBox = new BABYLON.Vector3(5 * SCALE, 0, 5 * SCALE);
      fireworks.color1 = new BABYLON.Color4(1, 0, 0, 1);
      fireworks.color2 = new BABYLON.Color4(0, 0, 1, 1);
      fireworks.colorDead = new BABYLON.Color4(1, 1, 0, 0);
      fireworks.minSize = 0.1 * SCALE;
      fireworks.maxSize = 0.3 * SCALE;
      fireworks.minLifeTime = 0.5;
      fireworks.maxLifeTime = 1.5;
      fireworks.emitRate = 20;
      fireworks.gravity = new BABYLON.Vector3(0, -2 * SCALE, 0);
      fireworks.direction1 = new BABYLON.Vector3(-2, 8, -2);
      fireworks.direction2 = new BABYLON.Vector3(2, 10, 2);
      fireworks.minEmitPower = 2 * SCALE;
      fireworks.maxEmitPower = 4 * SCALE;
      fireworks.start();

      setTimeout(() => fireworks.stop(), 5000);
    }

    // ========= ××™×¨×•×¢×™× =========
    document.getElementById("next-btn").addEventListener("click", moveToNextStation);

    document.getElementById("start-btn").addEventListener("click", () => {
      const startScreen = document.getElementById("start-screen");
      startScreen.classList.add("hidden");
      
      setTimeout(() => {
        startScreen.style.display = "none";
        document.getElementById("instructions").classList.add("show");
      }, 800);

      // ×¤×•×ª×—×™× ×“×œ×ª ×‘×ª×—×™×œ×ª ×”×¡×™×•×¨
      openDoor();

      gameState.isActive = true;
      gameState.isMoving = true;
      gameState.currentStation = 1;
    });

    // ========= MAIN LOOP =========
    scene = createScene();

    let lastTime = Date.now();
    engine.runRenderLoop(() => {
      const now = Date.now();
      const deltaTime = (now - lastTime) / 1000;
      lastTime = now;

      if (gameState.isActive) {
        movePlayerToStation(deltaTime);
        updateCamera();
      }

      scene.render();
    });

    window.addEventListener("resize", () => engine.resize());
  </script>
</body>
</html>
