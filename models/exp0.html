<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ULTIMATE FACTORY PROTOCOL</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <style>
        * { margin: 0; padding: 0; overflow: hidden; user-select: none; }
        body { background: #000; font-family: 'Segoe UI', sans-serif; }
        #renderCanvas { width: 100%; height: 100%; outline: none; }
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(45deg, #0f0f0f, #1a1a1a);
            display: flex; justify-content: center; align-items: center;
            color: #00d2ff; font-size: 24px; z-index: 999; letter-spacing: 5px;
            flex-direction: column;
        }
        .bar { width: 300px; height: 4px; background: #333; margin-top: 20px; overflow: hidden; }
        .progress { width: 0%; height: 100%; background: #00d2ff; transition: width 0.5s; animation: load 2s forwards; }
        @keyframes load { 0% { width: 0%; } 100% { width: 100%; } }
    </style>
</head>
<body>

<div id="loading">
    <div>INITIALIZING SYSTEMS</div>
    <div class="bar"><div class="progress"></div></div>
</div>
<canvas id="renderCanvas"></canvas>

<script>
/**
 * ULTIMATE FACTORY ESCAPE - PROTOTYPE
 * מכיל: מנוע גרפי, מחולל טקסטורות, מערכת UI, לוגיקת משחק, מערכת חלקיקים
 */

const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true, { stencil: true, antialias: true });

// --- STATE MANAGEMENT ---
const GameState = {
    path: [
        new BABYLON.Vector3(0, 0, -40),
        new BABYLON.Vector3(0, 0, -10),
        new BABYLON.Vector3(-20, 0, 0),
        new BABYLON.Vector3(-20, 0, 30),
        new BABYLON.Vector3(20, 0, 30),
        new BABYLON.Vector3(20, 0, 0),
        new BABYLON.Vector3(0, 0, 50)
    ],
    currentPoint: 0,
    isMoving: false,
    speed: 0.15,
    playerHeight: 2.5
};

// --- TEXTURE GENERATOR (כדי לא להיות תלוי בקבצים חיצוניים) ---
const TextureGen = {
    createMetal: function(scene) {
        const dt = new BABYLON.DynamicTexture("metalTex", 512, scene);
        const ctx = dt.getContext();
        const grad = ctx.createLinearGradient(0,0,512,512);
        grad.addColorStop(0, "#2a2a2a");
        grad.addColorStop(0.5, "#555555");
        grad.addColorStop(1, "#2a2a2a");
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,512,512);
        // Noise
        for(let i=0; i<5000; i++) {
            ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.1})`;
            ctx.fillRect(Math.random()*512, Math.random()*512, 2, 2);
        }
        dt.update();
        return dt;
    },
    createFloor: function(scene) {
        const dt = new BABYLON.DynamicTexture("floorTex", 512, scene);
        const ctx = dt.getContext();
        ctx.fillStyle = "#151515";
        ctx.fillRect(0,0,512,512);
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.strokeRect(0,0,512,512);
        // Caution stripes
        ctx.fillStyle = "#dda010";
        for(let i=0; i<512; i+=64) {
             ctx.beginPath();
             ctx.moveTo(i, 0);
             ctx.lineTo(i+32, 0);
             ctx.lineTo(0, i+32);
             ctx.lineTo(0, i);
             ctx.fill();
        }
        dt.update();
        return dt;
    },
    createHazard: function(scene) {
        const dt = new BABYLON.DynamicTexture("hazard", 256, scene);
        const ctx = dt.getContext();
        ctx.fillStyle = "#dec800";
        ctx.fillRect(0,0,256,256);
        ctx.fillStyle = "#000000";
        for(let i=0; i<400; i+=40) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i+20, 0);
            ctx.lineTo(0, i+20);
            ctx.lineTo(0, i);
            ctx.fill();
        }
        dt.update();
        return dt;
    }
};

// --- MAIN SCENE ---
const createScene = function () {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.02, 0.02, 0.03);
    scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
    scene.fogDensity = 0.008;
    scene.fogColor = new BABYLON.Color3(0.02, 0.02, 0.03);

    // MATERIALS
    const mats = createMaterials(scene);

    // ENVIRONMENT
    createEnvironment(scene, mats);
    
    // LIGHTING
    createLighting(scene);

    // PLAYER (ROBOT)
    const player = createComplexPlayer(scene, mats);

    // CAMERA
    const camera = new BABYLON.ArcRotateCamera("cam", -Math.PI/2, Math.PI/3, 25, player.position, scene);
    camera.lowerRadiusLimit = 10;
    camera.upperRadiusLimit = 40;
    camera.lowerBetaLimit = 0.1;
    camera.upperBetaLimit = Math.PI/2.2;
    camera.attachControl(canvas, true);

    // MACHINES & PARTICLES
    createMachines(scene, mats);

    // POST PROCESSING
    const pipeline = new BABYLON.DefaultRenderingPipeline("pipeline", true, scene, [camera]);
    pipeline.bloomEnabled = true;
    pipeline.bloomThreshold = 0.6;
    pipeline.bloomWeight = 0.4;
    pipeline.fxaaEnabled = true;

    // GUI
    const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
    createStartScreen(advancedTexture, scene, player, camera);

    // GAME LOOP LOGIC
    scene.registerBeforeRender(() => {
        if(GameState.isMoving) {
            const target = GameState.path[GameState.currentPoint];
            const moveDir = target.subtract(player.position);
            moveDir.y = 0;
            const dist = moveDir.length();

            if(dist < 0.5) {
                GameState.currentPoint++;
                if(GameState.currentPoint >= GameState.path.length) GameState.currentPoint = 0;
                
                // STOP LOGIC (SIMULATED QUESTION EVENT)
                if(GameState.currentPoint % 2 !== 0) { // Stop at odd points
                    GameState.isMoving = false;
                    stopPlayerAnimation(player);
                    createQuestionModal(advancedTexture, scene, () => {
                        GameState.isMoving = true;
                        startPlayerAnimation(player);
                    });
                }
            } else {
                moveDir.normalize();
                player.position.addInPlace(moveDir.scale(GameState.speed));
                
                // Rotation smoothing
                const targetRot = Math.atan2(moveDir.x, moveDir.z);
                player.rotation.y = BABYLON.Scalar.Lerp(player.rotation.y, targetRot, 0.1);
            }
            
            // Camera follow
            camera.target = BABYLON.Vector3.Lerp(camera.target, player.position.add(new BABYLON.Vector3(0,3,0)), 0.05);
        }
        
        // Constant idle animation
        if(!GameState.isMoving) {
             player.position.y = Math.sin(Date.now()*0.002)*0.1;
        }
    });

    return scene;
};

// --- HELPERS & BUILDERS ---

function createMaterials(scene) {
    const m = {};
    
    m.floor = new BABYLON.PBRMaterial("floor", scene);
    m.floor.albedoTexture = TextureGen.createFloor(scene);
    m.floor.albedoTexture.uScale = 20; m.floor.albedoTexture.vScale = 20;
    m.floor.roughness = 0.4;
    m.floor.metallic = 0.6;
    
    m.metal = new BABYLON.PBRMaterial("metal", scene);
    m.metal.albedoTexture = TextureGen.createMetal(scene);
    m.metal.roughness = 0.5;
    m.metal.metallic = 0.9;

    m.glowBlue = new BABYLON.PBRMaterial("glowB", scene);
    m.glowBlue.emissiveColor = new BABYLON.Color3(0, 0.8, 1);
    m.glowBlue.disableLighting = true;

    m.glowOrange = new BABYLON.PBRMaterial("glowO", scene);
    m.glowOrange.emissiveColor = new BABYLON.Color3(1, 0.5, 0);
    m.glowOrange.disableLighting = true;
    
    m.hazard = new BABYLON.PBRMaterial("hazard", scene);
    m.hazard.albedoTexture = TextureGen.createHazard(scene);
    m.hazard.metallic = 0.1;

    return m;
}

function createEnvironment(scene, mats) {
    const ground = BABYLON.MeshBuilder.CreateGround("g", {width:200, height:200}, scene);
    ground.material = mats.floor;
    ground.receiveShadows = true;

    // Columns
    for(let x=-80; x<=80; x+=40) {
        for(let z=-80; z<=80; z+=40) {
            const col = BABYLON.MeshBuilder.CreateBox("col", {height:20, width:2, depth:2}, scene);
            col.position = new BABYLON.Vector3(x, 10, z);
            col.material = mats.metal;
            
            const lightStrip = BABYLON.MeshBuilder.CreatePlane("ls", {height:15, width:0.2}, scene);
            lightStrip.parent = col;
            lightStrip.position.z = -1.01;
            lightStrip.material = mats.glowBlue;
        }
    }
    
    // Ceiling Beams
    for(let z=-80; z<=80; z+=20) {
        const beam = BABYLON.MeshBuilder.CreateBox("beam", {width:180, height:1, depth:1}, scene);
        beam.position = new BABYLON.Vector3(0, 20, z);
        beam.material = mats.metal;
    }
}

function createLighting(scene) {
    const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
    hemi.intensity = 0.3;
    
    const spot = new BABYLON.SpotLight("spot", new BABYLON.Vector3(0, 30, 0), new BABYLON.Vector3(0, -1, 0), Math.PI/2, 2, scene);
    spot.intensity = 4000;
    spot.shadowEnabled = true;
    
    const generator = new BABYLON.ShadowGenerator(1024, spot);
    generator.useBlurExponentialShadowMap = true;
    generator.blurKernel = 32;
    scene.shadowGenerator = generator; // Global reference
}

function createComplexPlayer(scene, mats) {
    const root = new BABYLON.TransformNode("playerRoot", scene);
    root.position = GameState.path[0].clone();
    
    // Wheel (Unicycle style)
    const wheel = BABYLON.MeshBuilder.CreateCylinder("wheel", {diameter:1.5, height:0.5}, scene);
    wheel.rotation.z = Math.PI/2;
    wheel.position.y = 0.75;
    wheel.parent = root;
    wheel.material = mats.metal;
    
    // Body
    const body = BABYLON.MeshBuilder.CreateBox("body", {width:1.2, height:1.5, depth:1}, scene);
    body.position.y = 2.2;
    body.parent = root;
    body.material = mats.metal;
    
    // Chest Core
    const core = BABYLON.MeshBuilder.CreateSphere("core", {diameter:0.6}, scene);
    core.position.z = -0.4;
    core.parent = body;
    core.material = mats.glowBlue;
    
    // Head
    const head = BABYLON.MeshBuilder.CreateBox("head", {width:0.8, height:0.8, depth:0.8}, scene);
    head.position.y = 3.6;
    head.parent = root;
    head.material = mats.metal;
    
    // Eye
    const eye = BABYLON.MeshBuilder.CreatePlane("eye", {width:0.6, height:0.2}, scene);
    eye.parent = head;
    eye.position.z = -0.41;
    eye.position.y = 0.1;
    eye.material = mats.glowBlue;
    
    // Arms
    const armL = BABYLON.MeshBuilder.CreateBox("armL", {width:0.3, height:1.5, depth:0.3}, scene);
    armL.position = new BABYLON.Vector3(-0.9, 2.2, 0);
    armL.parent = root;
    armL.material = mats.metal;
    
    const armR = BABYLON.MeshBuilder.CreateBox("armR", {width:0.3, height:1.5, depth:0.3}, scene);
    armR.position = new BABYLON.Vector3(0.9, 2.2, 0);
    armR.parent = root;
    armR.material = mats.metal;
    
    // Metadata for animation
    root.metadata = { wheel, armL, armR };
    
    scene.shadowGenerator.addShadowCaster(wheel);
    scene.shadowGenerator.addShadowCaster(body);
    scene.shadowGenerator.addShadowCaster(head);

    return root;
}

function startPlayerAnimation(player) {
    const scene = player.getScene();
    scene.onBeforeRenderObservable.add((this.animObserver = () => {
        if(GameState.isMoving) {
            player.metadata.wheel.rotation.x -= 0.2;
            player.metadata.armL.rotation.x = Math.sin(Date.now()*0.01)*0.5;
            player.metadata.armR.rotation.x = Math.cos(Date.now()*0.01)*0.5;
        }
    }));
}

function stopPlayerAnimation(player) {
    // Reset poses if needed
}

function createMachines(scene, mats) {
    // Particle System Template
    const createSteam = (pos) => {
        const particleSystem = new BABYLON.ParticleSystem("steam", 1000, scene);
        particleSystem.particleTexture = new BABYLON.Texture("https://raw.githubusercontent.com/BabylonJS/Babylon.js/master/packages/tools/playground/public/textures/flare.png", scene);
        particleSystem.emitter = pos;
        particleSystem.minEmitBox = new BABYLON.Vector3(-0.5, 0, -0.5); 
        particleSystem.maxEmitBox = new BABYLON.Vector3(0.5, 0, 0.5);
        particleSystem.color1 = new BABYLON.Color4(0.8, 0.8, 0.8, 0.5);
        particleSystem.color2 = new BABYLON.Color4(0.5, 0.5, 0.5, 0.0);
        particleSystem.size = 0.5;
        particleSystem.minSize = 0.1;
        particleSystem.maxSize = 1.0;
        particleSystem.minLifeTime = 0.3;
        particleSystem.maxLifeTime = 1.5;
        particleSystem.emitRate = 100;
        particleSystem.gravity = new BABYLON.Vector3(0, 2, 0);
        particleSystem.start();
    };

    // Big Press Machine
    const press = BABYLON.MeshBuilder.CreateBox("press", {width:6, height:10, depth:4}, scene);
    press.position = new BABYLON.Vector3(-20, 5, 0);
    press.material = mats.metal;
    scene.shadowGenerator.addShadowCaster(press);

    // Hazard Strip
    const strip = BABYLON.MeshBuilder.CreateGround("strip", {width:8, height:6}, scene);
    strip.position = new BABYLON.Vector3(-20, 0.01, 0);
    strip.material = mats.hazard;

    // Moving Piston
    const piston = BABYLON.MeshBuilder.CreateCylinder("piston", {diameter:2, height:4}, scene);
    piston.position = new BABYLON.Vector3(-20, 6, 2);
    piston.material = mats.metal;
    
    scene.registerBeforeRender(() => {
        piston.position.y = 6 + Math.sin(Date.now()*0.005)*2;
        if(Math.sin(Date.now()*0.005) < -0.9) {
             // Slam effect could be added here
        }
    });

    createSteam(new BABYLON.Vector3(-20, 1, 2));

    // Conveyor Belt Area
    const belt = BABYLON.MeshBuilder.CreateBox("belt", {width:4, height:1, depth:40}, scene);
    belt.position = new BABYLON.Vector3(20, 1, 10);
    belt.material = mats.metal;
    
    // Boxes on belt
    for(let i=0; i<5; i++) {
        const box = BABYLON.MeshBuilder.CreateBox("box"+i, {size:1.5}, scene);
        box.position = new BABYLON.Vector3(20, 2.5, -5 + i*8);
        box.material = mats.glowOrange;
        scene.shadowGenerator.addShadowCaster(box);
        
        scene.registerBeforeRender(() => {
            box.position.z += 0.05;
            if(box.position.z > 30) box.position.z = -10;
        });
    }
}

// --- GUI SYSTEM ---
function createStartScreen(advancedTexture, scene, player, camera) {
    const rect = new BABYLON.GUI.Rectangle();
    rect.width = 1; rect.height = 1;
    rect.background = "rgba(0,0,0,0.8)";
    advancedTexture.addControl(rect);

    const title = new BABYLON.GUI.TextBlock();
    title.text = "FACTORY PRIME";
    title.color = "#00d2ff";
    title.fontSize = 72;
    title.top = "-100px";
    title.shadowColor = "black";
    title.shadowBlur = 10;
    rect.addControl(title);

    const btn = BABYLON.GUI.Button.CreateSimpleButton("btn", "START OPERATION");
    btn.width = "300px"; btn.height = "60px";
    btn.color = "white"; btn.cornerRadius = 5;
    btn.background = "#0078d7";
    btn.top = "50px";
    btn.onPointerUpObservable.add(() => {
        rect.isVisible = false;
        GameState.isMoving = true;
        startPlayerAnimation(player);
        
        // Dynamic Zoom in
        const anim = new BABYLON.Animation("camZoom", "radius", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
        anim.setKeys([{frame:0, value:40}, {frame:60, value:15}]);
        camera.animations.push(anim);
        scene.beginAnimation(camera, 0, 60, false);
    });
    rect.addControl(btn);
}

function createQuestionModal(advancedTexture, scene, callback) {
    const rect = new BABYLON.GUI.Rectangle();
    rect.width = "600px"; rect.height = "400px";
    rect.background = "rgba(10, 20, 30, 0.95)";
    rect.color = "#00d2ff";
    rect.thickness = 2;
    rect.cornerRadius = 10;
    advancedTexture.addControl(rect);

    const title = new BABYLON.GUI.TextBlock();
    title.text = "SECURITY CHECKPOINT";
    title.color = "#00d2ff";
    title.fontSize = 30;
    title.top = "-150px";
    rect.addControl(title);

    const qText = new BABYLON.GUI.TextBlock();
    qText.text = "מהי המטרה העיקרית של מתודולוגיית LEAN?";
    qText.color = "white";
    qText.fontSize = 24;
    qText.textWrapping = true;
    qText.top = "-80px";
    rect.addControl(qText);

    const answers = ["הגדלת מלאי", "צמצום בזבוז וערך ללקוח", "העסקת יותר עובדים"];
    
    answers.forEach((ans, i) => {
        const btn = BABYLON.GUI.Button.CreateSimpleButton("ans"+i, ans);
        btn.width = "500px"; btn.height = "50px";
        btn.color = "white"; btn.background = "#333";
        btn.top = (20 + i*70) + "px";
        btn.cornerRadius = 5;
        
        btn.onPointerUpObservable.add(() => {
            if(i === 1) { // Correct
                btn.background = "green";
                setTimeout(() => {
                    rect.dispose();
                    callback();
                }, 500);
            } else {
                btn.background = "red";
            }
        });
        rect.addControl(btn);
    });
}

// Initialize
document.getElementById("loading").style.display = "flex";
setTimeout(() => {
    createScene();
    engine.runRenderLoop(() => {
        createScene().render(); // Render fix
    });
    document.getElementById("loading").style.display = "none";
    
    // Fix render loop
    engine.stopRenderLoop();
    const scene = createScene();
    engine.runRenderLoop(() => scene.render());
    
}, 2000);

window.addEventListener("resize", () => engine.resize());

</script>
</body>
</html>