<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <title>××©×—×§ ×ª×¨××™×œ ×”×’×‘ â€“ ××¨×’×– ×¦×™×•×“ ×ª×¢×©×™×™×ª×™ PRO</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- BabylonJS + GUI -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: "Heebo", Arial, sans-serif;
    }

    body {
      background: radial-gradient(circle at 20% 0%, #ffffff 0%, #e3f2fd 35%, #bbdefb 70%, #90caf9 100%);
      -webkit-tap-highlight-color: transparent;
    }

    #renderCanvas {
      width: 100%;
      height: 100%;
      display: block;
      outline: none;
    }

    /* HUD ×ª×—×ª×•×Ÿ */
    #hud {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 10px;
      width: 92%;
      max-width: 960px;
      background: rgba(255,255,255,0.98);
      border-radius: 18px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.18);
      padding: 10px 16px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
      font-size: 14px;
      direction: rtl;
      z-index: 10;
    }

    #hud span { white-space: nowrap; }

    #message {
      flex: 1;
      min-width: 140px;
    }

    #checkBtn {
      border: none;
      padding: 8px 20px;
      border-radius: 999px;
      background: #1e88e5;
      color: white;
      font-weight: 600;
      cursor: pointer;
      font-family: inherit;
      font-size: 14px;
    }

    #checkBtn:active { transform: scale(0.96); }

    /* ×”×ª×××” ×œ××•×‘×™×™×œ */
    @media (max-width: 600px) {
      #hud {
        bottom: 6px;
        padding: 8px 10px;
        font-size: 11px;
        gap: 6px;
      }

      #checkBtn {
        padding: 6px 14px;
        font-size: 12px;
      }

      #message { min-width: 100px; }
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <div id="hud">
    <span id="capacity">×§×™×‘×•×œ×ª: ?</span>
    <span id="weight">××©×§×œ × ×•×›×—×™: 0</span>
    <span id="value">×¢×¨×š × ×•×›×—×™: 0</span>
    <span id="message">×œ×—×¥ ×¢×œ ××•×¦×¨ ×›×“×™ ×œ×”×›× ×™×¡ / ×œ×”×•×¦×™× ××”××¨×’×–</span>
    <button id="checkBtn">âœ” ×‘×“×•×§ ×¤×ª×¨×•×Ÿ</button>
  </div>

  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    // ×¨×–×•×œ×•×¦×™×” × ×•×¨××œ×™×ª ×œ××•×‘×™×™×œ ×œ×¨×•×—×‘
    engine.setHardwareScalingLevel(1 / Math.min(window.devicePixelRatio || 1, 2));

    const IS_MOBILE = window.innerWidth <= 768;
    const SCALE = IS_MOBILE ? 0.45 : 0.5;

    // ====== × ×ª×•× ×™ ×‘×¢×™×™×ª ×ª×¨××™×œ ×”×’×‘ ======
    const CAPACITY = 10;
    const ITEMS = [
      { name: "ğŸ”© ×× ×•×¢ ×¡×¨×•×•",      weight: 4, value: 9,  color: new BABYLON.Color3(0.98, 0.54, 0.20), type: "servo" },
      { name: "ğŸ”¦ ×—×™×™×©×Ÿ ×œ×™×™×–×¨",    weight: 2, value: 6,  color: new BABYLON.Color3(0.11, 0.80, 0.98), type: "laser" },
      { name: "ğŸ“¦ ×‘×§×¨ PLC",        weight: 3, value: 7,  color: new BABYLON.Color3(0.63, 0.40, 0.98), type: "plc" },
      { name: "ğŸ¤– ××•×“×•×œ ×–×¨×•×¢",      weight: 5, value: 10, color: new BABYLON.Color3(1.00, 0.84, 0.15), type: "robotArm" },
      { name: "ğŸ“· ××¦×œ××ª QC",       weight: 1, value: 3,  color: new BABYLON.Color3(0.30, 0.88, 0.53), type: "camera" },
      { name: "ğŸ“¡ ××•×“×•×œ RFID",     weight: 2, value: 5,  color: new BABYLON.Color3(0.36, 0.69, 1.00), type: "rfid" }
    ];

    let scene, camera, ui;
    let backpackBase;
    let itemRoots = [];
    let backpackSlots = [];
    let currentWeight = 0;
    let currentValue  = 0;
    let bestPossibleValue = 0;

    // ===== ×¡××•× ×“ ×¤×©×•×˜ ×“×¨×š Audio =====
    const moveAudio = new Audio("transition-sfx-whoosh-sound-effect-407576.mp3");

    function playMoveSfx() {
      try {
        moveAudio.currentTime = 0;
        moveAudio.play();
      } catch (e) {
        console.log("audio error:", e);
      }
    }

    // HUD
    const capacityEl = document.getElementById("capacity");
    const weightEl   = document.getElementById("weight");
    const valueEl    = document.getElementById("value");
    const msgEl      = document.getElementById("message");
    const checkBtn   = document.getElementById("checkBtn");

    capacityEl.textContent = "×§×™×‘×•×œ×ª: " + CAPACITY;

    // ===== ×—×™×©×•×‘ ×”×¢×¨×š ×”××•×¤×˜×™××œ×™ =====
    function computeOptimalValue() {
      const n = ITEMS.length;
      let best = 0;
      for (let mask = 0; mask < (1 << n); mask++) {
        let w = 0, v = 0;
        for (let i = 0; i < n; i++) {
          if (mask & (1 << i)) {
            w += ITEMS[i].weight;
            v += ITEMS[i].value;
          }
        }
        if (w <= CAPACITY && v > best) best = v;
      }
      return best;
    }

    // ===== ×™×¦×™×¨×ª ×¡×¦× ×” =====
    function createScene() {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3(0.95, 0.98, 1);

      // ×ª××•×¨×”
      const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
      hemi.intensity = 0.9;

      const dir = new BABYLON.DirectionalLight("dir",
        new BABYLON.Vector3(-0.5, -1, -0.3),
        scene);
      dir.intensity = 0.6;

    // ===== ××¦×œ××” â€“ ××‘×˜ ×¤×¨×•× ×˜×œ×™, ×©×•×œ×—×Ÿ ×¤×¨×•×¡ ××§×¦×” ×œ×§×¦×” =====
    // ===== ××¦×œ××” â€“ ×¤×¨×•× ×˜×œ×™×ª, ×¨×•××” ××ª ×›×œ ×”×©×•×œ×—×Ÿ ×•×”×§×™×¨ =====
    const baseRadius = IS_MOBILE ? 32 * SCALE : 24 * SCALE;

    camera = new BABYLON.ArcRotateCamera(
      "camera",
      BABYLON.Tools.ToRadians(90),    // ××•×œ ×”×§×™×¨ ×•×”×©×•×œ×—×Ÿ
      BABYLON.Tools.ToRadians(75),     // ×§×¦×ª ××œ××¢×œ×” ××‘×œ ×¢×“×™×™×Ÿ ×¤×¨×•× ×˜×œ×™
      baseRadius,                      // ××¨×—×§ ×›×–×” ×©×™×¨××• ××ª ×›×œ ×”×©×•×œ×—×Ÿ
      new BABYLON.Vector3(0, 3 * SCALE, 0), // ××¡×ª×›×œ ×œ××¨×›×– ×”×©×•×œ×—×Ÿ
      scene
    );

    // × ×•×¢×œ×™× ××ª ×”××¦×œ××” ×©×œ× ×ª×–×•×–
    camera.attachControl(canvas, true);
    camera.inputs.clear();
    camera.lowerRadiusLimit = baseRadius;
    camera.upperRadiusLimit = baseRadius;
    camera.lowerBetaLimit   = camera.beta;
    camera.upperBetaLimit   = camera.beta;
    camera.panningSensibility = 0;



      // ×¡×‘×™×‘×”
      createEnvironment(scene);

      // GUI
      ui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

      // ×ª×¨××™×œ / ××¨×’×– ×¦×™×•×“
      createBackpack(scene);

      // ××•×¦×¨×™×
      createItems(scene);

      // ×‘×—×™×¨×”
      setupPicking(scene);

      return scene;
    }

    function createEnvironment(scene) {
      const ground = BABYLON.MeshBuilder.CreateGround("ground", {
        width: 40 * SCALE,
        height: 30 * SCALE
      }, scene);
      const gMat = new BABYLON.StandardMaterial("gMat", scene);
      gMat.diffuseColor = new BABYLON.Color3(0.96, 0.97, 1);
      gMat.specularColor = new BABYLON.Color3(0.7, 0.7, 0.9);
      ground.material = gMat;
      ground.isPickable = false;

      // ×¤×¡×™× ×–×•×”×¨×™×
      for (let i = -2; i <= 2; i++) {
        const stripe = BABYLON.MeshBuilder.CreateBox("stripe" + i, {
          width: 40 * SCALE,
          height: 0.02 * SCALE,
          depth: 0.12 * SCALE
        }, scene);
        stripe.position = new BABYLON.Vector3(0, 0.01 * SCALE, i * 3 * SCALE);
        const sMat = new BABYLON.StandardMaterial("sMat" + i, scene);
        sMat.emissiveColor = new BABYLON.Color3(0.36, 0.65, 1);
        sMat.alpha = 0.65;
        stripe.material = sMat;
        stripe.isPickable = false;
      }

      // ×§×™×¨ ××—×•×¨×™
      const wall = BABYLON.MeshBuilder.CreateBox("wall", {
        width: 40 * SCALE,
        height: 12 * SCALE,
        depth: 0.4 * SCALE
      }, scene);
      wall.position = new BABYLON.Vector3(0, 6 * SCALE, -8 * SCALE);
      const wMat = new BABYLON.StandardMaterial("wMat", scene);
      wMat.diffuseColor = new BABYLON.Color3(0.9, 0.93, 0.98);
      wall.material = wMat;
      wall.isPickable = false;

      // ×¨×¦×•×¢×ª LED ×‘×§×™×¨
      const ledStrip = BABYLON.MeshBuilder.CreateBox("ledStrip", {
        width: 36 * SCALE,
        height: 0.3 * SCALE,
        depth: 0.1 * SCALE
      }, scene);
      ledStrip.position = new BABYLON.Vector3(0, 9 * SCALE, -7.8 * SCALE);
      const ledMat = new BABYLON.StandardMaterial("ledMat", scene);
      ledMat.emissiveColor = new BABYLON.Color3(0.26, 0.82, 0.96);
      ledStrip.material = ledMat;
      ledStrip.isPickable = false;

      // ×©×•×œ×—×Ÿ ×¢×‘×•×“×”
      const tableTop = BABYLON.MeshBuilder.CreateBox("tableTop", {
        width: 24 * SCALE,
        depth: 12 * SCALE,
        height: 0.5 * SCALE
      }, scene);
      tableTop.position.y = 2.4 * SCALE;
      const tMat = new BABYLON.StandardMaterial("tMat", scene);
      tMat.diffuseColor = new BABYLON.Color3(0.92, 0.93, 0.98);
      tMat.specularColor = new BABYLON.Color3(0.85, 0.85, 0.9);
      tableTop.material = tMat;
      tableTop.isPickable = false;

      for (let sx of [-1, 1]) {
        for (let sz of [-1, 1]) {
          const leg = BABYLON.MeshBuilder.CreateBox("leg", {
            width: 0.7 * SCALE,
            depth: 0.7 * SCALE,
            height: 2.4 * SCALE
          }, scene);
          leg.position = new BABYLON.Vector3(
            sx * 11 * SCALE,
            1.2 * SCALE,
            sz * 5.5 * SCALE
          );
          leg.material = tMat;
          leg.isPickable = false;
        }
      }
    }

    // ===== ×ª×¨××™×œ / ××¨×’×– ×¦×™×•×“ =====
    function createBackpack(scene) {
      // ×‘×¡×™×¡
      backpackBase = BABYLON.MeshBuilder.CreateBox("backpackBase", {
        width: 7 * SCALE,
        height: 0.5 * SCALE,
        depth: 5 * SCALE
      }, scene);
      backpackBase.position = new BABYLON.Vector3(10 * SCALE, 2.65 * SCALE, 0);
      const baseMat = new BABYLON.StandardMaterial("baseMat", scene);
      baseMat.diffuseColor = new BABYLON.Color3(0.80, 0.86, 0.95);
      baseMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.95);
      backpackBase.material = baseMat;
      backpackBase.isPickable = false;

      // ×’×•×£ ×¢×’×•×œ
      const body = BABYLON.MeshBuilder.CreateCylinder("packBody", {
        diameter: 7 * SCALE,
        height: 3.2 * SCALE,
        tessellation: 32
      }, scene);
      body.scaling.z = 0.7;
      body.position = backpackBase.position.add(new BABYLON.Vector3(0, 1.8 * SCALE, 0.1 * SCALE));
      const bodyMat = new BABYLON.StandardMaterial("bodyMat", scene);
      bodyMat.diffuseColor = new BABYLON.Color3(0.45, 0.62, 0.93);
      bodyMat.alpha = 0.55;
      body.material = bodyMat;
      body.isPickable = false;

      // ××›×¡×”
      const lid = BABYLON.MeshBuilder.CreateCylinder("packLid", {
        diameter: 7 * SCALE,
        height: 0.4 * SCALE,
        tessellation: 32
      }, scene);
      lid.scaling.z = 0.7;
      lid.position = backpackBase.position.add(new BABYLON.Vector3(0, 3.3 * SCALE, 0.2 * SCALE));
      const lidMat = new BABYLON.StandardMaterial("lidMat", scene);
      lidMat.diffuseColor = new BABYLON.Color3(0.35, 0.52, 0.88);
      lid.material = lidMat;
      lid.isPickable = false;

      // ×™×“×™×ª
      const handle = BABYLON.MeshBuilder.CreateTorus("handle", {
        diameter: 3 * SCALE,
        thickness: 0.3 * SCALE,
        tessellation: 32
      }, scene);
      handle.position = backpackBase.position.add(new BABYLON.Vector3(0, 3.9 * SCALE, 2 * SCALE));
      const handleMat = new BABYLON.StandardMaterial("handleMat", scene);
      handleMat.diffuseColor = new BABYLON.Color3(0.95, 0.95, 1);
      handleMat.specularColor = new BABYLON.Color3(0.9, 0.9, 1);
      handle.material = handleMat;
      handle.isPickable = false;

      // ×¡×œ×•×˜×™× ×¢×œ ×”×¨×¦×¤×”
      const center = backpackBase.position.add(new BABYLON.Vector3(0, 0.6 * SCALE, 0));
      const dx = 2.2 * SCALE;
      const dz = 1.7 * SCALE;

      for (let row = 0; row < 2; row++) {
        for (let col = 0; col < 3; col++) {
          const pos = new BABYLON.Vector3(
            center.x + (col - 1) * dx,
            center.y + row * 1.3 * SCALE,
            center.z + (row === 0 ? 0.6 * SCALE : -0.6 * SCALE)
          );
          backpackSlots.push(pos);

          const slot = BABYLON.MeshBuilder.CreateBox("slotViz", {
            width: 1.9 * SCALE,
            height: 0.03 * SCALE,
            depth: 1.3 * SCALE
          }, scene);
          slot.position = new BABYLON.Vector3(pos.x, backpackBase.position.y + 0.01 * SCALE, pos.z);
          const sMat = new BABYLON.StandardMaterial("slotMat", scene);
          sMat.diffuseColor = new BABYLON.Color3(0.7, 0.85, 1);
          sMat.alpha = 0.45;
          slot.material = sMat;
          slot.isPickable = false;
        }
      }

      // ×›×™×ª×•×‘ GUI "××¨×’×– ×¦×™×•×“"
      const rect = new BABYLON.GUI.Rectangle();
      rect.width = IS_MOBILE ? "130px" : "140px";
      rect.height = "34px";
      rect.thickness = 0;
      rect.cornerRadius = 17;
      rect.background = "rgba(255,255,255,0.96)";
      ui.addControl(rect);
      rect.linkWithMesh(backpackBase);
      rect.linkOffsetY = -42;

      const txt = new BABYLON.GUI.TextBlock();
      txt.text = "ğŸ’ ××¨×’×– ×¦×™×•×“ ×ª×¢×©×™×™×ª×™";
      txt.color = "#1a237e";
      txt.fontSize = IS_MOBILE ? 13 : 14;
      txt.fontFamily = "Heebo";
      rect.addControl(txt);
    }

    // ===== ×™×¦×™×¨×ª ×”××•×¦×¨×™× =====
    function createItems(scene) {
      itemRoots = [];
      const startX = -11 * SCALE;
      const gapX   = 4 * SCALE;
      const rowZ   = [-2.5 * SCALE, 2.5 * SCALE];

      ITEMS.forEach((item, i) => {
        const row = i < 3 ? 0 : 1;
        const col = i % 3;

        const root = new BABYLON.TransformNode("itemRoot_" + i, scene);
        root.position = new BABYLON.Vector3(
          startX + col * gapX,
          2.8 * SCALE,
          rowZ[row]
        );

        buildItemModel(scene, root, item);

        root.metadata = {
          type: "itemRoot",
          index: i,
          selected: false,
          basePosition: root.position.clone(),
          slotIndex: null
        };

        // ×ª×•×•×™×ª GUI â€“ ×œ× ×—×•×¡××ª ×œ×—×™×¦×•×ª
        const rect = new BABYLON.GUI.Rectangle();
        rect.width = IS_MOBILE ? "170px" : "210px";
        rect.height = IS_MOBILE ? "48px" : "64px";
        rect.thickness = 0;
        rect.cornerRadius = 16;
        rect.background = "rgba(255,255,255,0.9)";
        rect.alpha = 0.95;
        rect.isPointerBlocker = false;
        ui.addControl(rect);
        rect.linkWithMesh(root);
        rect.linkOffsetY = IS_MOBILE ? -70 : -60;

        const lbl = new BABYLON.GUI.TextBlock();
        lbl.text = `${item.name}\n××©×§×œ: ${item.weight} | ×¢×¨×š: ${item.value}`;
        lbl.fontFamily = "Heebo";
        lbl.color = "#263238";
        lbl.fontSize = IS_MOBILE ? 11 : 13;
        lbl.textWrapping = true;
        rect.addControl(lbl);

        itemRoots.push(root);
      });
    }

    // (buildItemModel â€“ ×›××• ×§×•×“×, ×”×©××¨×ª×™ ××•×ª×• ×œ×œ× ×©×™× ×•×™ ××™×•×—×“ ×œ×˜×•×‘×ª ×”×§×™×¦×•×¨)
    function buildItemModel(scene, root, item) {
      const col = item.color;

      if (item.type === "servo") {
        const base = BABYLON.MeshBuilder.CreateBox("servoBase", {
          width: 1.8 * SCALE,
          height: 0.6 * SCALE,
          depth: 1.4 * SCALE
        }, scene);
        base.parent = root;
        base.position.y = 0.3 * SCALE;
        const baseMat = new BABYLON.StandardMaterial("servoBaseMat", scene);
        baseMat.diffuseColor = new BABYLON.Color3(0.15, 0.15, 0.18);
        baseMat.specularColor = new BABYLON.Color3(0.8, 0.8, 0.8);
        base.material = baseMat;

        const body = BABYLON.MeshBuilder.CreateBox("servoBody", {
          width: 1.5 * SCALE,
          height: 0.9 * SCALE,
          depth: 1.1 * SCALE
        }, scene);
        body.parent = root;
        body.position.y = 0.9 * SCALE;
        const bodyMat = new BABYLON.StandardMaterial("servoBodyMat", scene);
        bodyMat.diffuseColor = col;
        bodyMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
        body.material = bodyMat;

        const shaft = BABYLON.MeshBuilder.CreateCylinder("servoShaft", {
          diameter: 0.35 * SCALE,
          height: 0.4 * SCALE
        }, scene);
        shaft.parent = root;
        shaft.position = new BABYLON.Vector3(0, 1.4 * SCALE, 0);
        const shaftMat = new BABYLON.StandardMaterial("shaftMat", scene);
        shaftMat.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.95);
        shaft.material = shaftMat;

        const horn = BABYLON.MeshBuilder.CreateBox("servoHorn", {
          width: 1.6 * SCALE,
          height: 0.12 * SCALE,
          depth: 0.35 * SCALE
        }, scene);
        horn.parent = root;
        horn.position = new BABYLON.Vector3(0, 1.55 * SCALE, 0);
        horn.material = shaftMat;

      } else if (item.type === "laser") {
        const body = BABYLON.MeshBuilder.CreateBox("laserBody", {
          width: 1.6 * SCALE,
          height: 0.7 * SCALE,
          depth: 1.1 * SCALE
        }, scene);
        body.parent = root;
        const bodyMat = new BABYLON.StandardMaterial("laserBodyMat", scene);
        bodyMat.diffuseColor = col;
        bodyMat.specularColor = new BABYLON.Color3(0.8, 0.8, 0.9);
        body.material = bodyMat;

        const lens = BABYLON.MeshBuilder.CreateCylinder("laserLens", {
          diameter: 0.6 * SCALE,
          height: 0.35 * SCALE,
          tessellation: 24
        }, scene);
        lens.parent = root;
        lens.position.z = 0.7 * SCALE;
        const lensMat = new BABYLON.StandardMaterial("lensMat", scene);
        lensMat.diffuseColor = new BABYLON.Color3(0.1, 0.5, 1);
        lensMat.emissiveColor = new BABYLON.Color3(0.1, 0.6, 1);
        lens.material = lensMat;

        const bracket = BABYLON.MeshBuilder.CreateBox("laserBracket", {
          width: 0.8 * SCALE,
          height: 0.2 * SCALE,
          depth: 1.2 * SCALE
        }, scene);
        bracket.parent = root;
        bracket.position.y = -0.45 * SCALE;
        const brMat = new BABYLON.StandardMaterial("brMat", scene);
        brMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.25);
        bracket.material = brMat;

      } else if (item.type === "plc") {
        const rack = BABYLON.MeshBuilder.CreateBox("plcRack", {
          width: 2.4 * SCALE,
          height: 1.4 * SCALE,
          depth: 0.9 * SCALE
        }, scene);
        rack.parent = root;
        rack.position.y = 0.8 * SCALE;
        const rMat = new BABYLON.StandardMaterial("rackMat", scene);
        rMat.diffuseColor = new BABYLON.Color3(0.18, 0.19, 0.22);
        rack.material = rMat;

        for (let i = 0; i < 4; i++) {
          const mod = BABYLON.MeshBuilder.CreateBox("plcMod" + i, {
            width: 0.5 * SCALE,
            height: 1.1 * SCALE,
            depth: 0.7 * SCALE
          }, scene);
          mod.parent = root;
          mod.position = new BABYLON.Vector3(
            -0.75 * SCALE + i * 0.5 * SCALE,
            0.8 * SCALE,
            0
          );
          const mMat = new BABYLON.StandardMaterial("plcModMat" + i, scene);
          mMat.diffuseColor = new BABYLON.Color3(0.4 + 0.1 * i, 0.5, 0.7);
          mod.material = mMat;
        }

      } else if (item.type === "robotArm") {
        const base = BABYLON.MeshBuilder.CreateCylinder("armBase", {
          diameter: 1.3 * SCALE,
          height: 0.4 * SCALE
        }, scene);
        base.parent = root;
        base.position.y = 0.2 * SCALE;
        const baseMat = new BABYLON.StandardMaterial("armBaseMat", scene);
        baseMat.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.3);
        base.material = baseMat;

        const joint1 = BABYLON.MeshBuilder.CreateCylinder("joint1", {
          diameter: 0.9 * SCALE,
          height: 0.6 * SCALE
        }, scene);
        joint1.parent = root;
        joint1.position.y = 0.7 * SCALE;
        const jMat = new BABYLON.StandardMaterial("jMat", scene);
        jMat.diffuseColor = col;
        joint1.material = jMat;

        const arm1 = BABYLON.MeshBuilder.CreateBox("arm1", {
          width: 0.4 * SCALE,
          height: 1.6 * SCALE,
          depth: 0.4 * SCALE
        }, scene);
        arm1.parent = root;
        arm1.position = new BABYLON.Vector3(0, 1.6 * SCALE, 0.2 * SCALE);
        arm1.rotation.z = -0.3;
        arm1.material = jMat;

        const joint2 = BABYLON.MeshBuilder.CreateSphere("joint2", {
          diameter: 0.6 * SCALE
        }, scene);
        joint2.parent = root;
        joint2.position = new BABYLON.Vector3(0.3 * SCALE, 2.2 * SCALE, 0.4 * SCALE);
        joint2.material = jMat;

        const arm2 = BABYLON.MeshBuilder.CreateBox("arm2", {
          width: 0.35 * SCALE,
          height: 1.2 * SCALE,
          depth: 0.35 * SCALE
        }, scene);
        arm2.parent = root;
        arm2.position = new BABYLON.Vector3(0.4 * SCALE, 2.7 * SCALE, 0.7 * SCALE);
        arm2.rotation.z = 0.4;
        arm2.material = jMat;

        const gripper = BABYLON.MeshBuilder.CreateBox("gripper", {
          width: 0.7 * SCALE,
          height: 0.2 * SCALE,
          depth: 0.5 * SCALE
        }, scene);
        gripper.parent = root;
        gripper.position = new BABYLON.Vector3(0.6 * SCALE, 3.3 * SCALE, 0.9 * SCALE);
        const gMat = new BABYLON.StandardMaterial("gMat", scene);
        gMat.diffuseColor = new BABYLON.Color3(0.15, 0.15, 0.2);
        gripper.material = gMat;

      } else if (item.type === "camera") {
        const body = BABYLON.MeshBuilder.CreateBox("camBody", {
          width: 1.6 * SCALE,
          height: 0.9 * SCALE,
          depth: 0.9 * SCALE
        }, scene);
        body.parent = root;
        const bMat = new BABYLON.StandardMaterial("camMat", scene);
        bMat.diffuseColor = new BABYLON.Color3(0.2, 0.22, 0.26);
        body.material = bMat;

        const lens = BABYLON.MeshBuilder.CreateCylinder("camLens", {
          diameter: 0.7 * SCALE,
          height: 0.6 * SCALE,
          tessellation: 24
        }, scene);
        lens.parent = root;
        lens.position.z = 0.7 * SCALE;
        const lMat = new BABYLON.StandardMaterial("camLensMat", scene);
        lMat.diffuseColor = new BABYLON.Color3(0.1, 0.5, 1);
        lMat.emissiveColor = new BABYLON.Color3(0.1, 0.6, 1);
        lens.material = lMat;

        const mount = BABYLON.MeshBuilder.CreateBox("camMount", {
          width: 0.8 * SCALE,
          height: 0.2 * SCALE,
          depth: 1.2 * SCALE
        }, scene);
        mount.parent = root;
        mount.position.y = -0.5 * SCALE;
        const mMat = new BABYLON.StandardMaterial("camMountMat", scene);
        mMat.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.3);
        mount.material = mMat;

      } else if (item.type === "rfid") {
        const body = BABYLON.MeshBuilder.CreateBox("rfidBody", {
          width: 1.9 * SCALE,
          height: 0.4 * SCALE,
          depth: 1.5 * SCALE
        }, scene);
        body.parent = root;
        const bMat = new BABYLON.StandardMaterial("rfidMat", scene);
        bMat.diffuseColor = col;
        bMat.specularColor = new BABYLON.Color3(0.85, 0.85, 0.95);
        body.material = bMat;

        const frame = BABYLON.MeshBuilder.CreateTorus("rfidFrame", {
          diameter: 1.3 * SCALE,
          thickness: 0.08 * SCALE,
          tessellation: 32
        }, scene);
        frame.parent = root;
        frame.rotation.x = Math.PI / 2;
        frame.position.y = 0.25 * SCALE;
        const fMat = new BABYLON.StandardMaterial("rfidFrameMat", scene);
        fMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
        frame.material = fMat;
      }
    }

    // ===== ×‘×—×™×¨×” =====
    function setupPicking(scene) {
      scene.onPointerDown = (evt, pickResult) => {
        if (!pickResult || !pickResult.hit || !pickResult.pickedMesh) return;

        let node = pickResult.pickedMesh;
        while (node && (!node.metadata || node.metadata.type !== "itemRoot")) {
          node = node.parent;
        }
        if (!node || !node.metadata) return;

        toggleItem(node);
      };

      checkBtn.addEventListener("click", checkSolution);
    }

    // ===== ×× ×™××¦×™×™×ª ××¢×‘×¨ â€“ ×™×•×ª×¨ ××™×˜×™×ª =====
    function moveNodeTo(node, newPos) {
      const from = node.position.clone();
      const to = newPos.clone();

      const anim = new BABYLON.Animation(
        "moveAnim_" + node.name,
        "position",
        60,
        BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
      );

      const keys = [
        { frame: 0,  value: from },
        { frame: 45, value: to }  // ×”×™×” 30 â€“ ×¢×›×©×™×• ×—×œ×§ ×™×•×ª×¨
      ];
      anim.setKeys(keys);

      node.animations = [anim];
      node.getScene().beginAnimation(node, 0, 45, false);
    }

    // ===== ×œ×•×’×™×§×ª ×”×•×¡×¤×” / ×”×•×¦××” =====
    let backpackSlotsCount = 0;

    function toggleItem(root) {
      const idx = root.metadata.index;
      const item = ITEMS[idx];

      if (!root.metadata.selected) {
        // ×”×•×¡×¤×”
        root.metadata.selected = true;
        currentWeight += item.weight;
        currentValue  += item.value;

        // ×¡×œ×•×˜ ×¤× ×•×™
        let freeIndex = null;
        for (let i = 0; i < backpackSlots.length; i++) {
          let taken = false;
          for (const n of itemRoots) {
            if (n.metadata.selected && n.metadata.slotIndex === i) {
              taken = true;
              break;
            }
          }
          if (!taken) {
            freeIndex = i;
            break;
          }
        }

        if (freeIndex === null) {
          // ××™×Ÿ ××§×•×
          root.metadata.selected = false;
          currentWeight -= item.weight;
          currentValue  -= item.value;
          msgEl.textContent = "×”××¨×’×– ××œ× ×¤×™×–×™×ª â€“ ×ª×•×¦×™× ××•×¦×¨ ××—×“ ×›×“×™ ×œ×¤× ×•×ª ××§×•×.";
          msgEl.style.color = "#e53935";
        } else {
          root.metadata.slotIndex = freeIndex;
          const target = backpackSlots[freeIndex];
          moveNodeTo(root, target);
          playMoveSfx();
        }

      } else {
        // ×”×•×¦××”
        root.metadata.selected = false;
        currentWeight -= item.weight;
        currentValue  -= item.value;
        const base = root.metadata.basePosition.clone();
        root.metadata.slotIndex = null;
        moveNodeTo(root, base);
        playMoveSfx();
      }

      updateHUD();
    }

    function updateHUD() {
      weightEl.textContent = "××©×§×œ × ×•×›×—×™: " + currentWeight;
      valueEl.textContent  = "×¢×¨×š × ×•×›×—×™: " + currentValue;

      if (currentWeight > CAPACITY) {
        weightEl.style.color = "#e53935";
        msgEl.textContent = "×”××©×§×œ ×›×¨×’×¢ ×—×•×¨×’ ××”×§×™×‘×•×œ×ª â€“ ×ª×•×¦×™× ××•×¦×¨ ××• ×©× ×™×™× ×•×ª× ×¡×” ×§×•××‘×™× ×¦×™×” ××—×¨×ª.";
        msgEl.style.color = "#e53935";
      } else {
        weightEl.style.color = "#000";
        msgEl.textContent = "×œ×—×¥ ×¢×œ ××•×¦×¨×™× ×›×“×™ ×œ×”×•×¡×™×£ / ×œ×”×•×¦×™×. × ×¡×” ×œ×”×’×™×¢ ×œ×¢×¨×š ×”×›×™ ×’×‘×•×” ×‘×œ×™ ×œ×—×¨×•×’ ××”×§×™×‘×•×œ×ª.";
        msgEl.style.color = "#000";
      }
    }

    // ===== ×‘×“×™×§×ª ×¤×ª×¨×•×Ÿ =====
    function checkSolution() {
      if (currentWeight > CAPACITY) {
        msgEl.textContent = "×”××©×§×œ ×¢×“×™×™×Ÿ ×—×•×¨×’ ××”×§×™×‘×•×œ×ª â€“ ×§×•×“× ×ª××–×Ÿ ××ª ×”××©×§×œ ×•××– ×‘×“×•×§ ×©×•×‘.";
        msgEl.style.color = "#e53935";
        return;
      }

      const diff = bestPossibleValue - currentValue;

      if (diff === 0) {
        msgEl.textContent = "ğŸ‰ ××¦×•×™×Ÿ! ×”×’×¢×ª ×œ×¤×ª×¨×•×Ÿ ××•×¤×˜×™××œ×™ â€“ ××™×Ÿ ×§×•××‘×™× ×¦×™×” ×˜×•×‘×” ×™×•×ª×¨ ××”×‘×—×™×¨×” ×©×œ×š.";
        msgEl.style.color = "#2e7d32";
      } else if (diff <= 2) {
        msgEl.textContent = "ğŸ‘ ××ª×” ×××© ×§×¨×•×‘ ×œ×¤×ª×¨×•×Ÿ ×”×˜×•×‘ ×‘×™×•×ª×¨! ××¤×©×¨ ×œ×©×¤×¨ ×¢×•×“ ×§×¦×ª ×•×œ×”×•×¡×™×£ ×¢×¨×š ×©×œ " + diff + ".";
        msgEl.style.color = "#fbc02d";
      } else {
        msgEl.textContent = "â„¹ ×™×© ×¤×ª×¨×•×Ÿ ×˜×•×‘ ×™×•×ª×¨ â€“ ×”×¢×¨×š ×”××§×¡×™××œ×™ ×”××¤×©×¨×™ ×”×•× " + bestPossibleValue + ". × ×¡×” ×§×•××‘×™× ×¦×™×” ××—×¨×ª.";
        msgEl.style.color = "#f9a825";
      }
    }

    // ===== ×”×ª×—×œ×” =====
    bestPossibleValue = computeOptimalValue();
    scene = createScene();

    engine.runRenderLoop(() => { scene.render(); });

    window.addEventListener("resize", () => {
      engine.resize();
      engine.setHardwareScalingLevel(1 / Math.min(window.devicePixelRatio || 1, 2));
    });
  </script>
</body>
</html>
