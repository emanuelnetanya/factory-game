<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#1565C0">
  <title>××©×—×§ ×”×§×¦××ª ×©×œ×™×—×™× - ×”××œ×’×•×¨×™×ª× ×”×”×•× ×’×¨×™</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Heebo:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: "Heebo", Arial, sans-serif;
      position: fixed;
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 50%, #90caf9 100%);
    }

    #renderCanvas {
      width: 100vw;
      height: 100vh;
      height: 100dvh;
      display: block;
      outline: none;
      position: fixed;
      top: 0;
      left: 0;
      touch-action: none;
    }

    /* ========== SPLASH SCREEN ========== */
    #splashScreen {
      position: fixed;
      inset: 0;
      background: linear-gradient(135deg, #1565C0 0%, #0D47A1 50%, #1a237e 100%);
      z-index: 10000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 20px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      touch-action: pan-y;
    }

    #splashScreen.hidden { display: none; }

    .splash-content {
      max-width: 420px;
      width: 100%;
      text-align: center;
      padding-bottom: 40px;
    }

    .splash-icon {
      font-size: 70px;
      margin-bottom: 10px;
      margin-top: 20px;
      animation: float 3s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-12px); }
    }

    .splash-title {
      font-size: 32px;
      font-weight: 800;
      color: white;
      margin-bottom: 8px;
      text-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    .splash-subtitle {
      font-size: 16px;
      color: rgba(255,255,255,0.85);
      margin-bottom: 24px;
    }

    .splash-section {
      background: rgba(255,255,255,0.95);
      border-radius: 16px;
      padding: 16px;
      margin-bottom: 14px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      text-align: right;
    }

    .splash-section h3 {
      font-size: 16px;
      color: #1565C0;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .splash-section p {
      font-size: 14px;
      color: #37474f;
      line-height: 1.7;
    }

    .splash-section ol {
      padding-right: 20px;
      margin: 0;
    }

    .splash-section li {
      font-size: 14px;
      color: #37474f;
      line-height: 1.7;
      margin-bottom: 6px;
    }

    .highlight-text {
      color: #1565C0;
      font-weight: 700;
    }

    .warning-text {
      color: #e65100;
      font-weight: 700;
    }

    #startBtn {
      background: linear-gradient(135deg, #ffffff, #e3f2fd);
      color: #1565C0;
      border: none;
      padding: 16px 48px;
      border-radius: 16px;
      font-size: 20px;
      font-weight: 800;
      font-family: inherit;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      transition: transform 0.2s, box-shadow 0.2s;
      margin-top: 10px;
    }

    #startBtn:active {
      transform: scale(0.95);
    }

    /* ========== ROTATE DEVICE ========== */
    #rotateDevice {
      display: none;
      position: fixed;
      inset: 0;
      background: linear-gradient(135deg, #1565C0, #0D47A1);
      z-index: 9999;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      text-align: center;
      padding: 20px;
    }

    #rotateDevice .icon {
      font-size: 80px;
      margin-bottom: 20px;
      animation: rotateAnim 2s ease-in-out infinite;
    }

    @keyframes rotateAnim {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(90deg); }
    }

    #rotateDevice h2 {
      font-size: 24px;
      margin-bottom: 10px;
    }

    #rotateDevice p {
      font-size: 16px;
      opacity: 0.9;
    }

    @media (max-width: 900px) and (orientation: portrait) {
      #rotateDevice { display: flex; }
      #renderCanvas, #topBar, #sidePanel, #infoPanel, #statusBar { 
        opacity: 0; 
        pointer-events: none; 
      }
    }

    /* ========== NEW TOP BAR DESIGN ========== */
    #topBar {
      position: fixed;
      top: max(12px, env(safe-area-inset-top, 12px));
      left: 0;
      right: 0;
      padding: 0 16px;
      display: none;
      align-items: center;
      justify-content: space-between;
      z-index: 100;
    }

    #topBar.visible { display: flex; }

    .side-buttons-left, .side-buttons-right {
      display: flex;
      gap: 8px;
    }

    .side-btn {
      width: 46px;
      height: 46px;
      border: none;
      border-radius: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.25);
      transition: transform 0.15s;
    }

    .side-btn:active { transform: scale(0.9); }

    .btn-red { background: linear-gradient(135deg, #ff6b6b, #ee5a5a); }
    .btn-yellow { background: linear-gradient(135deg, #ffd54f, #ffca28); }
    .btn-green { background: linear-gradient(135deg, #69db7c, #51cf66); }
    .btn-blue { background: linear-gradient(135deg, #74c0fc, #4dabf7); }

    .center-panel {
      background: linear-gradient(135deg, #1565C0, #0D47A1);
      border-radius: 18px;
      padding: 10px 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 6px 25px rgba(0,0,0,0.35);
    }

    .stat-box {
      background: rgba(255,255,255,0.18);
      border-radius: 12px;
      padding: 8px 18px;
      text-align: center;
      min-width: 75px;
    }

    .stat-box .label {
      font-size: 11px;
      color: rgba(255,255,255,0.85);
      font-weight: 600;
    }

    .stat-box .value {
      font-size: 26px;
      font-weight: 800;
      color: white;
    }

    .check-btn {
      background: linear-gradient(135deg, #69f0ae, #00e676);
      border: none;
      border-radius: 12px;
      padding: 14px 28px;
      color: #1b5e20;
      font-family: inherit;
      font-size: 16px;
      font-weight: 800;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      opacity: 0.5;
      pointer-events: none;
      transition: all 0.2s;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    .check-btn.active {
      opacity: 1;
      pointer-events: auto;
    }

    .check-btn:active { transform: scale(0.95); }

    /* ========== OVERLAY ========== */
    #overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      z-index: 199;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    #overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    /* ========== SIDE PANEL (HELP) ========== */
    #sidePanel {
      position: fixed;
      top: 0;
      right: -340px;
      width: 320px;
      max-width: 90vw;
      height: 100%;
      height: 100dvh;
      background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(227,242,253,0.98));
      backdrop-filter: blur(20px);
      box-shadow: -4px 0 30px rgba(0,0,0,0.3);
      z-index: 200;
      transition: right 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      touch-action: pan-y;
      padding: max(20px, env(safe-area-inset-top, 20px)) 16px 100px 16px;
    }

    #sidePanel.open { right: 0; }

    .panel-close {
      position: absolute;
      top: max(16px, env(safe-area-inset-top, 16px));
      left: 16px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: none;
      background: #e0e0e0;
      color: #424242;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .panel-title {
      font-size: 22px;
      font-weight: 800;
      color: #1565C0;
      margin-bottom: 20px;
      margin-top: 40px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .panel-section {
      background: white;
      border-radius: 14px;
      padding: 16px;
      margin-bottom: 14px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.08);
    }

    .panel-section h3 {
      font-size: 15px;
      color: #1565C0;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .panel-section p {
      font-size: 13px;
      color: #37474f;
      line-height: 1.7;
    }

    .tip-box {
      background: linear-gradient(135deg, #fff8e1, #ffecb3);
      border: 2px solid #FFC107;
      border-radius: 14px;
      padding: 14px;
      margin-top: 14px;
    }

    .tip-box h4 {
      color: #e65100;
      font-size: 14px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .tip-box p {
      font-size: 12px;
      color: #5D4037;
      line-height: 1.6;
    }

    /* ========== INFO PANEL ========== */
    #infoPanel {
      position: fixed;
      top: 0;
      right: -360px;
      width: 340px;
      max-width: 90vw;
      height: 100%;
      height: 100dvh;
      background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(232,245,233,0.98));
      backdrop-filter: blur(20px);
      box-shadow: -4px 0 30px rgba(0,0,0,0.3);
      z-index: 200;
      transition: right 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      touch-action: pan-y;
      padding: max(20px, env(safe-area-inset-top, 20px)) 16px 100px 16px;
    }

    #infoPanel.open { right: 0; }

    .edu-icon {
      font-size: 50px;
      text-align: center;
      margin-bottom: 10px;
      margin-top: 40px;
    }

    .edu-title {
      font-size: 20px;
      font-weight: 800;
      color: #2e7d32;
      text-align: center;
      margin-bottom: 20px;
    }

    .edu-section {
      background: white;
      border-radius: 14px;
      padding: 16px;
      margin-bottom: 14px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.08);
    }

    .edu-section h3 {
      font-size: 14px;
      color: #2e7d32;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .edu-section p {
      font-size: 12px;
      color: #37474f;
      line-height: 1.7;
    }

    .uses-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 10px;
    }

    .use-tag {
      background: linear-gradient(135deg, #e8f5e9, #c8e6c9);
      color: #1b5e20;
      padding: 5px 12px;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 600;
    }

    /* ========== COURIER MODAL ========== */
    #courierModal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(8px);
      z-index: 300;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    #courierModal.visible { display: flex; }

    .modal-content {
      background: white;
      border-radius: 20px;
      max-width: 400px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0,0,0,0.4);
      animation: modalPop 0.3s ease;
    }

    @keyframes modalPop {
      from { transform: scale(0.9); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    .modal-header {
      padding: 18px;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .modal-courier-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .modal-courier-avatar {
      width: 50px;
      height: 50px;
      border-radius: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 26px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }

    .modal-courier-name {
      font-size: 20px;
      font-weight: 800;
      color: #333;
    }

    .modal-courier-status {
      font-size: 12px;
      color: #888;
    }

    .modal-close {
      width: 36px;
      height: 36px;
      border: none;
      background: #f0f0f0;
      border-radius: 50%;
      font-size: 18px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-body { padding: 18px; }

    .modal-section-title {
      font-size: 14px;
      font-weight: 700;
      color: #1565C0;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .time-matrix {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .matrix-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 16px;
      background: #f8f9ff;
      border-radius: 14px;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.2s;
    }

    .matrix-row:hover {
      background: #e8f0ff;
      border-color: #1565C0;
    }

    .matrix-row.assigned {
      background: linear-gradient(135deg, #e8f5e9, #c8e6c9);
      border-color: #4CAF50;
    }

    .matrix-row.assigned-other {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .matrix-row-info {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .matrix-family-dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
    }

    .matrix-family-name {
      font-weight: 700;
      font-size: 14px;
      color: #333;
    }

    .matrix-restaurant {
      font-size: 11px;
      color: #888;
    }

    .matrix-time {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .matrix-time-value {
      font-size: 18px;
      font-weight: 800;
      color: #1565C0;
    }

    .matrix-select-btn {
      padding: 8px 16px;
      background: linear-gradient(135deg, #1565C0, #0D47A1);
      color: white;
      border: none;
      border-radius: 20px;
      font-family: inherit;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
    }

    .matrix-row.assigned .matrix-select-btn { background: #4CAF50; }
    .matrix-row.assigned-other .matrix-select-btn { display: none; }

    .assigned-badge {
      display: none;
      padding: 6px 12px;
      background: #999;
      color: white;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 700;
    }

    .matrix-row.assigned-other .assigned-badge { display: block; }

    /* ========== CELEBRATION ========== */
    #celebration {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      backdrop-filter: blur(10px);
      z-index: 400;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
      overflow-y: auto;
    }

    #celebration.visible { display: flex; }

    .celeb-card {
      background: white;
      border-radius: 24px;
      max-width: 450px;
      width: 100%;
      padding: 28px;
      text-align: center;
      box-shadow: 0 25px 70px rgba(0,0,0,0.4);
      animation: celebPop 0.5s ease;
    }

    @keyframes celebPop {
      0% { transform: scale(0.8) translateY(40px); opacity: 0; }
      100% { transform: scale(1) translateY(0); opacity: 1; }
    }

    .celeb-icon { font-size: 60px; margin-bottom: 12px; }

    .celeb-title {
      font-size: 28px;
      font-weight: 900;
      background: linear-gradient(135deg, #1565C0, #0D47A1);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 20px;
    }

    .results-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 20px;
    }

    .result-box {
      padding: 16px;
      border-radius: 16px;
      text-align: center;
    }

    .result-box.user {
      background: linear-gradient(135deg, #fff8e1, #ffecb3);
      border: 2px solid #FFC107;
    }

    .result-box.optimal {
      background: linear-gradient(135deg, #e8f5e9, #c8e6c9);
      border: 2px solid #4CAF50;
    }

    .result-label {
      font-size: 11px;
      font-weight: 700;
      color: #666;
      margin-bottom: 6px;
    }

    .result-value { font-size: 26px; font-weight: 900; }
    .result-box.user .result-value { color: #FF9800; }
    .result-box.optimal .result-value { color: #4CAF50; }

    .time-comparison {
      background: linear-gradient(135deg, #e3f2fd, #bbdefb);
      border: 2px solid #1565C0;
      border-radius: 16px;
      padding: 16px;
      margin-bottom: 20px;
      text-align: right;
    }

    .time-comparison h4 {
      font-size: 14px;
      color: #1565C0;
      margin-bottom: 10px;
    }

    .time-comparison p {
      font-size: 13px;
      color: #0D47A1;
      line-height: 1.7;
    }

    .optimal-list {
      background: #f5f5f5;
      border-radius: 14px;
      padding: 14px;
      margin-bottom: 20px;
      text-align: right;
    }

    .optimal-list h4 { font-size: 13px; color: #333; margin-bottom: 10px; }

    .optimal-item {
      font-size: 12px;
      color: #555;
      padding: 4px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .insight-box {
      background: linear-gradient(135deg, #1565C0, #0D47A1);
      border-radius: 16px;
      padding: 18px;
      margin-bottom: 20px;
      text-align: right;
    }

    .insight-box h4 {
      color: rgba(255,255,255,0.9);
      font-size: 13px;
      margin-bottom: 10px;
    }

    .insight-box p {
      color: white;
      font-size: 13px;
      line-height: 1.7;
    }

    #playAgainBtn {
      padding: 14px 40px;
      background: linear-gradient(135deg, #1565C0, #0D47A1);
      color: white;
      border: none;
      border-radius: 50px;
      font-family: inherit;
      font-size: 18px;
      font-weight: 800;
      cursor: pointer;
      box-shadow: 0 8px 25px rgba(21, 101, 192, 0.4);
    }

    /* ========== RESPONSIVE ========== */
    @media (max-width: 700px) {
      .center-panel { padding: 8px 12px; gap: 8px; }
      .stat-box { padding: 6px 12px; min-width: 60px; }
      .stat-box .value { font-size: 20px; }
      .stat-box .label { font-size: 10px; }
      .check-btn { padding: 10px 16px; font-size: 14px; }
      .side-btn { width: 40px; height: 40px; font-size: 18px; }
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <!-- Splash Screen -->
  <div id="splashScreen">
    <div class="splash-content">
      <div class="splash-icon">ğŸï¸</div>
      <h1 class="splash-title">××©×—×§ ×”×§×¦××ª ×©×œ×™×—×™×</h1>
      <p class="splash-subtitle">×œ××“ ××ª ×”××œ×’×•×¨×™×ª× ×”×”×•× ×’×¨×™ ×‘×¦×•×¨×” ××™× ×˜×¨××§×˜×™×‘×™×ª</p>

      <div class="splash-section">
        <h3>ğŸ“¦ ×¢×œ ×”××©×—×§</h3>
        <p>
          ××ª×” ×× ×”×œ ××¢×¨×›×ª ××©×œ×•×—×™× ×¢× <span class="highlight-text">4 ×©×œ×™×—×™×</span> ×•-<span class="highlight-text">4 ×”×–×× ×•×ª</span>.
          <br><br>
          ×›×œ ×”×–×× ×” ×›×•×œ×œ×ª ××¡×¢×“×” (××©× ×”×©×œ×™×— ××•×¡×£) ×•××©×¤×—×” (×œ×©× ×”×•× ××•×¡×¨). ×œ×›×œ ×©×œ×™×— ×™×© <span class="highlight-text">×–××Ÿ ×”×’×¢×” ×©×•× ×”</span> ×œ×›×œ ×”×–×× ×” ×‘×”×ª×× ×œ××™×§×•× ×©×œ×•.
        </p>
      </div>

      <div class="splash-section">
        <h3>ğŸ¯ ×”××˜×¨×”</h3>
        <p>
          ×©×‘×¥ ×›×œ ×©×œ×™×— ×œ×”×–×× ×” ××—×ª, ×›×š ×©<span class="highlight-text">×¡×›×•× ×”×–×× ×™× ×”×›×•×œ×œ</span> ×©×œ ×›×œ ×”×©×œ×™×—×™× ×™×—×“ ×™×”×™×” <span class="highlight-text">×”× ××•×š ×‘×™×•×ª×¨</span>.
          <br><br>
          <span class="warning-text">âš ï¸ ×©×™× ×œ×‘:</span> ×”××˜×¨×” ×”×™× ×œ× ×œ××¦×•× ××ª ×”×–××Ÿ ×”×§×¦×¨ ×œ×›×œ ×©×œ×™×— ×‘× ×¤×¨×“, ××œ× ××ª <span class="highlight-text">×”×–××Ÿ ×”×›×•×œ×œ ×”× ××•×š ×‘×™×•×ª×¨ ×œ×›×œ ×”××¢×¨×›×ª!</span>
        </p>
      </div>

      <div class="splash-section">
        <h3>ğŸ‘† ××™×š ××©×—×§×™×?</h3>
        <ol>
          <li><strong>×œ×—×¥ ×¢×œ ×©×œ×™×— (××•×¤× ×•×¢)</strong> - ×ª×™×¤×ª×— ×¨×©×™××ª ×”×–×× ×™× ×©×œ×•</li>
          <li><strong>×‘×—×¨ ×”×–×× ×”</strong> - ×”×©×œ×™×— ×™×©×•×‘×¥ ××œ×™×”</li>
          <li><strong>×—×–×•×¨ ×¢×œ ×”×ª×”×œ×™×š</strong> - ×©×‘×¥ ××ª ×›×œ 4 ×”×©×œ×™×—×™×</li>
          <li><strong>×œ×—×¥ "×‘×“×™×§×”"</strong> - ×’×œ×” ×× ××¦××ª ××ª ×”×¤×ª×¨×•×Ÿ ×”××•×¤×˜×™××œ×™!</li>
        </ol>
      </div>

      <button id="startBtn">ğŸš€ ×”×ª×—×œ ××©×—×§</button>
    </div>
  </div>

  <!-- Rotate Device -->
  <div id="rotateDevice">
    <div class="icon">ğŸ“±</div>
    <h2>×¡×•×‘×‘ ××ª ×”××›×©×™×¨</h2>
    <p>×”××©×—×§ ×¢×•×‘×“ ×‘××¦×‘ ×©×•×›×‘ (Landscape)</p>
  </div>

  <!-- NEW TOP BAR DESIGN -->
  <div id="topBar">
    <div class="side-buttons-left">
      <button class="side-btn btn-red" id="resetBtn" title="××™×¤×•×¡">ğŸ”„</button>
    </div>

    <div class="center-panel">
      <div class="stat-box">
        <div class="label">×©×•×‘×¦×•</div>
        <div class="value" id="assignedVal">0/4</div>
      </div>
      <div class="stat-box">
        <div class="label">×–××Ÿ ×›×•×œ×œ</div>
        <div class="value" id="totalTimeVal">0</div>
      </div>
      <button class="check-btn" id="checkBtn">âœ“ ×‘×“×™×§×”</button>
    </div>

    <div class="side-buttons-right">
      <button class="side-btn btn-yellow" id="hintBtn" title="×¨××–">ğŸ’¡</button>
      <button class="side-btn btn-green" id="helpBtn" title="×¢×–×¨×”">â“</button>
      <button class="side-btn btn-blue" id="infoBtn" title="××™×“×¢">ğŸ“</button>
    </div>
  </div>

  <!-- Overlay -->
  <div id="overlay"></div>

  <!-- Help Panel -->
  <div id="sidePanel">
    <button class="panel-close" onclick="closeAllPanels()">âœ•</button>
    <div class="panel-title">ğŸ® ××™×š ××©×—×§×™×?</div>

    <div class="panel-section">
      <h3>ğŸ“¦ ×¢×œ ×”××©×—×§</h3>
      <p>××ª×” ×× ×”×œ ××¢×¨×›×ª ××©×œ×•×—×™× ×¢× 4 ×©×œ×™×—×™× ×•-4 ×”×–×× ×•×ª. ×›×œ ×”×–×× ×” ×›×•×œ×œ×ª ××¡×¢×“×” (××©× ×”×©×œ×™×— ××•×¡×£ ××ª ×”××•×›×œ) ×•××©×¤×—×” (×œ×©× ×”×•× ××•×¡×¨). ×œ×›×œ ×©×œ×™×— ×™×© ×–××Ÿ ×”×’×¢×” ×©×•× ×” ×œ×›×œ ×”×–×× ×”, ×‘×”×ª×× ×œ××™×§×•× ×©×œ×• ×¢×œ ×”××¤×”.</p>
    </div>

    <div class="panel-section">
      <h3>ğŸ¯ ××” ×”××˜×¨×”?</h3>
      <p>×œ×©×‘×¥ ×›×œ ×©×œ×™×— ×œ×”×–×× ×” ××—×ª, ×›×š ×©×¡×›×•× ×”×–×× ×™× ×”×›×•×œ×œ ×©×œ ×›×œ ×”×©×œ×™×—×™× ×™×—×“ ×™×”×™×” ×”× ××•×š ×‘×™×•×ª×¨ ×”××¤×©×¨×™.</p>
      <p style="margin-top:10px;color:#e65100;font-weight:600;">×©×™× ×œ×‘: ××ª×” ×œ× ××—×¤×© ××ª ×”×–××Ÿ ×”×§×¦×¨ ×‘×™×•×ª×¨ ×œ×›×œ ×©×œ×™×— ×‘× ×¤×¨×“, ××œ× ××ª ×”×–××Ÿ ×”×›×•×œ×œ ×”× ××•×š ×‘×™×•×ª×¨ ×œ×›×œ ×”××¢×¨×›×ª!</p>
    </div>

    <div class="panel-section">
      <h3>ğŸ‘† ×©×œ×‘×™ ×”××©×—×§</h3>
      <p>×¨××©×™×ª, ×œ×—×¥ ×¢×œ ××—×“ ×”××•×¤× ×•×¢×™× ×‘××¤×”. ×–×” ×™×¤×ª×— ×—×œ×•×Ÿ ×©××¦×™×’ ××ª ×›×œ ×”×”×–×× ×•×ª, ×•×œ×›×œ ××—×ª ×ª×¨××” ×›××” ×–××Ÿ ×™×™×§×— ×œ×©×œ×™×— ×œ×”×’×™×¢.</p>
      <p style="margin-top:8px;">×©× ×™×ª, ×‘×—×¨ ×”×–×× ×” ×¢×‘×•×¨ ×”×©×œ×™×—. ×ª×¨××” ×§×• ×¦×‘×¢×•× ×™ ×©××¨××” ××ª ×”××¡×œ×•×œ ×©×œ×•.</p>
      <p style="margin-top:8px;">×©×œ×™×©×™×ª, ×—×–×•×¨ ×¢×œ ×”×ª×”×œ×™×š ×¢×‘×•×¨ ×©××¨ ×”×©×œ×™×—×™× ×¢×“ ×©×©×™×‘×¦×ª ××ª ×›×•×œ×.</p>
      <p style="margin-top:8px;">×œ×‘×¡×•×£, ×œ×—×¥ ×¢×œ ×›×¤×ª×•×¨ ×”×‘×“×™×§×” ×•×’×œ×” ×× ××¦××ª ××ª ×”×¤×ª×¨×•×Ÿ ×”××•×¤×˜×™××œ×™!</p>
    </div>

    <div class="tip-box">
      <h4>ğŸ’¡ ××™×š ×œ×—×©×•×‘ × ×›×•×Ÿ?</h4>
      <p>×”×˜×¢×•×ª ×”× ×¤×•×¦×” ×”×™× ×œ×©×‘×¥ ×›×œ ×©×œ×™×— ×œ×”×–×× ×” ×©×”×•× ××’×™×¢ ××œ×™×” ×”×›×™ ××”×¨. ×–×” ×œ× ×ª××™×“ ×”×¤×ª×¨×•×Ÿ ×”×˜×•×‘ ×‘×™×•×ª×¨!</p>
      <p style="margin-top:8px;">×œ×¤× ×™ ×©××ª×” ××©×‘×¥ ×©×œ×™×—, ×‘×“×•×§ ×’× ××ª ×”×–×× ×™× ×©×œ ×”×©×œ×™×—×™× ×”××—×¨×™× ×œ××•×ª×” ×”×–×× ×”. ×©××œ ××ª ×¢×¦××š: ×× ×× ×™ ××©×‘×¥ ××ª ×”×©×œ×™×— ×”×–×” ×›××Ÿ, ××” ×™×§×¨×” ×œ×©××¨?</p>
    </div>
  </div>

  <!-- Info Panel -->
  <div id="infoPanel">
    <button class="panel-close" onclick="closeAllPanels()">âœ•</button>
    <div class="edu-icon">ğŸ§ </div>
    <div class="edu-title">××” ×œ×•××“×™× ×›××Ÿ?</div>

    <div class="edu-section">
      <h3>ğŸ“š ×”××œ×’×•×¨×™×ª× ×”×”×•× ×’×¨×™</h3>
      <p>×”××œ×’×•×¨×™×ª× ×”×”×•× ×’×¨×™ (Hungarian Algorithm) ×¤×•×ª×— ×‘-1955 ×¢×œ ×™×“×™ ×”××ª××˜×™×§××™ ×”×¨×•×œ×“ ×§×•×Ÿ. ×”×•× ×¤×•×ª×¨ ××ª ×‘×¢×™×™×ª ×”×”×§×¦××” - ×›×™×¦×“ ×œ×©×‘×¥ N ×¢×•×‘×“×™× ×œ-N ××©×™××•×ª ×›×š ×©×”×¢×œ×•×ª ×”×›×•×œ×œ×ª ×ª×”×™×” ××™× ×™××œ×™×ª.</p>
    </div>

    <div class="edu-section">
      <h3>ğŸ”§ ××™×¤×” ×–×” ×‘×©×™××•×©?</h3>
      <div class="uses-list">
        <span class="use-tag">×©×™×‘×•×¥ ×©×œ×™×—×™×</span>
        <span class="use-tag">×ª×–××•×Ÿ ×¢×•×‘×“×™×</span>
        <span class="use-tag">×œ×•×’×™×¡×˜×™×§×”</span>
        <span class="use-tag">×”×§×¦××ª ××©××‘×™×</span>
        <span class="use-tag">×©×¨×©×¨×ª ××¡×¤×§×”</span>
        <span class="use-tag">×ª×›× ×•×Ÿ ×™×™×¦×•×¨</span>
      </div>
    </div>

    <div class="edu-section">
      <h3>ğŸ“ ×œ××” ×ª×¢×©×™×™×” ×•× ×™×”×•×œ?</h3>
      <p>×”×ª×•××¨ ×‘×”× ×“×¡×ª ×ª×¢×©×™×™×” ×•× ×™×”×•×œ ××œ××“ ×œ×§×‘×œ ×”×—×œ×˜×•×ª ××•×¤×˜×™××œ×™×•×ª ×›×©×”××©××‘×™× ××•×’×‘×œ×™×. ×‘×—×‘×¨×•×ª ×›××• ×•×•×œ×˜, ×’×˜, ×××–×•×Ÿ - ××”× ×“×¡×™ ×ª×¢×•"×  ×‘×•× ×™× ××ª ×”××œ×’×•×¨×™×ª××™× ×©××©×‘×¦×™× ××œ×¤×™ ×©×œ×™×—×™× ×‘×–××Ÿ ×××ª!</p>
    </div>
  </div>

  <!-- Courier Modal -->
  <div id="courierModal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-courier-info">
          <div class="modal-courier-avatar" id="modalAvatar">ğŸï¸</div>
          <div>
            <div class="modal-courier-name" id="modalCourierName">×™×•×¡×™</div>
            <div class="modal-courier-status" id="modalCourierStatus">×‘×—×¨ ×”×–×× ×”</div>
          </div>
        </div>
        <button class="modal-close" onclick="closeModal()">âœ•</button>
      </div>
      <div class="modal-body">
        <div class="modal-section-title">â±ï¸ ×–×× ×™ ×”×’×¢×” ×œ×”×–×× ×•×ª</div>
        <div class="time-matrix" id="timeMatrix"></div>
      </div>
    </div>
  </div>

  <!-- Celebration -->
  <div id="celebration">
    <div class="celeb-card">
      <div class="celeb-icon" id="celebIcon">ğŸ‰</div>
      <h2 class="celeb-title" id="celebTitle">×›×œ ×”×›×‘×•×“!</h2>

      <div class="results-grid">
        <div class="result-box user">
          <div class="result-label">×”×¤×ª×¨×•×Ÿ ×©×œ×š</div>
          <div class="result-value" id="userTimeResult">0 ×“×§'</div>
        </div>
        <div class="result-box optimal">
          <div class="result-label">×”×¤×ª×¨×•×Ÿ ×”××•×¤×˜×™××œ×™</div>
          <div class="result-value" id="optimalTimeResult">0 ×“×§'</div>
        </div>
      </div>

      <div class="time-comparison">
        <h4>â±ï¸ ×”×©×•×•××ª ×–××Ÿ ×”×©×™×‘×•×¥</h4>
        <p id="timeComparisonText">×œ×§×— ×œ×š X ×œ×©×‘×¥. ×”××œ×’×•×¨×™×ª× ×¢×©×” ×–××ª ×‘-Y.</p>
      </div>

      <div class="optimal-list">
        <h4>ğŸ† ×”×©×™×‘×•×¥ ×”××•×¤×˜×™××œ×™:</h4>
        <div id="optimalListContent"></div>
      </div>

      <div class="insight-box">
        <h4>ğŸ’¡ ×œ××” ×–×” ×—×©×•×‘?</h4>
        <p id="insightText">×‘×—×‘×¨×•×ª ××©×œ×•×—×™× ×’×“×•×œ×•×ª ×™×© ××œ×¤×™ ×©×œ×™×—×™×. ×¨×§ ××œ×’×•×¨×™×ª× ×™×›×•×œ ×œ×©×‘×¥ ××•×ª× ×‘×™×¢×™×œ×•×ª!</p>
      </div>

      <button id="playAgainBtn" onclick="resetGame()">ğŸ”„ ×©×—×§ ×©×•×‘</button>
    </div>
  </div>

  <script>
    // ========== CONFIGURATION - BETTER POSITIONS ==========
    const MINUTES_PER_UNIT = 0.18;
    const COURIER_SCALE = 1.5;
    const COURIER_HEIGHT = 0.3;

    const couriers = [
      { id: 1, x: -50, z: -40, color: '#FF6B6B', name: '×™×•×¡×™' },
      { id: 2, x: 50, z: -40, color: '#4ECDC4', name: '××™×›×œ' },
      { id: 3, x: -50, z: 40, color: '#45B7D1', name: '×“× ×™' },
      { id: 4, x: 50, z: 40, color: '#FFA07A', name: '×©×¨×”' }
    ];

    const orders = [
      { id: 1, restX: -18, restZ: -5, custX: 18, custZ: -22, color: '#FFD93D', restaurant: '×¤×™×¦×” ×¨×•××', family: '××©×¤×—×ª ×›×”×Ÿ' },
      { id: 2, restX: 20, restZ: 8, custX: -22, custZ: 20, color: '#6BCF7F', restaurant: '×¡×•×©×™ ×˜×•×§×™×•', family: '××©×¤×—×ª ×œ×•×™' },
      { id: 3, restX: -8, restZ: 25, custX: 30, custZ: 10, color: '#B4A7D6', restaurant: '×‘×•×¨×’×¨ ×”××•×¡', family: '××©×¤×—×ª ××‘×¨×”×' },
      { id: 4, restX: 5, restZ: -25, custX: -28, custZ: -8, color: '#FF9FF3', restaurant: '×¤×œ××¤×œ ×”×–×”×‘', family: '××©×¤×—×ª ×“×•×“' }
    ];

    // ========== GAME STATE ==========
    let gameState = {
      started: false,
      assignments: {},
      selectedCourier: null,
      startTime: null,
      isComplete: false,
      isAnimating: false
    };

    let scene, engine, canvas, advancedTexture;
    let courierMeshes = [];
    let assignmentLines = {};

    // ========== UTILITY FUNCTIONS ==========
    function getDistance(c, o) {
      const toRest = Math.sqrt(Math.pow(o.restX - c.x, 2) + Math.pow(o.restZ - c.z, 2));
      const toCust = Math.sqrt(Math.pow(o.custX - o.restX, 2) + Math.pow(o.custZ - o.restZ, 2));
      return toRest + toCust;
    }

    function getTimeMinutes(courier, order) {
      const dist = getDistance(courier, order);
      return Math.round(dist * MINUTES_PER_UNIT * 10) / 10;
    }

    function getTotalTime() {
      let total = 0;
      Object.entries(gameState.assignments).forEach(([cId, oId]) => {
        const c = couriers.find(x => x.id === parseInt(cId));
        const o = orders.find(x => x.id === oId);
        if (c && o) total += getTimeMinutes(c, o);
      });
      return Math.round(total * 10) / 10;
    }

    function formatMinutes(mins) {
      return mins + " ×“×§'";
    }

    // ========== HUNGARIAN ALGORITHM ==========
    function hungarianAlgorithm(cost) {
      const n = cost.length;
      const u = new Array(n + 1).fill(0);
      const v = new Array(n + 1).fill(0);
      const p = new Array(n + 1).fill(0);
      const way = new Array(n + 1).fill(0);

      for (let i = 1; i <= n; i++) {
        p[0] = i;
        let j0 = 0;
        const minv = new Array(n + 1).fill(Infinity);
        const used = new Array(n + 1).fill(false);

        do {
          used[j0] = true;
          const i0 = p[j0];
          let delta = Infinity, j1;

          for (let j = 1; j <= n; j++) {
            if (!used[j]) {
              const cur = cost[i0 - 1][j - 1] - u[i0] - v[j];
              if (cur < minv[j]) { minv[j] = cur; way[j] = j0; }
              if (minv[j] < delta) { delta = minv[j]; j1 = j; }
            }
          }

          for (let j = 0; j <= n; j++) {
            if (used[j]) { u[p[j]] += delta; v[j] -= delta; }
            else { minv[j] -= delta; }
          }
          j0 = j1;
        } while (p[j0] !== 0);

        do { const j1 = way[j0]; p[j0] = p[j1]; j0 = j1; } while (j0);
      }

      const result = [];
      for (let j = 1; j <= n; j++) if (p[j] !== 0) result[p[j] - 1] = j - 1;
      return result;
    }

    function getOptimalSolution() {
      const cost = couriers.map(c => orders.map(o => getTimeMinutes(c, o)));
      const assignment = hungarianAlgorithm(cost);
      let total = 0;
      const opt = {};
      assignment.forEach((oIdx, cIdx) => {
        opt[couriers[cIdx].id] = orders[oIdx].id;
        total += cost[cIdx][oIdx];
      });
      return { assignments: opt, total: Math.round(total * 10) / 10 };
    }

    // ========== UI FUNCTIONS ==========
    function updateHUD() {
      const count = Object.keys(gameState.assignments).length;
      document.getElementById('assignedVal').textContent = count + '/4';
      document.getElementById('totalTimeVal').textContent = getTotalTime();

      const checkBtn = document.getElementById('checkBtn');
      if (count === 4) {
        checkBtn.classList.add('active');
      } else {
        checkBtn.classList.remove('active');
      }
    }

    function openPanel(panel) {
      closeAllPanels();
      panel.classList.add('open');
      document.getElementById('overlay').classList.add('visible');
    }

    function closeAllPanels() {
      document.getElementById('sidePanel').classList.remove('open');
      document.getElementById('infoPanel').classList.remove('open');
      document.getElementById('overlay').classList.remove('visible');
    }

    function openModal(courierId) {
      const courier = couriers.find(c => c.id === courierId);
      if (!courier) return;

      gameState.selectedCourier = courierId;
      if (!gameState.startTime) gameState.startTime = Date.now();

      document.getElementById('modalAvatar').style.background = courier.color;
      document.getElementById('modalCourierName').textContent = courier.name;

      const assigned = gameState.assignments[courierId];
      document.getElementById('modalCourierStatus').textContent = assigned
        ? '××©×•×‘×¥ ×œ' + orders.find(o => o.id === assigned).family
        : '×‘×—×¨ ×”×–×× ×” ×œ×©×œ×™×—×•×ª';

      const matrix = document.getElementById('timeMatrix');
      matrix.innerHTML = orders.map(o => {
        const time = getTimeMinutes(courier, o);
        const assignedTo = Object.entries(gameState.assignments).find(([_, oId]) => oId === o.id);
        const isThis = assignedTo && parseInt(assignedTo[0]) === courierId;
        const isOther = assignedTo && parseInt(assignedTo[0]) !== courierId;
        const otherCourier = isOther ? couriers.find(c => c.id === parseInt(assignedTo[0])) : null;

        let cls = 'matrix-row';
        if (isThis) cls += ' assigned';
        if (isOther) cls += ' assigned-other';

        return `
          <div class="${cls}" onclick="${!isOther ? `assignOrder(${o.id})` : ''}">
            <div class="matrix-row-info">
              <div class="matrix-family-dot" style="background:${o.color}"></div>
              <div>
                <div class="matrix-family-name">${o.family}</div>
                <div class="matrix-restaurant">×“×¨×š ${o.restaurant}</div>
              </div>
            </div>
            <div class="matrix-time">
              <span class="matrix-time-value">${time} ×“×§'</span>
              <button class="matrix-select-btn">${isThis ? 'âœ“' : '×‘×—×¨'}</button>
              <span class="assigned-badge">${isOther ? otherCourier.name : ''}</span>
            </div>
          </div>
        `;
      }).join('');

      document.getElementById('courierModal').classList.add('visible');
    }

    function closeModal() {
      document.getElementById('courierModal').classList.remove('visible');
      gameState.selectedCourier = null;
    }

    function assignOrder(orderId) {
      if (!gameState.selectedCourier) return;

      Object.keys(gameState.assignments).forEach(cId => {
        if (gameState.assignments[cId] === orderId) delete gameState.assignments[cId];
      });

      gameState.assignments[gameState.selectedCourier] = orderId;
      updateHUD();
      updateVisuals();
      closeModal();
    }

    function updateVisuals() {
      courierMeshes.forEach(mesh => {
        const isAssigned = gameState.assignments[mesh.courierId] !== undefined;
        if (mesh.ringMat) {
          mesh.ringMat.alpha = isAssigned ? 0.7 : 0;
          mesh.ringMat.emissiveColor = BABYLON.Color3.FromHexString(isAssigned ? '#4CAF50' : '#FFD700');
        }
      });

      Object.values(assignmentLines).forEach(l => l.dispose());
      assignmentLines = {};

      Object.entries(gameState.assignments).forEach(([cId, oId]) => {
        const courier = couriers.find(c => c.id === parseInt(cId));
        const order = orders.find(o => o.id === oId);
        const mesh = courierMeshes.find(m => m.courierId === parseInt(cId));

        if (courier && order && mesh) {
          const points = [
            new BABYLON.Vector3(mesh.position.x, 2, mesh.position.z),
            new BABYLON.Vector3(order.restX, 2, order.restZ),
            new BABYLON.Vector3(order.custX, 2, order.custZ)
          ];

          const tube = BABYLON.MeshBuilder.CreateTube("line_" + cId, {
            path: points, radius: 0.35, tessellation: 12, cap: BABYLON.Mesh.CAP_ALL
          }, scene);

          const mat = new BABYLON.StandardMaterial("tubeMat_" + cId, scene);
          mat.diffuseColor = BABYLON.Color3.FromHexString(courier.color);
          mat.emissiveColor = BABYLON.Color3.FromHexString(courier.color).scale(0.5);
          mat.alpha = 0.85;
          tube.material = mat;

          assignmentLines[cId] = tube;
        }
      });
    }

    // ========== HINT SYSTEM ==========
    function showHint() {
      const optimal = getOptimalSolution();
      const current = gameState.assignments;

      let hint = '';
      for (const [cId, oId] of Object.entries(current)) {
        if (optimal.assignments[cId] !== oId) {
          const courier = couriers.find(c => c.id === parseInt(cId));
          const correctOrder = orders.find(o => o.id === optimal.assignments[cId]);
          hint = `ğŸ’¡ × ×¡×” ×œ×©×‘×¥ ××ª ${courier.name} ×œ${correctOrder.family}`;
          break;
        }
      }

      if (!hint && Object.keys(current).length < 4) {
        const unassigned = couriers.find(c => !current[c.id]);
        if (unassigned) {
          const correctOrder = orders.find(o => o.id === optimal.assignments[unassigned.id]);
          hint = `ğŸ’¡ × ×¡×” ×œ×©×‘×¥ ××ª ${unassigned.name} ×œ${correctOrder.family}`;
        }
      }

      if (!hint) hint = 'ğŸ‰ ××¦×•×™×Ÿ! × ×¨××” ×©××ª×” ×¢×œ ×”×“×¨×š ×”× ×›×•× ×”!';
      alert(hint);
    }

    // ========== COURIER ANIMATION ==========
    async function animateCouriersDelivery() {
      gameState.isAnimating = true;
      
      Object.values(assignmentLines).forEach(l => l.dispose());
      assignmentLines = {};

      const animations = [];
      
      Object.entries(gameState.assignments).forEach(([cId, oId]) => {
        const mesh = courierMeshes.find(m => m.courierId === parseInt(cId));
        const order = orders.find(o => o.id === oId);
        if (mesh && order) {
          animations.push(animateSingleCourier(mesh, order));
        }
      });

      await Promise.all(animations);
      gameState.isAnimating = false;
    }

    function animateSingleCourier(mesh, order) {
      return new Promise(resolve => {
        const path = [
          { x: mesh.originalX, z: mesh.originalZ },
          { x: order.restX, z: order.restZ },
          { x: order.custX, z: order.custZ }
        ];

        let segmentIndex = 0;

        function animateSegment() {
          if (segmentIndex >= path.length - 1) {
            resolve();
            return;
          }

          const start = path[segmentIndex];
          const end = path[segmentIndex + 1];
          const dx = end.x - start.x;
          const dz = end.z - start.z;
          const distance = Math.sqrt(dx * dx + dz * dz);
          const duration = distance * 25;

          mesh.rotation.y = Math.atan2(dx, dz);

          gsap.to(mesh.position, {
            x: end.x,
            z: end.z,
            duration: duration / 1000,
            ease: "power2.inOut",
            onComplete: () => {
              segmentIndex++;
              setTimeout(animateSegment, 150);
            }
          });
        }

        animateSegment();
      });
    }

    // ========== CHECK & CELEBRATE ==========
    async function checkSolution() {
      if (Object.keys(gameState.assignments).length !== 4 || gameState.isAnimating) return;

      await animateCouriersDelivery();

      gameState.isComplete = true;
      const userTime = getTotalTime();
      const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
      
      const t0 = performance.now();
      const optimal = getOptimalSolution();
      const t1 = performance.now();
      const algoTime = (t1 - t0).toFixed(2);

      const diff = userTime - optimal.total;
      const diffPercent = ((diff / optimal.total) * 100).toFixed(1);

      let icon, title;
      if (diff <= 0) {
        icon = 'ğŸ†';
        title = '××•×©×œ×!';
      } else if (diff < 3) {
        icon = 'ğŸ‰';
        title = '×›××¢×˜ ××•×©×œ×!';
      } else {
        icon = 'ğŸ’ª';
        title = '×¡×™×™××ª!';
      }

      document.getElementById('celebIcon').textContent = icon;
      document.getElementById('celebTitle').textContent = title;
      document.getElementById('userTimeResult').textContent = formatMinutes(userTime);
      document.getElementById('optimalTimeResult').textContent = formatMinutes(optimal.total);

      const elapsedMin = Math.floor(elapsed / 60);
      const elapsedSec = elapsed % 60;
      const elapsedStr = elapsedMin > 0 ? `${elapsedMin} ×“×§×•×ª ×•-${elapsedSec} ×©× ×™×•×ª` : `${elapsedSec} ×©× ×™×•×ª`;
      
      document.getElementById('timeComparisonText').innerHTML = `
        ×œ×§×— ×œ×š <strong>${elapsedStr}</strong> ×œ×©×‘×¥ 4 ×©×œ×™×—×™×.<br>
        ×”××œ×’×•×¨×™×ª× ×”×”×•× ×’×¨×™ ×¢×©×” ×–××ª ×‘-<strong>${algoTime} ××œ×¤×™×•×ª ×”×©× ×™×™×”</strong>.<br><br>
        ${diff > 0 ? `×”×¤×ª×¨×•×Ÿ ×©×œ×š ××¨×•×š ×‘-<strong>${formatMinutes(diff)}</strong> (${diffPercent}%) ××”××•×¤×˜×™××œ×™.` : '××¦××ª ××ª ×”×¤×ª×¨×•×Ÿ ×”××•×¤×˜×™××œ×™ ×‘×“×™×•×§!'}
      `;

      document.getElementById('optimalListContent').innerHTML = Object.entries(optimal.assignments).map(([cId, oId]) => {
        const c = couriers.find(x => x.id === parseInt(cId));
        const o = orders.find(x => x.id === oId);
        const t = getTimeMinutes(c, o);
        return `<div class="optimal-item"><span style="color:${c.color}">â—</span> ${c.name} â†’ ${o.family} (${t} ×“×§')</div>`;
      }).join('');

      document.getElementById('insightText').innerHTML = `
        ×‘××©×—×§ ×–×” ×©×™×‘×¦×ª ×¨×§ 4 ×©×œ×™×—×™× ×•×–×” ×œ×§×— ×œ×š ${elapsedStr}.<br><br>
        ×‘×—×‘×¨×•×ª ×›××• <strong>×•×•×œ×˜</strong> ×™×© ××œ×¤×™ ×©×œ×™×—×™× ×•×”×–×× ×•×ª ×‘×•-×–×× ×™×ª - ××“× ×œ× ×™×›×•×œ ×œ×©×‘×¥ ×™×“× ×™×ª!<br><br>
        ×›××Ÿ × ×›× ×¡ <strong>××”× ×“×¡ ×”×ª×¢×©×™×™×” ×•×”× ×™×”×•×œ</strong> - ×œ×‘× ×•×ª ××œ×’×•×¨×™×ª××™× ×©×¢×•×©×™× ××ª ×–×” ×‘-××œ×¤×™×•×ª ×”×©× ×™×™×”.
      `;

      document.getElementById('celebration').classList.add('visible');
    }

    function resetGame() {
      gameState = {
        started: true,
        assignments: {},
        selectedCourier: null,
        startTime: null,
        isComplete: false,
        isAnimating: false
      };

      updateHUD();
      document.getElementById('celebration').classList.remove('visible');

      courierMeshes.forEach(mesh => {
        mesh.position.x = mesh.originalX;
        mesh.position.z = mesh.originalZ;
        mesh.rotation.y = 0;
        if (mesh.ringMat) mesh.ringMat.alpha = 0;
      });

      Object.values(assignmentLines).forEach(l => l.dispose());
      assignmentLines = {};
    }

    // ========== GAME START ==========
    function startGame() {
      document.getElementById('splashScreen').classList.add('hidden');
      document.getElementById('topBar').classList.add('visible');
      gameState.started = true;
      
      const elem = document.documentElement;
      if (elem.requestFullscreen) elem.requestFullscreen().catch(() => {});
      else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
      
      if (engine) engine.resize();
    }

    // ========== EVENT LISTENERS ==========
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('helpBtn').addEventListener('click', () => openPanel(document.getElementById('sidePanel')));
    document.getElementById('infoBtn').addEventListener('click', () => openPanel(document.getElementById('infoPanel')));
    document.getElementById('hintBtn').addEventListener('click', showHint);
    document.getElementById('resetBtn').addEventListener('click', resetGame);
    document.getElementById('checkBtn').addEventListener('click', checkSolution);
    document.getElementById('overlay').addEventListener('click', closeAllPanels);

    // ========== BABYLON.JS SCENE ==========
    function createScene() {
      canvas = document.getElementById('renderCanvas');
      engine = new BABYLON.Engine(canvas, true, { antialias: true, stencil: true });
      engine.setHardwareScalingLevel(1 / Math.min(window.devicePixelRatio || 1, 2));
      scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0.91, 0.94, 0.97, 1);

      advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('UI');

      // Camera
      const isMobile = window.innerWidth < 900;
      const camRadius = isMobile ? 115 : 105;
      const camBeta = isMobile ? Math.PI / 3 : Math.PI / 3.2;

      const camera = new BABYLON.ArcRotateCamera('cam', -Math.PI / 2, camBeta, camRadius, BABYLON.Vector3.Zero(), scene);
      camera.attachControl(canvas, false);
      camera.inputs.clear();
      camera.lowerRadiusLimit = camRadius;
      camera.upperRadiusLimit = camRadius;

      // Lighting
      const hemi = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0, 1, 0), scene);
      hemi.intensity = 0.75;
      hemi.groundColor = new BABYLON.Color3(0.85, 0.88, 0.95);

      const sun = new BABYLON.DirectionalLight('sun', new BABYLON.Vector3(-0.5, -1, 0.3), scene);
      sun.position = new BABYLON.Vector3(50, 70, -50);
      sun.intensity = 0.95;

      const shadowGen = new BABYLON.ShadowGenerator(2048, sun);
      shadowGen.useBlurExponentialShadowMap = true;
      shadowGen.blurKernel = 32;
      shadowGen.darkness = 0.15;

      // Ground
      const ground = BABYLON.MeshBuilder.CreateGround('ground', { width: 160, height: 160 }, scene);
      const groundMat = new BABYLON.StandardMaterial('groundMat', scene);
      groundMat.diffuseColor = new BABYLON.Color3(0.9, 0.92, 0.94);
      ground.material = groundMat;
      ground.receiveShadows = true;

      // Roads
      createRoads(scene);
      
      // Environment - Trees and Street Lights
      createEnvironment(scene, shadowGen);

      // Create entities
      couriers.forEach(c => courierMeshes.push(createCourier(scene, c, shadowGen)));
      orders.forEach(o => { createRestaurant(scene, o, shadowGen); createHouse(scene, o, shadowGen); });

      // Click handler
      scene.onPointerDown = (evt, pick) => {
        if (!gameState.started || gameState.isComplete || gameState.isAnimating) return;
        if (pick.hit) {
          let p = pick.pickedMesh;
          while (p && !p.courierId) p = p.parent;
          if (p?.courierId) openModal(p.courierId);
        }
      };

      return scene;
    }

    function createRoads(scene) {
      const roadMat = new BABYLON.StandardMaterial('roadMat', scene);
      roadMat.diffuseColor = new BABYLON.Color3(0.38, 0.4, 0.45);

      const lineMat = new BABYLON.StandardMaterial('lineMat', scene);
      lineMat.diffuseColor = new BABYLON.Color3(1, 0.95, 0.4);
      lineMat.emissiveColor = new BABYLON.Color3(0.15, 0.14, 0.05);

      for (let i = -40; i <= 40; i += 20) {
        const rH = BABYLON.MeshBuilder.CreateBox('rH' + i, { width: 160, height: 0.05, depth: 12 }, scene);
        rH.position.set(0, 0.025, i);
        rH.material = roadMat;

        const rV = BABYLON.MeshBuilder.CreateBox('rV' + i, { width: 12, height: 0.05, depth: 160 }, scene);
        rV.position.set(i, 0.025, 0);
        rV.material = roadMat;

        for (let j = -75; j <= 75; j += 6) {
          const lH = BABYLON.MeshBuilder.CreateBox('lH', { width: 3.5, height: 0.06, depth: 0.25 }, scene);
          lH.position.set(j, 0.06, i);
          lH.material = lineMat;

          const lV = BABYLON.MeshBuilder.CreateBox('lV', { width: 0.25, height: 0.06, depth: 3.5 }, scene);
          lV.position.set(i, 0.06, j);
          lV.material = lineMat;
        }
      }
    }

    function createEnvironment(scene, shadowGen) {
      const treePositions = [
        [-65, -55], [65, -55], [-65, 55], [65, 55],
        [-70, 0], [70, 0], [0, -65], [0, 65],
        [-70, -30], [70, 30], [-30, 70], [30, -70],
        [-70, 30], [70, -30], [30, 70], [-30, -70]
      ];
      treePositions.forEach(pos => createTree(scene, pos[0], pos[1], shadowGen));

      for (let x = -30; x <= 30; x += 20) {
        for (let z = -30; z <= 30; z += 20) {
          createStreetLight(scene, x + 7, z + 7);
        }
      }
    }

    function createTree(scene, x, z, shadowGen) {
      const trunk = BABYLON.MeshBuilder.CreateCylinder('trunk', { height: 3.5, diameter: 0.9 }, scene);
      trunk.position.set(x, 1.75, z);
      const trunkMat = new BABYLON.StandardMaterial('trunkMat', scene);
      trunkMat.diffuseColor = new BABYLON.Color3(0.5, 0.35, 0.18);
      trunk.material = trunkMat;
      shadowGen.addShadowCaster(trunk);

      const leaves = BABYLON.MeshBuilder.CreateSphere('leaves', { diameter: 6, segments: 8 }, scene);
      leaves.position.set(x, 5.5, z);
      leaves.scaling.y = 1.2;
      const leavesMat = new BABYLON.StandardMaterial('leavesMat', scene);
      leavesMat.diffuseColor = new BABYLON.Color3(0.35, 0.72, 0.38);
      leaves.material = leavesMat;
      shadowGen.addShadowCaster(leaves);
    }

    function createStreetLight(scene, x, z) {
      const poleMat = new BABYLON.StandardMaterial('poleMat', scene);
      poleMat.diffuseColor = new BABYLON.Color3(0.28, 0.28, 0.32);

      const pole = BABYLON.MeshBuilder.CreateCylinder('pole', { height: 9, diameter: 0.4 }, scene);
      pole.position.set(x, 4.5, z);
      pole.material = poleMat;

      const arm = BABYLON.MeshBuilder.CreateBox('arm', { width: 3, height: 0.25, depth: 0.25 }, scene);
      arm.position.set(x + 1.5, 9, z);
      arm.material = poleMat;

      const bulb = BABYLON.MeshBuilder.CreateSphere('bulb', { diameter: 0.7 }, scene);
      bulb.position.set(x + 3, 8.7, z);
      const bulbMat = new BABYLON.StandardMaterial('bulbMat', scene);
      bulbMat.emissiveColor = new BABYLON.Color3(1, 0.95, 0.75);
      bulb.material = bulbMat;

      const light = new BABYLON.PointLight('streetLight', new BABYLON.Vector3(x + 3, 8.5, z), scene);
      light.intensity = 0.35;
      light.range = 20;
    }

    function createCourier(scene, c, shadowGen) {
      const S = COURIER_SCALE;
      const H = COURIER_HEIGHT;
      
      const parent = new BABYLON.TransformNode('courier_' + c.id, scene);
      parent.position.set(c.x, H, c.z);
      parent.courierId = c.id;
      parent.originalX = c.x;
      parent.originalZ = c.z;

      const color = BABYLON.Color3.FromHexString(c.color);
      const bodyMat = new BABYLON.StandardMaterial('bodyMat' + c.id, scene);
      bodyMat.diffuseColor = color;
      bodyMat.specularPower = 64;

      const body = BABYLON.MeshBuilder.CreateBox('body', { width: 1.1 * S, height: 0.65 * S, depth: 2.8 * S }, scene);
      body.position.y = 0.85 * S;
      body.parent = parent;
      body.material = bodyMat;
      shadowGen.addShadowCaster(body);

      const tank = BABYLON.MeshBuilder.CreateCylinder('tank', { diameter: 0.75 * S, height: 1.3 * S }, scene);
      tank.rotation.x = Math.PI / 2;
      tank.position.set(0, 1.05 * S, 0.45 * S);
      tank.parent = parent;
      tank.material = bodyMat;
      shadowGen.addShadowCaster(tank);

      const seatMat = new BABYLON.StandardMaterial('seatMat', scene);
      seatMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);

      const seat = BABYLON.MeshBuilder.CreateBox('seat', { width: 0.75 * S, height: 0.28 * S, depth: 1.1 * S }, scene);
      seat.position.set(0, 1.28 * S, -0.35 * S);
      seat.parent = parent;
      seat.material = seatMat;
      shadowGen.addShadowCaster(seat);

      const wheelMat = new BABYLON.StandardMaterial('wheelMat', scene);
      wheelMat.diffuseColor = new BABYLON.Color3(0.08, 0.08, 0.08);

      const chromeMat = new BABYLON.StandardMaterial('chromeMat', scene);
      chromeMat.diffuseColor = new BABYLON.Color3(0.82, 0.82, 0.88);
      chromeMat.specularPower = 128;

      const fWheel = BABYLON.MeshBuilder.CreateTorus('fw', { diameter: 1.1 * S, thickness: 0.32 * S, tessellation: 32 }, scene);
      fWheel.rotation.z = Math.PI / 2;
      fWheel.position.set(0, 0.55 * S, 1.2 * S);
      fWheel.parent = parent;
      fWheel.material = wheelMat;
      shadowGen.addShadowCaster(fWheel);

      const fRim = BABYLON.MeshBuilder.CreateCylinder('frim', { diameter: 0.55 * S, height: 0.28 * S }, scene);
      fRim.rotation.x = Math.PI / 2;
      fRim.position.set(0, 0.55 * S, 1.2 * S);
      fRim.parent = parent;
      fRim.material = chromeMat;

      const bWheel = BABYLON.MeshBuilder.CreateTorus('bw', { diameter: 1.1 * S, thickness: 0.32 * S, tessellation: 32 }, scene);
      bWheel.rotation.z = Math.PI / 2;
      bWheel.position.set(0, 0.55 * S, -1 * S);
      bWheel.parent = parent;
      bWheel.material = wheelMat;
      shadowGen.addShadowCaster(bWheel);

      const bRim = BABYLON.MeshBuilder.CreateCylinder('brim', { diameter: 0.55 * S, height: 0.28 * S }, scene);
      bRim.rotation.x = Math.PI / 2;
      bRim.position.set(0, 0.55 * S, -1 * S);
      bRim.parent = parent;
      bRim.material = chromeMat;

      const handlebar = BABYLON.MeshBuilder.CreateCylinder('hbar', { diameter: 0.09 * S, height: 1.4 * S }, scene);
      handlebar.rotation.z = Math.PI / 2;
      handlebar.position.set(0, 1.55 * S, 1.1 * S);
      handlebar.parent = parent;
      handlebar.material = chromeMat;

      const headlight = BABYLON.MeshBuilder.CreateSphere('hl', { diameter: 0.35 * S }, scene);
      headlight.position.set(0, 1.15 * S, 1.45 * S);
      headlight.parent = parent;
      const hlMat = new BABYLON.StandardMaterial('hlMat', scene);
      hlMat.emissiveColor = new BABYLON.Color3(1, 1, 0.8);
      headlight.material = hlMat;

      const taillight = BABYLON.MeshBuilder.CreateBox('tl', { width: 0.55 * S, height: 0.18 * S, depth: 0.12 * S }, scene);
      taillight.position.set(0, 0.95 * S, -1.45 * S);
      taillight.parent = parent;
      const tlMat = new BABYLON.StandardMaterial('tlMat', scene);
      tlMat.emissiveColor = new BABYLON.Color3(1, 0.1, 0.1);
      taillight.material = tlMat;

      const boxMat = new BABYLON.StandardMaterial('boxMat', scene);
      boxMat.diffuseColor = new BABYLON.Color3(0.98, 0.98, 0.98);

      const deliveryBox = BABYLON.MeshBuilder.CreateBox('dbox', { width: 1.5 * S, height: 1.2 * S, depth: 1.5 * S }, scene);
      deliveryBox.position.set(0, 1.75 * S, -0.95 * S);
      deliveryBox.parent = parent;
      deliveryBox.material = boxMat;
      shadowGen.addShadowCaster(deliveryBox);

      // Selection ring
      const ring = BABYLON.MeshBuilder.CreateTorus('ring', { diameter: 5 * S, thickness: 0.25, tessellation: 64 }, scene);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = 0.15;
      ring.parent = parent;
      const ringMat = new BABYLON.StandardMaterial('ringMat' + c.id, scene);
      ringMat.emissiveColor = color;
      ringMat.alpha = 0;
      ring.material = ringMat;
      parent.ringMat = ringMat;

      // Label
      const isMob = window.innerWidth < 900;
      const rect = new BABYLON.GUI.Rectangle();
      rect.width = isMob ? '80px' : '90px';
      rect.height = isMob ? '28px' : '32px';
      rect.cornerRadius = 16;
      rect.thickness = 0;
      rect.background = c.color;
      advancedTexture.addControl(rect);
      rect.linkWithMesh(parent);
      rect.linkOffsetY = isMob ? -70 : -90;

      const txt = new BABYLON.GUI.TextBlock();
      txt.text = c.name;
      txt.color = 'white';
      txt.fontSize = isMob ? 14 : 16;
      txt.fontWeight = 'bold';
      txt.fontFamily = 'Heebo';
      rect.addControl(txt);

      // Idle animation
      let t = Math.random() * Math.PI * 2;
      scene.registerBeforeRender(() => {
        if (!gameState.isComplete && !gameState.isAnimating) {
          t += 0.04;
          parent.position.y = H + Math.sin(t * 2) * 0.08;
        }
        fWheel.rotation.x += 0.03;
        bWheel.rotation.x += 0.03;
      });

      return parent;
    }

    function createRestaurant(scene, o, shadowGen) {
      const parent = new BABYLON.TransformNode('rest_' + o.id, scene);
      parent.position.set(o.restX, 0, o.restZ);

      const color = BABYLON.Color3.FromHexString(o.color);
      const mat = new BABYLON.StandardMaterial('restMat' + o.id, scene);
      mat.diffuseColor = color.scale(0.88);

      const base = BABYLON.MeshBuilder.CreateBox('base', { width: 5.5, height: 6.5, depth: 5.5 }, scene);
      base.position.y = 3.25;
      base.parent = parent;
      base.material = mat;
      shadowGen.addShadowCaster(base);

      const roofMat = new BABYLON.StandardMaterial('roofMat', scene);
      roofMat.diffuseColor = new BABYLON.Color3(0.68, 0.22, 0.22);

      const roof = BABYLON.MeshBuilder.CreateCylinder('roof', { diameterTop: 0, diameterBottom: 7.5, height: 3.2, tessellation: 4 }, scene);
      roof.position.y = 8;
      roof.rotation.y = Math.PI / 4;
      roof.parent = parent;
      roof.material = roofMat;
      shadowGen.addShadowCaster(roof);

      const doorMat = new BABYLON.StandardMaterial('doorMat', scene);
      doorMat.diffuseColor = new BABYLON.Color3(0.48, 0.3, 0.14);

      const door = BABYLON.MeshBuilder.CreateBox('door', { width: 1.5, height: 3, depth: 0.15 }, scene);
      door.position.set(0, 1.5, 2.8);
      door.parent = parent;
      door.material = doorMat;

      const windowMat = new BABYLON.StandardMaterial('winMat', scene);
      windowMat.diffuseColor = new BABYLON.Color3(0.72, 0.88, 1);
      windowMat.emissiveColor = new BABYLON.Color3(0.32, 0.42, 0.52);

      for (let i = -1; i <= 1; i += 2) {
        const win = BABYLON.MeshBuilder.CreateBox('win', { width: 1.1, height: 1.3, depth: 0.12 }, scene);
        win.position.set(i * 1.6, 4.2, 2.8);
        win.parent = parent;
        win.material = windowMat;
      }

      const signMat = new BABYLON.StandardMaterial('signMat', scene);
      signMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
      signMat.emissiveColor = color.scale(0.5);

      const sign = BABYLON.MeshBuilder.CreateBox('sign', { width: 4, height: 1.1, depth: 0.28 }, scene);
      sign.position.set(0, 5.6, 2.95);
      sign.parent = parent;
      sign.material = signMat;

      // Label
      const isMob = window.innerWidth < 900;
      const rect = new BABYLON.GUI.Rectangle();
      rect.width = isMob ? '100px' : '120px';
      rect.height = isMob ? '24px' : '28px';
      rect.cornerRadius = 14;
      rect.thickness = 2;
      rect.color = 'white';
      rect.background = o.color;
      advancedTexture.addControl(rect);
      rect.linkWithMesh(parent);
      rect.linkOffsetY = isMob ? -85 : -120;

      const txt = new BABYLON.GUI.TextBlock();
      txt.text = 'ğŸ• ' + o.restaurant;
      txt.color = 'white';
      txt.fontSize = isMob ? 10 : 11;
      txt.fontWeight = 'bold';
      txt.fontFamily = 'Heebo';
      rect.addControl(txt);

      // Floating icon
      const iconMat = new BABYLON.StandardMaterial('iconMat', scene);
      iconMat.diffuseColor = color;
      iconMat.emissiveColor = color.scale(0.6);

      const icon = BABYLON.MeshBuilder.CreateSphere('icon', { diameter: 2 }, scene);
      icon.position.y = 12;
      icon.parent = parent;
      icon.material = iconMat;

      let time = Math.random() * Math.PI * 2;
      scene.registerBeforeRender(() => {
        time += 0.025;
        icon.position.y = 12 + Math.sin(time) * 0.45;
        icon.rotation.y += 0.015;
      });

      return parent;
    }

    function createHouse(scene, o, shadowGen) {
      const parent = new BABYLON.TransformNode('house_' + o.id, scene);
      parent.position.set(o.custX, 0, o.custZ);

      const baseMat = new BABYLON.StandardMaterial('houseMat', scene);
      baseMat.diffuseColor = new BABYLON.Color3(0.94, 0.9, 0.85);

      const base = BABYLON.MeshBuilder.CreateBox('hbase', { width: 5, height: 5, depth: 5 }, scene);
      base.position.y = 2.5;
      base.parent = parent;
      base.material = baseMat;
      shadowGen.addShadowCaster(base);

      const roofMat = new BABYLON.StandardMaterial('hroofMat', scene);
      roofMat.diffuseColor = new BABYLON.Color3(0.58, 0.38, 0.25);

      const roof = BABYLON.MeshBuilder.CreateCylinder('hroof', { diameterTop: 0, diameterBottom: 7, height: 2.8, tessellation: 4 }, scene);
      roof.position.y = 6.2;
      roof.rotation.y = Math.PI / 4;
      roof.parent = parent;
      roof.material = roofMat;
      shadowGen.addShadowCaster(roof);

      const color = BABYLON.Color3.FromHexString(o.color);
      const doorMat = new BABYLON.StandardMaterial('hdoorMat', scene);
      doorMat.diffuseColor = color.scale(0.75);

      const door = BABYLON.MeshBuilder.CreateBox('hdoor', { width: 1.3, height: 2.4, depth: 0.12 }, scene);
      door.position.set(0, 1.2, 2.55);
      door.parent = parent;
      door.material = doorMat;

      const windowMat = new BABYLON.StandardMaterial('hwinMat', scene);
      windowMat.diffuseColor = new BABYLON.Color3(0.62, 0.78, 0.98);
      windowMat.emissiveColor = new BABYLON.Color3(0.28, 0.38, 0.48);

      for (let i = -1; i <= 1; i += 2) {
        const win = BABYLON.MeshBuilder.CreateBox('hwin', { width: 0.85, height: 0.85, depth: 0.12 }, scene);
        win.position.set(i * 1.3, 3.5, 2.55);
        win.parent = parent;
        win.material = windowMat;
      }

      // Label
      const isMob = window.innerWidth < 900;
      const rect = new BABYLON.GUI.Rectangle();
      rect.width = isMob ? '95px' : '110px';
      rect.height = isMob ? '24px' : '28px';
      rect.cornerRadius = 14;
      rect.thickness = 2;
      rect.color = o.color;
      rect.background = 'white';
      advancedTexture.addControl(rect);
      rect.linkWithMesh(parent);
      rect.linkOffsetY = isMob ? -70 : -100;

      const txt = new BABYLON.GUI.TextBlock();
      txt.text = 'ğŸ  ' + o.family;
      txt.color = '#333';
      txt.fontSize = isMob ? 10 : 11;
      txt.fontWeight = 'bold';
      txt.fontFamily = 'Heebo';
      rect.addControl(txt);

      // Floating marker
      const markerMat = new BABYLON.StandardMaterial('markerMat', scene);
      markerMat.diffuseColor = color;
      markerMat.emissiveColor = color.scale(0.45);

      const marker = BABYLON.MeshBuilder.CreateCylinder('marker', { diameterTop: 0.45, diameterBottom: 1.6, height: 2.8 }, scene);
      marker.position.y = 10;
      marker.parent = parent;
      marker.material = markerMat;

      let time = Math.random() * Math.PI * 2;
      scene.registerBeforeRender(() => {
        time += 0.03;
        marker.position.y = 10 + Math.sin(time) * 0.38;
      });

      return parent;
    }

    // ========== INIT ==========
    createScene();
    engine.runRenderLoop(() => scene.render());
    window.addEventListener('resize', () => engine.resize());
    window.addEventListener('orientationchange', () => setTimeout(() => engine.resize(), 300));
  </script>
  </script>
</body>
</html>