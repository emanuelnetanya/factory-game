<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <title>××©×—×§ ×ª×¨××™×œ ×”×’×‘ â€“ ××¨×’×– ×¦×™×•×“ ×ª×¢×©×™×™×ª×™ PRO</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- BabylonJS + GUI -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: "Heebo", Arial, sans-serif;
    }

    /* ×›×“×™ ×œ×¢×–×•×¨ ×‘××¡×š ××œ× ×‘××•×‘×™×™×œ */
    body {
      background: radial-gradient(circle at 20% 0%, #ffffff 0%, #e3f2fd 35%, #bbdefb 70%, #90caf9 100%);
      -webkit-tap-highlight-color: transparent;
      min-height: 100dvh;
    }

    #renderCanvas {
      width: 100%;
      height: 100%;
      display: block;
      outline: none;
    }

    /* HUD ×¢×œ×™×•×Ÿ */
    #hud {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      top: 18px; /* ×§×¦×ª ×™×•×ª×¨ ×¨×—×•×§ ××œ××¢×œ×” */
      width: 92%;
      max-width: 960px;
      background: rgba(255,255,255,0.98);
      border-radius: 18px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.18);
      padding: 10px 16px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
      font-size: 14px;
      direction: rtl;
      z-index: 10;
    }

    #hud span { white-space: nowrap; }

    #message {
      flex: 1;
      min-width: 140px;
    }

    #checkBtn {
      border: none;
      padding: 8px 20px;
      border-radius: 999px;
      background: #1e88e5;
      color: white;
      font-weight: 600;
      cursor: pointer;
      font-family: inherit;
      font-size: 14px;
    }

    #checkBtn:active { transform: scale(0.96); }

    /* ×›×¤×ª×•×¨ ×¡×™××Ÿ ×©××œ×” */
    #helpBtn {
      border: none;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: #ffca28;
      color: #263238;
      font-weight: 800;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }

    #helpBtn:active { transform: scale(0.96); }

    /* ×›×¤×ª×•×¨ X ×™×¦×™××” â€“ ××•×¤×™×¢ ××—×¨×™ × ×’×™×¢×” ×‘××¡×š */
    #exitBtn {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: none;
      background: rgba(244,67,54,0.95);
      color: #fff;
      font-weight: 700;
      font-size: 18px;
      cursor: pointer;
      z-index: 12;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s;
    }

    #exitBtn.visible {
      opacity: 1;
      pointer-events: auto;
    }

    /* ××•×‘×¨×œ×™×™ "××™×š ×œ×©×—×§" â€“ ××¡×š ××œ× */
    #howToOverlay {
      position: fixed;
      inset: 0;
      background: rgba(13, 31, 55, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    #howToOverlay.hidden { display: none; }

    #howToCard {
      width: 90%;
      max-width: 480px;
      background: #ffffff;
      border-radius: 20px;
      box-shadow: 0 16px 40px rgba(0,0,0,0.35);
      padding: 22px 20px 18px;
      text-align: right;
      direction: rtl;
      position: relative;
    }

    #howToTitle {
      font-size: 26px;
      font-weight: 800;
      color: #1e3a8a;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: center;
    }

    #howToTitle span.icon {
      font-size: 28px;
    }

    #howToCard h3 {
      font-size: 18px;
      margin: 12px 0 6px;
      color: #1565c0;
    }

    #howToCard p {
      font-size: 14px;
      margin-bottom: 6px;
      color: #263238;
    }

    #howToCard ol {
      padding-right: 20px;
      margin: 4px 0 8px;
      font-size: 14px;
      color: #263238;
    }

    #howToCard li { margin-bottom: 4px; }

    #howToCard .tip {
      font-size: 13px;
      margin-top: 8px;
      color: #2e7d32;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    #closeOverlay {
      position: absolute;
      top: 10px;
      left: 10px;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: none;
      background: #e0e0e0;
      color: #37474f;
      cursor: pointer;
      font-weight: 700;
      font-size: 18px;
    }

    @media (max-width: 600px) {
      #hud {
        top: 10px;
        padding: 8px 10px;
        font-size: 11px;
        gap: 6px;
      }

      #checkBtn {
        padding: 6px 14px;
        font-size: 12px;
      }

      #message { min-width: 100px; }

      #howToCard {
        padding: 18px 14px 14px;
      }

      #howToTitle { font-size: 22px; }
      #howToCard h3 { font-size: 16px; }
      #howToCard p,
      #howToCard li { font-size: 13px; }
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <!-- HUD ×¢×œ×™×•×Ÿ -->
  <div id="hud">
    <span id="capacity">×§×™×‘×•×œ×ª: ?</span>
    <span id="weight">××©×§×œ × ×•×›×—×™: 0</span>
    <span id="value">×¢×¨×š × ×•×›×—×™: 0</span>
    <span id="message">×‘×—×¨ ××ª ×”×¦×™×•×“ ×©×œ×š ×•×”×¢××¡ ×œ××¨×’×– â€“ ×‘×œ×™ ×œ×—×¨×•×’ ××”×§×™×‘×•×œ×ª!</span>
    <button id="checkBtn">âœ” ×‘×“×•×§ ×¤×ª×¨×•×Ÿ</button>
    <button id="helpBtn">?</button>
  </div>

  <!-- ×›×¤×ª×•×¨ ×™×¦×™××” -->
  <button id="exitBtn">âœ•</button>

  <!-- ××¡×š ××œ× â€“ ××™×š ×œ×©×—×§ -->
  <div id="howToOverlay" class="hidden">
    <div id="howToCard">
      <button id="closeOverlay">âœ•</button>
      <div id="howToTitle">
        <span class="icon">ğŸ’</span>
        <span>××™×š ×œ×©×—×§?</span>
      </div>
      <h3>×”××˜×¨×”</h3>
      <p>×œ××œ× ××ª ××¨×’×– ×”×¦×™×•×“ ×‘××•×¦×¨×™× ×‘×¢×œ×™ ×”×¢×¨×š ×”×›×•×œ×œ ×”×’×‘×•×” ×‘×™×•×ª×¨, ××‘×œ×™ ×œ×—×¨×•×’ ××”××©×§×œ ×”××§×¡×™××œ×™.</p>

      <h3>××™×š ××©×—×§×™×</h3>
      <ol>
        <li>×œ×—×¥ ×¢×œ ××•×¦×¨ ×›×“×™ ×œ×”×›× ×™×¡ ××•×ª×• ×œ××¨×’×–.</li>
        <li>×œ×—×¥ ×©×•×‘ ×¢×œ ××•×ª×• ××•×¦×¨ ×›×“×™ ×œ×”×•×¦×™× ××•×ª×•.</li>
        <li>×¢×§×•×‘ ××—×¨×™ ×”××©×§×œ ×•×”×¢×¨×š ×‘×¤×¡ ×”×¢×œ×™×•×Ÿ ×©×œ ×”××¡×š.</li>
        <li>×›×©××ª×” ×—×•×©×‘ ×©××¦××ª ×¡×˜ ×¦×™×•×“ ×—×›×, ×œ×—×¥ ×¢×œ "×‘×“×•×§ ×¤×ª×¨×•×Ÿ".</li>
      </ol>

      <div class="tip">
        <span>ğŸ’¡</span>
        <span>×˜×™×¤: ×œ× ×ª××™×“ ×›×“××™ ×œ×§×—×ª ××ª ×”×¤×¨×™×˜ ×”×™×§×¨ ×‘×™×•×ª×¨ â€“ ×œ×¤×¢××™× ×©×™×œ×•×‘ ×—×›× × ×•×ª×Ÿ ×™×•×ª×¨ ×¢×¨×š!</span>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    // ×¨×–×•×œ×•×¦×™×” × ×•×¨××œ×™×ª ×œ××•×‘×™×™×œ ×œ×¨×•×—×‘
    engine.setHardwareScalingLevel(1 / Math.min(window.devicePixelRatio || 1, 2));

    const IS_MOBILE = window.innerWidth <= 768;
    const SCALE = IS_MOBILE ? 0.45 : 0.5;

    // ====== × ×ª×•× ×™ ×‘×¢×™×™×ª ×ª×¨××™×œ ×”×’×‘ ======
    const CAPACITY = 10;
    const ITEMS = [
      { name: "ğŸ”© ×× ×•×¢ ×¡×¨×•×•",      weight: 4, value: 9,  color: new BABYLON.Color3(0.98, 0.54, 0.20), type: "servo" },
      { name: "ğŸ”¦ ×—×™×™×©×Ÿ ×œ×™×™×–×¨",    weight: 2, value: 6,  color: new BABYLON.Color3(0.11, 0.80, 0.98), type: "laser" },
      { name: "ğŸ“¦ ×‘×§×¨ PLC",        weight: 3, value: 7,  color: new BABYLON.Color3(0.63, 0.40, 0.98), type: "plc" },
      { name: "ğŸ¤– ××•×“×•×œ ×–×¨×•×¢",      weight: 5, value: 10, color: new BABYLON.Color3(1.00, 0.84, 0.15), type: "robotArm" },
      { name: "ğŸ“· ××¦×œ××ª QC",       weight: 1, value: 3,  color: new BABYLON.Color3(0.30, 0.88, 0.53), type: "camera" },
      { name: "ğŸ“¡ ××•×“×•×œ RFID",     weight: 2, value: 5,  color: new BABYLON.Color3(0.36, 0.69, 1.00), type: "rfid" }
    ];

    let scene, camera, ui;
    let backpackBase;
    let itemRoots = [];
    let backpackSlots = [];
    let currentWeight = 0;
    let currentValue  = 0;
    let bestPossibleValue = 0;

    // ===== ×¡××•× ×“ ×¤×©×•×˜ ×“×¨×š Audio =====
    const moveAudio = new Audio("transition-sfx-whoosh-sound-effect-407576.mp3");

    function playMoveSfx() {
      try {
        moveAudio.currentTime = 0;
        moveAudio.play();
      } catch (e) {
        console.log("audio error:", e);
      }
    }

    // HUD + ×¢×–×¨×” + ×™×¦×™××”
    const capacityEl = document.getElementById("capacity");
    const weightEl   = document.getElementById("weight");
    const valueEl    = document.getElementById("value");
    const msgEl      = document.getElementById("message");
    const checkBtn   = document.getElementById("checkBtn");
    const helpBtn    = document.getElementById("helpBtn");
    const exitBtn    = document.getElementById("exitBtn");
    const howToOverlay = document.getElementById("howToOverlay");
    const closeOverlay = document.getElementById("closeOverlay");

    capacityEl.textContent = "×§×™×‘×•×œ×ª: " + CAPACITY;

    // ×”×¦×’×ª ×›×¤×ª×•×¨ X + × ×™×¡×™×•×Ÿ ×œ××¡×š ××œ× ××—×¨×™ × ×’×™×¢×” ×¨××©×•× ×” ×‘××¡×š
    document.addEventListener("pointerdown", () => {
      exitBtn.classList.add("visible");

      // × ×™×¡×™×•×Ÿ ×œ×”×™×›× ×¡ ×œ××¡×š ××œ× (×™×›×©×œ ×‘×©×§×˜ ××™×¤×” ×©×œ× × ×ª××š)
      const elem = document.documentElement;
      if (!document.fullscreenElement &&
          elem.requestFullscreen) {
        elem.requestFullscreen().catch(() => {});
      }
    }, { once: true });

    exitBtn.addEventListener("click", () => {
      const ok = confirm("×œ×™×¦×™××” ××”××©×—×§ ×¡×’×•×¨ ××ª ×”×œ×©×•× ×™×ª ××• ×—×–×•×¨ ××—×•×¨×” ×‘×“×¤×“×¤×Ÿ.\n\n×”×× ×œ×—×–×•×¨ ××—×•×¨×” ×¢×›×©×™×•?");
      if (ok) {
        window.history.back();
      }
    });

    helpBtn.addEventListener("click", () => {
      howToOverlay.classList.remove("hidden");
    });

    closeOverlay.addEventListener("click", () => {
      howToOverlay.classList.add("hidden");
    });

    // ===== ×—×™×©×•×‘ ×”×¢×¨×š ×”××•×¤×˜×™××œ×™ =====
    function computeOptimalValue() {
      const n = ITEMS.length;
      let best = 0;
      for (let mask = 0; mask < (1 << n); mask++) {
        let w = 0, v = 0;
        for (let i = 0; i < n; i++) {
          if (mask & (1 << i)) {
            w += ITEMS[i].weight;
            v += ITEMS[i].value;
          }
        }
        if (w <= CAPACITY && v > best) best = v;
      }
      return best;
    }

    // ===== ×™×¦×™×¨×ª ×¡×¦× ×” =====
    function createScene() {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3(0.90, 0.94, 0.99);

      // ×ª××•×¨×”
      const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
      hemi.intensity = 0.8;

      const dir = new BABYLON.DirectionalLight("dir",
        new BABYLON.Vector3(-0.5, -1, -0.3),
        scene);
      dir.intensity = 0.6;

      // ===== ××¦×œ××” â€“ ×¤×¨×•× ×˜×œ×™×ª, ×¨×•××” ××ª ×›×œ ×”×©×•×œ×—×Ÿ ×•×”×§×™×¨ =====
      const baseRadius = IS_MOBILE ? 100 * SCALE : 23 * SCALE;

      camera = new BABYLON.ArcRotateCamera(
        "camera",
        BABYLON.Tools.ToRadians(90),    // ××•×œ ×”×§×™×¨ ×•×”×©×•×œ×—×Ÿ
        BABYLON.Tools.ToRadians(35),    // ×§×¦×ª ×¤×—×•×ª ××œ××¢×œ×” â€“ ×¨×•××™× ×™×•×ª×¨ ××ª ×”××“×¨×’×•×ª ×•×”××•×¦×¨×™×
        baseRadius,
        new BABYLON.Vector3(-2 * SCALE, 3.2 * SCALE, 0),
        scene
      );

      camera.attachControl(canvas, true);
      camera.inputs.clear();
      camera.lowerRadiusLimit = baseRadius;
      camera.upperRadiusLimit = baseRadius;
      camera.lowerBetaLimit   = camera.beta;
      camera.upperBetaLimit   = camera.beta;
      camera.panningSensibility = 0;

      // GUI
      ui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

      // ×¡×‘×™×‘×”
      createEnvironment(scene);

      // ×ª×¨××™×œ / ××¨×’×– ×¦×™×•×“
      createBackpack(scene);

      // ××•×¦×¨×™×
      createItems(scene);

      // ×‘×—×™×¨×”
      setupPicking(scene);

      return scene;
    }

    function createEnvironment(scene) {
      // ×¨×¦×¤×” â€“ ×˜×§×¡×˜×•×¨×” ×¢×“×™× ×” ×©×œ ×‘×˜×•×Ÿ/××¤×•×§×¡×™
      const ground = BABYLON.MeshBuilder.CreateGround("ground", {
        width: 44 * SCALE,
        height: 30 * SCALE
      }, scene);
      const gMat = new BABYLON.StandardMaterial("gMat", scene);
      gMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/ground.jpg", scene);
      gMat.diffuseTexture.uScale = 4;
      gMat.diffuseTexture.vScale = 4;
      gMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.5);
      ground.material = gMat;
      ground.isPickable = false;

      // ×¤×¡×™× ×–×•×”×¨×™×
      for (let i = -2; i <= 2; i++) {
        const stripe = BABYLON.MeshBuilder.CreateBox("stripe" + i, {
          width: 44 * SCALE,
          height: 0.02 * SCALE,
          depth: 0.12 * SCALE
        }, scene);
        stripe.position = new BABYLON.Vector3(0, 0.01 * SCALE, i * 3 * SCALE);
        const sMat = new BABYLON.StandardMaterial("sMat" + i, scene);
        sMat.emissiveColor = new BABYLON.Color3(0.36, 0.65, 1);
        sMat.alpha = 0.65;
        stripe.material = sMat;
        stripe.isPickable = false;
      }

      // ×§×™×¨ ××—×•×¨×™ â€“ ×˜×™×¤×” ×™×•×ª×¨ ×¨×—×•×§, ××¢×˜ ×›×”×”
      const wall = BABYLON.MeshBuilder.CreateBox("wall", {
        width: 44 * SCALE,
        height: 12 * SCALE,
        depth: 0.4 * SCALE
      }, scene);
      wall.position = new BABYLON.Vector3(0, 6 * SCALE, -9 * SCALE);
      const wMat = new BABYLON.StandardMaterial("wMat", scene);
      wMat.diffuseColor = new BABYLON.Color3(0.85, 0.90, 0.97);
      wMat.specularColor = new BABYLON.Color3(0.7, 0.7, 0.8);
      wall.material = wMat;
      wall.isPickable = false;

      // ×¨×¦×•×¢×ª LED ×‘×§×™×¨
      const ledStrip = BABYLON.MeshBuilder.CreateBox("ledStrip", {
        width: 38 * SCALE,
        height: 0.3 * SCALE,
        depth: 0.1 * SCALE
      }, scene);
      ledStrip.position = new BABYLON.Vector3(0, 9 * SCALE, -8.8 * SCALE);
      const ledMat = new BABYLON.StandardMaterial("ledMat", scene);
      ledMat.emissiveColor = new BABYLON.Color3(0.26, 0.82, 0.96);
      ledStrip.material = ledMat;
      ledStrip.isPickable = false;

      // ×©×•×œ×—×Ÿ ×¢×‘×•×“×” â€“ ×¢× ×˜×§×¡×˜×•×¨×ª ×¢×¥/××ª×›×ª ×‘×”×™×¨×”
      const tableTop = BABYLON.MeshBuilder.CreateBox("tableTop", {
        width: 30 * SCALE,
        depth: 12 * SCALE,
        height: 0.5 * SCALE
      }, scene);
      tableTop.position.y = 2.4 * SCALE;
      const tMat = new BABYLON.StandardMaterial("tMat", scene);
      tMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/wood.jpg", scene);
      tMat.diffuseTexture.uScale = 2;
      tMat.diffuseTexture.vScale = 2;
      tMat.specularColor = new BABYLON.Color3(0.8, 0.8, 0.85);
      tableTop.material = tMat;
      tableTop.isPickable = false;

      // ×¨×’×œ×™×™× ×œ×©×•×œ×—×Ÿ
      for (let sx of [-1, 1]) {
        for (let sz of [-1, 1]) {
          const leg = BABYLON.MeshBuilder.CreateBox("leg", {
            width: 0.7 * SCALE,
            depth: 0.7 * SCALE,
            height: 2.4 * SCALE
          }, scene);
          leg.position = new BABYLON.Vector3(
            sx * 13.5 * SCALE,
            1.2 * SCALE,
            sz * 5.5 * SCALE
          );
          leg.material = tMat;
          leg.isPickable = false;
        }
      }

      // ××“×¨×’×•×ª ×œ×ª×¦×•×’×ª ×”××•×¦×¨×™× â€“ ××“×¨×’×” ×§×“××™×ª × ××•×›×”, ××—×•×¨×™×ª ×’×‘×•×”×”
      const stepMat = new BABYLON.StandardMaterial("stepMat", scene);
      stepMat.diffuseColor = new BABYLON.Color3(0.80, 0.86, 0.96);
      stepMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.95);

      const stepWidth = 18 * SCALE;
      const stepDepth = 4 * SCALE;
      const stepHeight = 0.35 * SCALE;
      const itemsCenterX = -8 * SCALE;

      // ××“×¨×’×” ×§×“××™×ª â€“ × ××•×›×” ×™×•×ª×¨
      const step1 = BABYLON.MeshBuilder.CreateBox("step1", {
        width: stepWidth,
        depth: stepDepth,
        height: stepHeight
      }, scene);
      step1.position = new BABYLON.Vector3(
        itemsCenterX,
        2.4 * SCALE + 0.25 * SCALE + stepHeight / 2, // ×¢×œ ×”×©×•×œ×—×Ÿ
        -2.5 * SCALE
      );
      step1.material = stepMat;
      step1.isPickable = false;

      // ××“×¨×’×” ××—×•×¨×™×ª â€“ ×’×‘×•×”×” ×™×•×ª×¨
      const step2 = BABYLON.MeshBuilder.CreateBox("step2", {
        width: stepWidth,
        depth: stepDepth,
        height: stepHeight
      }, scene);
      step2.position = new BABYLON.Vector3(
        itemsCenterX,
        step1.position.y + stepHeight + 0.15 * SCALE,
        2.5 * SCALE
      );
      step2.material = stepMat;
      step2.isPickable = false;
    }

    // ===== ×ª×¨××™×œ / ××¨×’×– ×¦×™×•×“ =====
    function createBackpack(scene) {
      // ×‘×¡×™×¡
      backpackBase = BABYLON.MeshBuilder.CreateBox("backpackBase", {
        width: 7 * SCALE,
        height: 0.5 * SCALE,
        depth: 5 * SCALE
      }, scene);
      backpackBase.position = new BABYLON.Vector3(11 * SCALE, 2.65 * SCALE, 0);
      const baseMat = new BABYLON.StandardMaterial("baseMat", scene);
      baseMat.diffuseColor = new BABYLON.Color3(0.80, 0.86, 0.95);
      baseMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.95);
      backpackBase.material = baseMat;
      backpackBase.isPickable = false;

      // ×’×•×£ ×¢×’×•×œ
      const body = BABYLON.MeshBuilder.CreateCylinder("packBody", {
        diameter: 7 * SCALE,
        height: 3.2 * SCALE,
        tessellation: 32
      }, scene);
      body.scaling.z = 0.7;
      body.position = backpackBase.position.add(new BABYLON.Vector3(0, 1.8 * SCALE, 0.1 * SCALE));
      const bodyMat = new BABYLON.StandardMaterial("bodyMat", scene);
      bodyMat.diffuseColor = new BABYLON.Color3(0.45, 0.62, 0.93);
      bodyMat.alpha = 0.55;
      body.material = bodyMat;
      body.isPickable = false;

      // ××›×¡×”
      const lid = BABYLON.MeshBuilder.CreateCylinder("packLid", {
        diameter: 7 * SCALE,
        height: 0.4 * SCALE,
        tessellation: 32
      }, scene);
      lid.scaling.z = 0.7;
      lid.position = backpackBase.position.add(new BABYLON.Vector3(0, 3.3 * SCALE, 0.2 * SCALE));
      const lidMat = new BABYLON.StandardMaterial("lidMat", scene);
      lidMat.diffuseColor = new BABYLON.Color3(0.35, 0.52, 0.88);
      lid.material = lidMat;
      lid.isPickable = false;

      // ×™×“×™×ª
      const handle = BABYLON.MeshBuilder.CreateTorus("handle", {
        diameter: 3 * SCALE,
        thickness: 0.3 * SCALE,
        tessellation: 32
      }, scene);
      handle.position = backpackBase.position.add(new BABYLON.Vector3(0, 3.9 * SCALE, 2 * SCALE));
      const handleMat = new BABYLON.StandardMaterial("handleMat", scene);
      handleMat.diffuseColor = new BABYLON.Color3(0.95, 0.95, 1);
      handleMat.specularColor = new BABYLON.Color3(0.9, 0.9, 1);
      handle.material = handleMat;
      handle.isPickable = false;

      // ×¡×œ×•×˜×™× ×‘×ª×•×š ×”××¨×’×–
      const center = backpackBase.position.add(new BABYLON.Vector3(0, 0.6 * SCALE, 0));
      const dx = 2.2 * SCALE;

      for (let row = 0; row < 2; row++) {
        for (let col = 0; col < 3; col++) {
          const pos = new BABYLON.Vector3(
            center.x + (col - 1) * dx,
            center.y + row * 1.3 * SCALE,
            center.z + (row === 0 ? 0.6 * SCALE : -0.6 * SCALE)
          );
          backpackSlots.push(pos);

          const slot = BABYLON.MeshBuilder.CreateBox("slotViz", {
            width: 1.9 * SCALE,
            height: 0.03 * SCALE,
            depth: 1.3 * SCALE
          }, scene);
          slot.position = new BABYLON.Vector3(pos.x, backpackBase.position.y + 0.01 * SCALE, pos.z);
          const sMat = new BABYLON.StandardMaterial("slotMat", scene);
          sMat.diffuseColor = new BABYLON.Color3(0.7, 0.85, 1);
          sMat.alpha = 0.45;
          slot.material = sMat;
          slot.isPickable = false;
        }
      }

      // ×›×™×ª×•×‘ GUI "××¨×’×– ×¦×™×•×“"
      const rect = new BABYLON.GUI.Rectangle();
      rect.width = IS_MOBILE ? "130px" : "140px";
      rect.height = "34px";
      rect.thickness = 0;
      rect.cornerRadius = 17;
      rect.background = "rgba(255,255,255,0.96)";
      ui.addControl(rect);
      rect.linkWithMesh(backpackBase);
      rect.linkOffsetY = -42;

      const txt = new BABYLON.GUI.TextBlock();
      txt.text = "ğŸ’ ××¨×’×– ×¦×™×•×“ ×ª×¢×©×™×™×ª×™";
      txt.color = "#1a237e";
      txt.fontSize = IS_MOBILE ? 13 : 14;
      txt.fontFamily = "Heebo";
      rect.addControl(txt);
    }

    // ===== ×™×¦×™×¨×ª ×”××•×¦×¨×™× =====
    function createItems(scene) {
      itemRoots = [];

      // ××™×§×•××™× ×¢×œ ×”××“×¨×’×•×ª â€“ ×©×ª×™ ×©×•×¨×•×ª ×‘×’×‘×”×™× ×©×•× ×™×
      const startX = -13 * SCALE;
      const gapX   = 4.8 * SCALE;

      const rowY   = [3.3 * SCALE, 3.8 * SCALE];      // ×§×“××™×ª × ××•×›×”, ××—×•×¨×™×ª ×’×‘×•×”×”
      const rowZ   = [-2.5 * SCALE, 2.5 * SCALE];

      ITEMS.forEach((item, i) => {
        const row = i < 3 ? 0 : 1;
        const col = i % 3;

        const root = new BABYLON.TransformNode("itemRoot_" + i, scene);
        root.position = new BABYLON.Vector3(
          startX + col * gapX,
          rowY[row],
          rowZ[row]
        );

        buildItemModel(scene, root, item);

        root.metadata = {
          type: "itemRoot",
          index: i,
          selected: false,
          basePosition: root.position.clone(),
          slotIndex: null
        };

        // ×ª×•×•×™×ª GUI
        const rect = new BABYLON.GUI.Rectangle();
        rect.width = IS_MOBILE ? "150px" : "190px";
        rect.height = IS_MOBILE ? "42px" : "52px";
        rect.thickness = 0;
        rect.cornerRadius = 16;
        rect.background = "rgba(255,255,255,0.9)";
        rect.alpha = 0.95;
        rect.isPointerBlocker = false;
        ui.addControl(rect);
        rect.linkWithMesh(root);
        rect.linkOffsetY = row === 0 ? -80 : -70;

        const lbl = new BABYLON.GUI.TextBlock();
        lbl.text = `${item.name}\n××©×§×œ: ${item.weight} | ×¢×¨×š: ${item.value}`;
        lbl.fontFamily = "Heebo";
        lbl.color = "#263238";
        lbl.fontSize = IS_MOBILE ? 11 : 13;
        lbl.textWrapping = true;
        rect.addControl(lbl);

        itemRoots.push(root);
      });
    }

    // ===== ××•×“×œ×™× ×©×œ ×”××•×¦×¨×™× â€“ ××•×¡×™×¤×™× ×§×¦×ª "×˜×§×¡×˜×•×¨×”" ×•×ª×—×•×©×” ×—×•××¨×™×ª =====
    function buildItemModel(scene, root, item) {
      const col = item.color;

      // ×—×•××¨ ××ª×›×ª×™ ×¢×“×™×Ÿ ×œ×©×™××•×© ×‘×—×œ×§×™ ××ª×›×ª
      const metalMat = new BABYLON.StandardMaterial("metalMat_" + item.type, scene);
      metalMat.diffuseColor = new BABYLON.Color3(0.2, 0.22, 0.26);
      metalMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
      metalMat.specularPower = 64;

      if (item.type === "servo") {
        const base = BABYLON.MeshBuilder.CreateBox("servoBase", {
          width: 1.8 * SCALE,
          height: 0.6 * SCALE,
          depth: 1.4 * SCALE
        }, scene);
        base.parent = root;
        base.position.y = 0.3 * SCALE;
        base.material = metalMat;

        const body = BABYLON.MeshBuilder.CreateBox("servoBody", {
          width: 1.5 * SCALE,
          height: 0.9 * SCALE,
          depth: 1.1 * SCALE
        }, scene);
        body.parent = root;
        body.position.y = 0.9 * SCALE;
        const bodyMat = new BABYLON.StandardMaterial("servoBodyMat", scene);
        bodyMat.diffuseColor = col;
        bodyMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
        bodyMat.specularPower = 48;
        body.material = bodyMat;

        const shaft = BABYLON.MeshBuilder.CreateCylinder("servoShaft", {
          diameter: 0.35 * SCALE,
          height: 0.4 * SCALE
        }, scene);
        shaft.parent = root;
        shaft.position = new BABYLON.Vector3(0, 1.4 * SCALE, 0);
        const shaftMat = new BABYLON.StandardMaterial("shaftMat", scene);
        shaftMat.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.95);
        shaftMat.specularPower = 64;
        shaft.material = shaftMat;

        const horn = BABYLON.MeshBuilder.CreateBox("servoHorn", {
          width: 1.6 * SCALE,
          height: 0.12 * SCALE,
          depth: 0.35 * SCALE
        }, scene);
        horn.parent = root;
        horn.position = new BABYLON.Vector3(0, 1.55 * SCALE, 0);
        horn.material = shaftMat;

      } else if (item.type === "laser") {
        const body = BABYLON.MeshBuilder.CreateBox("laserBody", {
          width: 1.6 * SCALE,
          height: 0.7 * SCALE,
          depth: 1.1 * SCALE
        }, scene);
        body.parent = root;
        const bodyMat = new BABYLON.StandardMaterial("laserBodyMat", scene);
        bodyMat.diffuseColor = col;
        bodyMat.specularColor = new BABYLON.Color3(0.8, 0.8, 0.9);
        bodyMat.specularPower = 48;
        body.material = bodyMat;

        const lens = BABYLON.MeshBuilder.CreateCylinder("laserLens", {
          diameter: 0.6 * SCALE,
          height: 0.35 * SCALE,
          tessellation: 24
        }, scene);
        lens.parent = root;
        lens.position.z = 0.7 * SCALE;
        const lensMat = new BABYLON.StandardMaterial("lensMat", scene);
        lensMat.diffuseColor = new BABYLON.Color3(0.1, 0.5, 1);
        lensMat.emissiveColor = new BABYLON.Color3(0.1, 0.7, 1);
        lensMat.specularPower = 64;
        lens.material = lensMat;

        const bracket = BABYLON.MeshBuilder.CreateBox("laserBracket", {
          width: 0.8 * SCALE,
          height: 0.2 * SCALE,
          depth: 1.2 * SCALE
        }, scene);
        bracket.parent = root;
        bracket.position.y = -0.45 * SCALE;
        bracket.material = metalMat;

      } else if (item.type === "plc") {
        const rack = BABYLON.MeshBuilder.CreateBox("plcRack", {
          width: 2.4 * SCALE,
          height: 1.4 * SCALE,
          depth: 0.9 * SCALE
        }, scene);
        rack.parent = root;
        rack.position.y = 0.8 * SCALE;
        rack.material = metalMat;

        for (let i = 0; i < 4; i++) {
          const mod = BABYLON.MeshBuilder.CreateBox("plcMod" + i, {
            width: 0.5 * SCALE,
            height: 1.1 * SCALE,
            depth: 0.7 * SCALE
          }, scene);
          mod.parent = root;
          mod.position = new BABYLON.Vector3(
            -0.75 * SCALE + i * 0.5 * SCALE,
            0.8 * SCALE,
            0
          );
          const mMat = new BABYLON.StandardMaterial("plcModMat" + i, scene);
          mMat.diffuseColor = new BABYLON.Color3(0.4 + 0.1 * i, 0.5, 0.7);
          mMat.specularColor = new BABYLON.Color3(0.8, 0.8, 0.9);
          mMat.specularPower = 48;
          mod.material = mMat;
        }

      } else if (item.type === "robotArm") {
        const base = BABYLON.MeshBuilder.CreateCylinder("armBase", {
          diameter: 1.3 * SCALE,
          height: 0.4 * SCALE
        }, scene);
        base.parent = root;
        base.position.y = 0.2 * SCALE;
        base.material = metalMat;

        const joint1 = BABYLON.MeshBuilder.CreateCylinder("joint1", {
          diameter: 0.9 * SCALE,
          height: 0.6 * SCALE
        }, scene);
        joint1.parent = root;
        joint1.position.y = 0.7 * SCALE;
        const jMat = new BABYLON.StandardMaterial("jMat", scene);
        jMat.diffuseColor = col;
        jMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.85);
        jMat.specularPower = 48;
        joint1.material = jMat;

        const arm1 = BABYLON.MeshBuilder.CreateBox("arm1", {
          width: 0.4 * SCALE,
          height: 1.6 * SCALE,
          depth: 0.4 * SCALE
        }, scene);
        arm1.parent = root;
        arm1.position = new BABYLON.Vector3(0, 1.6 * SCALE, 0.2 * SCALE);
        arm1.rotation.z = -0.3;
        arm1.material = jMat;

        const joint2 = BABYLON.MeshBuilder.CreateSphere("joint2", {
          diameter: 0.6 * SCALE
        }, scene);
        joint2.parent = root;
        joint2.position = new BABYLON.Vector3(0.3 * SCALE, 2.2 * SCALE, 0.4 * SCALE);
        joint2.material = jMat;

        const arm2 = BABYLON.MeshBuilder.CreateBox("arm2", {
          width: 0.35 * SCALE,
          height: 1.2 * SCALE,
          depth: 0.35 * SCALE
        }, scene);
        arm2.parent = root;
        arm2.position = new BABYLON.Vector3(0.4 * SCALE, 2.7 * SCALE, 0.7 * SCALE);
        arm2.rotation.z = 0.4;
        arm2.material = jMat;

        const gripper = BABYLON.MeshBuilder.CreateBox("gripper", {
          width: 0.7 * SCALE,
          height: 0.2 * SCALE,
          depth: 0.5 * SCALE
        }, scene);
        gripper.parent = root;
        gripper.position = new BABYLON.Vector3(0.6 * SCALE, 3.3 * SCALE, 0.9 * SCALE);
        const gMat = new BABYLON.StandardMaterial("gMat", scene);
        gMat.diffuseColor = new BABYLON.Color3(0.15, 0.15, 0.2);
        gMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
        gMat.specularPower = 64;
        gripper.material = gMat;

      } else if (item.type === "camera") {
        const body = BABYLON.MeshBuilder.CreateBox("camBody", {
          width: 1.6 * SCALE,
          height: 0.9 * SCALE,
          depth: 0.9 * SCALE
        }, scene);
        body.parent = root;
        body.material = metalMat;

        const lens = BABYLON.MeshBuilder.CreateCylinder("camLens", {
          diameter: 0.7 * SCALE,
          height: 0.6 * SCALE,
          tessellation: 24
        }, scene);
        lens.parent = root;
        lens.position.z = 0.7 * SCALE;
        const lMat = new BABYLON.StandardMaterial("camLensMat", scene);
        lMat.diffuseColor = new BABYLON.Color3(0.1, 0.5, 1);
        lMat.emissiveColor = new BABYLON.Color3(0.1, 0.7, 1);
        lMat.specularPower = 64;
        lens.material = lMat;

        const mount = BABYLON.MeshBuilder.CreateBox("camMount", {
          width: 0.8 * SCALE,
          height: 0.2 * SCALE,
          depth: 1.2 * SCALE
        }, scene);
        mount.parent = root;
        mount.position.y = -0.5 * SCALE;
        mount.material = metalMat;

      } else if (item.type === "rfid") {
        const body = BABYLON.MeshBuilder.CreateBox("rfidBody", {
          width: 1.9 * SCALE,
          height: 0.4 * SCALE,
          depth: 1.5 * SCALE
        }, scene);
        body.parent = root;
        const bMat = new BABYLON.StandardMaterial("rfidMat", scene);
        bMat.diffuseColor = col;
        bMat.specularColor = new BABYLON.Color3(0.85, 0.85, 0.95);
        bMat.specularPower = 48;
        body.material = bMat;

        const frame = BABYLON.MeshBuilder.CreateTorus("rfidFrame", {
          diameter: 1.3 * SCALE,
          thickness: 0.08 * SCALE,
          tessellation: 32
        }, scene);
        frame.parent = root;
        frame.rotation.x = Math.PI / 2;
        frame.position.y = 0.25 * SCALE;
        const fMat = new BABYLON.StandardMaterial("rfidFrameMat", scene);
        fMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
        fMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
        fMat.specularPower = 64;
        frame.material = fMat;
      }
    }

    // ===== ×‘×—×™×¨×” =====
    function setupPicking(scene) {
      scene.onPointerDown = (evt, pickResult) => {
        if (!pickResult || !pickResult.hit || !pickResult.pickedMesh) return;

        let node = pickResult.pickedMesh;
        while (node && (!node.metadata || node.metadata.type !== "itemRoot")) {
          node = node.parent;
        }
        if (!node || !node.metadata) return;

        toggleItem(node);
      };

      checkBtn.addEventListener("click", checkSolution);
    }

    // ===== ×× ×™××¦×™×™×ª ××¢×‘×¨ =====
    function moveNodeTo(node, newPos) {
      const from = node.position.clone();
      const to = newPos.clone();

      const anim = new BABYLON.Animation(
        "moveAnim_" + node.name,
        "position",
        60,
        BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
      );

      const keys = [
        { frame: 0,  value: from },
        { frame: 45, value: to }
      ];
      anim.setKeys(keys);

      node.animations = [anim];
      node.getScene().beginAnimation(node, 0, 45, false);
    }

    // ===== ×œ×•×’×™×§×ª ×”×•×¡×¤×” / ×”×•×¦××” =====
    function toggleItem(root) {
      const idx = root.metadata.index;
      const item = ITEMS[idx];

      if (!root.metadata.selected) {
        // ×”×•×¡×¤×”
        root.metadata.selected = true;
        currentWeight += item.weight;
        currentValue  += item.value;

        // ×¡×œ×•×˜ ×¤× ×•×™
        let freeIndex = null;
        for (let i = 0; i < backpackSlots.length; i++) {
          let taken = false;
          for (const n of itemRoots) {
            if (n.metadata.selected && n.metadata.slotIndex === i) {
              taken = true;
              break;
            }
          }
          if (!taken) {
            freeIndex = i;
            break;
          }
        }

        if (freeIndex === null) {
          // ××™×Ÿ ××§×•×
          root.metadata.selected = false;
          currentWeight -= item.weight;
          currentValue  -= item.value;
          msgEl.textContent = "×”××¨×’×– ××œ× ×¤×™×–×™×ª â€“ ×©×—×¨×¨ ××•×¦×¨ ××—×“ ×›×“×™ ×œ×¤× ×•×ª ××§×•×.";
          msgEl.style.color = "#e53935";
        } else {
          root.metadata.slotIndex = freeIndex;
          const target = backpackSlots[freeIndex];
          moveNodeTo(root, target);
          playMoveSfx();
        }

      } else {
        // ×”×•×¦××”
        root.metadata.selected = false;
        currentWeight -= item.weight;
        currentValue  -= item.value;
        const base = root.metadata.basePosition.clone();
        root.metadata.slotIndex = null;
        moveNodeTo(root, base);
        playMoveSfx();
      }

      updateHUD();
    }

    function updateHUD() {
      weightEl.textContent = "××©×§×œ × ×•×›×—×™: " + currentWeight;
      valueEl.textContent  = "×¢×¨×š × ×•×›×—×™: " + currentValue;

      if (currentWeight > CAPACITY) {
        weightEl.style.color = "#e53935";
        msgEl.textContent = "âš  ×”××¨×’×– ×›×¨×’×¢ ×—×•×¨×’ ××”×§×™×‘×•×œ×ª â€“ ×©×—×¨×¨ ××•×¦×¨ ××• ×©× ×™×™× ×•×ª× ×¡×” ×§×•××‘×™× ×¦×™×” ××—×¨×ª.";
        msgEl.style.color = "#e53935";
      } else {
        weightEl.style.color = "#000";
        msgEl.textContent = "×œ×—×¥ ×¢×œ ××•×¦×¨×™× ×›×“×™ ×œ×”×•×¡×™×£ / ×œ×”×•×¦×™×. × ×¡×” ×œ×”×’×™×¢ ×œ×¢×¨×š ×”×›×™ ×’×‘×•×” ×‘×œ×™ ×œ×—×¨×•×’ ××”×§×™×‘×•×œ×ª.";
        msgEl.style.color = "#000";
      }
    }

    // ===== ×‘×“×™×§×ª ×¤×ª×¨×•×Ÿ =====
    function checkSolution() {
      if (currentWeight > CAPACITY) {
        msgEl.textContent = "×”××©×§×œ ×¢×“×™×™×Ÿ ×—×•×¨×’ ××”×§×™×‘×•×œ×ª â€“ ×§×•×“× ×ª××–×Ÿ ××ª ×”××©×§×œ ×•××– ×‘×“×•×§ ×©×•×‘.";
        msgEl.style.color = "#e53935";
        return;
      }

      const diff = bestPossibleValue - currentValue;

      if (diff === 0) {
        msgEl.textContent = "ğŸ‰ ×‘×•×¡ ×©×œ ×”×œ×•×’×™×¡×˜×™×§×”! ×”×’×¢×ª ×œ×¤×ª×¨×•×Ÿ ××•×¤×˜×™××œ×™ â€“ ××™×Ÿ ×§×•××‘×™× ×¦×™×” ×˜×•×‘×” ×™×•×ª×¨.";
        msgEl.style.color = "#2e7d32";
      } else if (diff <= 2) {
        msgEl.textContent = "ğŸ‘ ××ª×” ×××© ×§×¨×•×‘! ××¤×©×¨ ×œ×©×¤×¨ ×¢×•×“ ×§×¦×ª ×•×œ×”×¢×œ×•×ª ××ª ×”×¢×¨×š ×”×›×•×œ×œ ×‘-" + diff + ".";
        msgEl.style.color = "#fbc02d";
      } else {
        msgEl.textContent = "â„¹ ×™×© ×¤×ª×¨×•×Ÿ ×˜×•×‘ ×™×•×ª×¨ â€“ ×”×¢×¨×š ×”××§×¡×™××œ×™ ×”××¤×©×¨×™ ×”×•× " + bestPossibleValue + ". × ×¡×” ×§×•××‘×™× ×¦×™×” ××—×¨×ª.";
        msgEl.style.color = "#f9a825";
      }
    }

    // ===== ×”×ª×—×œ×” =====
    bestPossibleValue = computeOptimalValue();
    scene = createScene();

    engine.runRenderLoop(() => { scene.render(); });

    window.addEventListener("resize", () => {
      engine.resize();
      engine.setHardwareScalingLevel(1 / Math.min(window.devicePixelRatio || 1, 2));
    });
  </script>
</body>
</html>
