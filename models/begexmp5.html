<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <title>××©×—×§ ×ª×¨××™×œ ×”×’×‘ â€“ ××¨×’×– ×¦×™×•×“ ×ª×¢×©×™×™×ª×™ PRO</title>
  
  <!-- ××¡×š ××œ× ××•×‘×™×™×œ - ×”×¡×¨×ª URL bar -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="theme-color" content="#1976D2" />

  <!-- BabylonJS + GUI -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: "Heebo", Arial, sans-serif;
      -webkit-tap-highlight-color: transparent;
      position: fixed;
    }

    body {
      background: radial-gradient(circle at 20% 0%, #ffffff 0%, #e3f2fd 35%, #bbdefb 70%, #90caf9 100%);
      min-height: 100vh;
      min-height: 100dvh;
    }

    #renderCanvas {
      width: 100vw;
      height: 100vh;
      height: 100dvh;
      display: block;
      outline: none;
      position: fixed;
      top: 0;
      left: 0;
    }

    /* HUD ×ª×—×ª×•×Ÿ ×§×•××¤×§×˜×™ */
    #hud {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: max(8px, env(safe-area-inset-bottom, 8px));
      width: 96%;
      max-width: 960px;
      background: rgba(33, 150, 243, 0.92);
      border-radius: 16px;
      box-shadow: 0 -3px 16px rgba(0,0,0,0.25);
      padding: 8px 12px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 14px;
      font-weight: 600;
      direction: rtl;
      z-index: 10;
      color: white;
    }

    #hudInfo {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: space-around;
    }

    #hud span { 
      white-space: nowrap;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
      font-size: 12px;
    }

    #message {
      width: 100%;
      text-align: center;
      color: white;
      line-height: 1.3;
      font-size: 12px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    #checkBtn {
      border: none;
      padding: 8px 20px;
      border-radius: 999px;
      background: white;
      color: #1e88e5;
      font-weight: 700;
      cursor: pointer;
      font-family: inherit;
      font-size: 13px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      width: 100%;
    }

    #checkBtn:active { transform: scale(0.97); }

    /* ×›×¤×ª×•×¨×™× ×¢×œ×™×•× ×™× */
    #topButtons {
      position: fixed;
      top: max(12px, env(safe-area-inset-top, 12px));
      right: 12px;
      display: flex;
      gap: 10px;
      z-index: 11;
    }

    #hintBtn, #helpBtn {
      border: none;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      font-weight: 800;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      box-shadow: 0 3px 12px rgba(0,0,0,0.3);
    }

    #hintBtn {
      background: #ffc107;
      color: #263238;
      font-size: 24px;
    }

    #helpBtn {
      background: white;
      color: #1e88e5;
      font-size: 20px;
    }

    #hintBtn:active, #helpBtn:active { transform: scale(0.94); }

    #exitBtn {
      position: fixed;
      top: max(12px, env(safe-area-inset-top, 12px));
      left: 12px;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: none;
      background: rgba(244,67,54,0.95);
      color: #fff;
      font-weight: 700;
      font-size: 20px;
      cursor: pointer;
      z-index: 12;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s;
      box-shadow: 0 3px 12px rgba(0,0,0,0.3);
    }

    #exitBtn.visible {
      opacity: 1;
      pointer-events: auto;
    }

    #exitBtn:active { transform: scale(0.94); }

    #howToOverlay {
      position: fixed;
      inset: 0;
      background: rgba(13, 31, 55, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    #howToOverlay.hidden { display: none; }

    #howToCard {
      width: 90%;
      max-width: 480px;
      background: #ffffff;
      border-radius: 20px;
      box-shadow: 0 16px 40px rgba(0,0,0,0.35);
      padding: 22px 20px 18px;
      text-align: right;
      direction: rtl;
      position: relative;
    }

    #howToTitle {
      font-size: 26px;
      font-weight: 800;
      color: #1e3a8a;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: center;
    }

    #howToTitle span.icon { font-size: 28px; }

    #howToCard h3 {
      font-size: 18px;
      margin: 12px 0 6px;
      color: #1565c0;
    }

    #howToCard p {
      font-size: 14px;
      margin-bottom: 6px;
      color: #263238;
    }

    #howToCard ol {
      padding-right: 20px;
      margin: 4px 0 8px;
      font-size: 14px;
      color: #263238;
    }

    #howToCard li { margin-bottom: 4px; }

    #howToCard .tip {
      font-size: 13px;
      margin-top: 8px;
      color: #2e7d32;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    #closeOverlay {
      position: absolute;
      top: 10px;
      left: 10px;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: none;
      background: #e0e0e0;
      color: #37474f;
      cursor: pointer;
      font-weight: 700;
      font-size: 18px;
    }

    @media (max-width: 600px) {
      #hud {
        bottom: max(6px, env(safe-area-inset-bottom, 6px));
        padding: 6px 10px;
        border-radius: 14px;
        gap: 4px;
      }

      #hud span {
        font-size: 11px;
      }

      #message {
        font-size: 11px;
      }

      #checkBtn {
        padding: 7px 16px;
        font-size: 12px;
      }

      #topButtons {
        top: max(8px, env(safe-area-inset-top, 8px));
        right: 8px;
        gap: 6px;
      }

      #hintBtn, #helpBtn {
        width: 40px;
        height: 40px;
        font-size: 18px;
      }

      #exitBtn {
        top: max(8px, env(safe-area-inset-top, 8px));
        left: 8px;
        width: 40px;
        height: 40px;
        font-size: 16px;
      }

      #howToCard {
        padding: 18px 14px 14px;
      }

      #howToTitle { font-size: 22px; }
      #howToCard h3 { font-size: 16px; }
      #howToCard p,
      #howToCard li { font-size: 13px; }
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <div id="topButtons">
    <button id="hintBtn">ğŸ’¡</button>
    <button id="helpBtn">?</button>
  </div>

  <div id="hud">
    <span id="message">×‘×—×¨ ××ª ×”×¦×™×•×“ ×©×œ×š ×•×”×¢××¡ ×œ××¨×’×– â€“ ×‘×œ×™ ×œ×—×¨×•×’ ××”×§×™×‘×•×œ×ª!</span>
    <div id="hudInfo">
      <span id="capacity">×§×™×‘×•×œ×ª: ?</span>
      <span id="weight">××©×§×œ × ×•×›×—×™: 0</span>
      <span id="value">×¢×¨×š × ×•×›×—×™: 0</span>
    </div>
    <button id="checkBtn">âœ” ×‘×“×•×§ ×¤×ª×¨×•×Ÿ</button>
  </div>

  <button id="exitBtn">âœ•</button>

  <div id="howToOverlay" class="hidden">
    <div id="howToCard">
      <button id="closeOverlay">âœ•</button>
      <div id="howToTitle">
        <span class="icon">ğŸ’</span>
        <span>××™×š ×œ×©×—×§?</span>
      </div>
      <h3>×”××˜×¨×”</h3>
      <p>×œ××œ× ××ª ××¨×’×– ×”×¦×™×•×“ ×‘××•×¦×¨×™× ×‘×¢×œ×™ ×”×¢×¨×š ×”×›×•×œ×œ ×”×’×‘×•×” ×‘×™×•×ª×¨, ××‘×œ×™ ×œ×—×¨×•×’ ××”××©×§×œ ×”××§×¡×™××œ×™.</p>
      <h3>××™×š ××©×—×§×™×</h3>
      <ol>
        <li>×œ×—×¥ ×¢×œ ××•×¦×¨ ×›×“×™ ×œ×”×›× ×™×¡ ××•×ª×• ×œ××¨×’×–.</li>
        <li>×œ×—×¥ ×©×•×‘ ×¢×œ ××•×ª×• ××•×¦×¨ ×›×“×™ ×œ×”×•×¦×™× ××•×ª×•.</li>
        <li>×¢×§×•×‘ ××—×¨×™ ×”××©×§×œ ×•×”×¢×¨×š ×‘×¤×¡ ×”×¢×œ×™×•×Ÿ ×©×œ ×”××¡×š.</li>
        <li>×›×©××ª×” ×—×•×©×‘ ×©××¦××ª ×¡×˜ ×¦×™×•×“ ×—×›×, ×œ×—×¥ ×¢×œ "×‘×“×•×§ ×¤×ª×¨×•×Ÿ".</li>
      </ol>
      <div class="tip">
        <span>ğŸ’¡</span>
        <span>×˜×™×¤: ×œ× ×ª××™×“ ×›×“××™ ×œ×§×—×ª ××ª ×”×¤×¨×™×˜ ×”×™×§×¨ ×‘×™×•×ª×¨ â€“ ×œ×¤×¢××™× ×©×™×œ×•×‘ ×—×›× × ×•×ª×Ÿ ×™×•×ª×¨ ×¢×¨×š!</span>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    engine.setHardwareScalingLevel(1 / Math.min(window.devicePixelRatio || 1, 2));

    const IS_MOBILE = window.innerWidth <= 768;
    const SCALE = IS_MOBILE ? 0.45 : 0.5;

    // ××™×“×¢ ×¢×œ ×”××“×¨×’×•×ª
    let stepsInfo = null;

    const CAPACITY = 10;
    const ITEMS = [
      { name: "ğŸ”© ×× ×•×¢ ×¡×¨×•×•",   weight: 4, value: 9,  color: new BABYLON.Color3(0.98, 0.54, 0.20), type: "servo" },
      { name: "ğŸ”¦ ×—×™×™×©×Ÿ ×œ×™×™×–×¨", weight: 2, value: 6,  color: new BABYLON.Color3(0.11, 0.80, 0.98), type: "laser" },
      { name: "ğŸ“¦ ×‘×§×¨ PLC",     weight: 3, value: 7,  color: new BABYLON.Color3(0.63, 0.40, 0.98), type: "plc" },
      { name: "ğŸ¤– ××•×“×•×œ ×–×¨×•×¢",   weight: 5, value: 10, color: new BABYLON.Color3(1.00, 0.84, 0.15), type: "robotArm" },
      { name: "ğŸ“· ××¦×œ××ª QC",    weight: 1, value: 3,  color: new BABYLON.Color3(0.30, 0.88, 0.53), type: "camera" },
      { name: "ğŸ“¡ ××•×“×•×œ RFID",  weight: 2, value: 5,  color: new BABYLON.Color3(0.36, 0.69, 1.00), type: "rfid" }
    ];

    let scene, camera, ui;
    let backpackBase;
    let itemRoots = [];
    let backpackSlots = [];
    let currentWeight = 0;
    let currentValue  = 0;
    let bestPossibleValue = 0;

    // ×”×—×–×¨×ª ×”×¡××•× ×“ ×”××§×•×¨×™
    const moveAudio = new Audio("transition-sfx-whoosh-sound-effect-407576.mp3");
    
    function playMoveSfx() {
      try { moveAudio.currentTime = 0; moveAudio.play(); } catch (e) {}
    }

    const capacityEl   = document.getElementById("capacity");
    const weightEl     = document.getElementById("weight");
    const valueEl      = document.getElementById("value");
    const msgEl        = document.getElementById("message");
    const checkBtn     = document.getElementById("checkBtn");
    const hintBtn      = document.getElementById("hintBtn");
    const helpBtn      = document.getElementById("helpBtn");
    const exitBtn      = document.getElementById("exitBtn");
    const howToOverlay = document.getElementById("howToOverlay");
    const closeOverlay = document.getElementById("closeOverlay");

    capacityEl.textContent = "×§×™×‘×•×œ×ª: " + CAPACITY;

    // ××¡×š ××œ× ××•×‘×™×™×œ
    function goFullscreen() {
      const elem = document.documentElement;
      if (!document.fullscreenElement) {
        if (elem.requestFullscreen) {
          elem.requestFullscreen().catch(() => {});
        } else if (elem.webkitRequestFullscreen) {
          elem.webkitRequestFullscreen();
        } else if (elem.msRequestFullscreen) {
          elem.msRequestFullscreen();
        }
      }
      setTimeout(() => {
        window.scrollTo(0, 1);
        document.body.style.height = window.innerHeight + 'px';
      }, 100);
    }

    document.addEventListener("pointerdown", () => {
      exitBtn.classList.add("visible");
      goFullscreen();
    }, { once: true });

    let lastHeight = window.innerHeight;
    window.addEventListener('resize', () => {
      if (window.innerHeight !== lastHeight) {
        lastHeight = window.innerHeight;
        document.body.style.height = window.innerHeight + 'px';
        goFullscreen();
      }
    });

    exitBtn.addEventListener("click", () => {
      const ok = confirm("×œ×™×¦×™××” ××”××©×—×§ ×¡×’×•×¨ ××ª ×”×œ×©×•× ×™×ª ××• ×—×–×•×¨ ××—×•×¨×” ×‘×“×¤×“×¤×Ÿ.\n\n×”×× ×œ×—×–×•×¨ ××—×•×¨×” ×¢×›×©×™×•?");
      if (ok) window.history.back();
    });

    helpBtn.addEventListener("click", () => {
      howToOverlay.classList.remove("hidden");
    });
    closeOverlay.addEventListener("click", () => {
      howToOverlay.classList.add("hidden");
    });

    // ×›×¤×ª×•×¨ ×¨××– ××©×•×¤×¨ - ××¨××” ××” ×œ×”×•×¡×™×£ ××• ××” ×œ×”×•×¦×™×
    hintBtn.addEventListener("click", () => {
      // ×—×™×©×•×‘ ×”×¤×ª×¨×•×Ÿ ×”××•×¤×˜×™××œ×™
      const n = ITEMS.length;
      let bestMask = 0;
      let bestValue = 0;
      
      for (let mask = 0; mask < (1 << n); mask++) {
        let w = 0, v = 0;
        for (let i = 0; i < n; i++) {
          if (mask & (1 << i)) {
            w += ITEMS[i].weight;
            v += ITEMS[i].value;
          }
        }
        if (w <= CAPACITY && v > bestValue) {
          bestValue = v;
          bestMask = mask;
        }
      }

      // ××¢×¨×š ×©×œ ×©×™× ×•×™×™× ××•××œ×¦×™×
      let itemsToAdd = [];
      let itemsToRemove = [];
      
      for (let i = 0; i < n; i++) {
        const shouldBeSelected = (bestMask & (1 << i)) !== 0;
        const isSelected = itemRoots[i].metadata.selected;
        
        if (shouldBeSelected && !isSelected) {
          itemsToAdd.push(ITEMS[i].name);
        }
        if (!shouldBeSelected && isSelected) {
          itemsToRemove.push(ITEMS[i].name);
        }
      }
      
      // ×‘× ×™×™×ª ×”×•×“×¢×ª ×”×¨××–
      let hintText = "";
      
      if (itemsToRemove.length > 0 && itemsToAdd.length > 0) {
        // ×¦×¨×™×š ×’× ×œ×”×•×¡×™×£ ×•×’× ×œ×”×•×¦×™×
        hintText = `ğŸ’¡ ×¨××–: ×”×•×¦× "${itemsToRemove[0]}" ×•×”×•×¡×£ "${itemsToAdd[0]}"`;
      } else if (itemsToRemove.length > 0) {
        // ×¨×§ ×¦×¨×™×š ×œ×”×•×¦×™×
        hintText = `ğŸ’¡ ×¨××–: ×”×•×¦× ××ª "${itemsToRemove[0]}" ××”××¨×’×–!`;
      } else if (itemsToAdd.length > 0) {
        // ×¨×§ ×¦×¨×™×š ×œ×”×•×¡×™×£
        hintText = `ğŸ’¡ ×¨××–: ×”×•×¡×£ ××ª "${itemsToAdd[0]}" ×œ××¨×’×–!`;
      } else {
        // ×¤×ª×¨×•×Ÿ ××•×©×œ×!
        hintText = "ğŸ‰ ××ª×” ×›×‘×¨ ×‘×¤×ª×¨×•×Ÿ ×”××•×¤×˜×™××œ×™! ××¢×•×œ×”!";
      }
      
      msgEl.textContent = hintText;
      msgEl.style.color = "white";
    });

    function computeOptimalValue() {
      const n = ITEMS.length;
      let best = 0;
      for (let mask = 0; mask < (1 << n); mask++) {
        let w = 0, v = 0;
        for (let i = 0; i < n; i++) {
          if (mask & (1 << i)) {
            w += ITEMS[i].weight;
            v += ITEMS[i].value;
          }
        }
        if (w <= CAPACITY && v > best) best = v;
      }
      return best;
    }

    function fitCanvasToWindow() {
      canvas.style.width  = window.innerWidth + "px";
      canvas.style.height = window.innerHeight + "px";
      engine.resize();
    }

    function createScene() {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3(0.95, 0.97, 0.99);

      const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
      hemi.intensity = 1.0;
      const dir = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-0.5, -1, -0.3), scene);
      dir.intensity = 0.6;

      const baseRadius = IS_MOBILE ? 32 * SCALE : 24 * SCALE;
      camera = new BABYLON.ArcRotateCamera(
        "camera",
        BABYLON.Tools.ToRadians(90),
        BABYLON.Tools.ToRadians(65),
        baseRadius,
        new BABYLON.Vector3(-2 * SCALE, 3.2 * SCALE, 0),
        scene
      );
      camera.attachControl(canvas, true);
      camera.inputs.clear();
      camera.lowerRadiusLimit = baseRadius;
      camera.upperRadiusLimit = baseRadius;
      camera.lowerBetaLimit   = camera.beta;
      camera.upperBetaLimit   = camera.beta;
      camera.panningSensibility = 0;

      ui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

      createEnvironment(scene);
      createBackpack(scene);
      createItems(scene);
      setupPicking(scene);

      return scene;
    }

    function createEnvironment(scene) {
      // ×¨×¦×¤×” ×¢× ×˜×§×¡×˜×•×¨×” ×‘×”×™×¨×” ×•××•×“×¨× ×™×ª
      const ground = BABYLON.MeshBuilder.CreateGround("ground", {
        width: 44 * SCALE,
        height: 30 * SCALE
      }, scene);
      const gMat = new BABYLON.StandardMaterial("gMat", scene);
      const lightFloorTex = new BABYLON.Texture("https://assets.babylonjs.com/environments/backgroundGround.png", scene);
      lightFloorTex.uScale = 3;
      lightFloorTex.vScale = 2;
      gMat.diffuseTexture = lightFloorTex;
      gMat.diffuseColor = new BABYLON.Color3(0.98, 0.98, 1);
      gMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.6);
      ground.material = gMat;
      ground.isPickable = false;

      // ×¤×¡×™× ×–×•×”×¨×™× ×¢×“×™× ×™×
      for (let i = -2; i <= 2; i++) {
        const stripe = BABYLON.MeshBuilder.CreateBox("stripe" + i, {
          width: 44 * SCALE,
          height: 0.02 * SCALE,
          depth: 0.12 * SCALE
        }, scene);
        stripe.position = new BABYLON.Vector3(0, 0.01 * SCALE, i * 3 * SCALE);
        const sMat = new BABYLON.StandardMaterial("sMat" + i, scene);
        sMat.emissiveColor = new BABYLON.Color3(0.5, 0.75, 1);
        sMat.alpha = 0.3;
        stripe.material = sMat;
        stripe.isPickable = false;
      }

      // ×§×™×¨ ×‘×”×™×¨ ×•××•×“×¨× ×™
      const wall = BABYLON.MeshBuilder.CreateBox("wall", {
        width: 44 * SCALE,
        height: 12 * SCALE,
        depth: 0.4 * SCALE
      }, scene);
      wall.position = new BABYLON.Vector3(0, 6 * SCALE, -9 * SCALE);
      const wMat = new BABYLON.StandardMaterial("wMat", scene);
      wMat.diffuseColor = new BABYLON.Color3(0.96, 0.97, 0.99);
      wMat.specularColor = new BABYLON.Color3(0.8, 0.8, 0.85);
      wall.material = wMat;
      wall.isPickable = false;

      const ledStrip = BABYLON.MeshBuilder.CreateBox("ledStrip", {
        width: 38 * SCALE,
        height: 0.3 * SCALE,
        depth: 0.1 * SCALE
      }, scene);
      ledStrip.position = new BABYLON.Vector3(0, 9 * SCALE, -8.8 * SCALE);
      const ledMat = new BABYLON.StandardMaterial("ledMat", scene);
      ledMat.emissiveColor = new BABYLON.Color3(0.4, 0.85, 1);
      ledStrip.material = ledMat;
      ledStrip.isPickable = false;

      // ×©×•×œ×—×Ÿ ×¢× ×˜×§×¡×˜×•×¨×ª ×¢×¥ ×‘×”×™×¨×” ×•××•×“×¨× ×™×ª
      const tableTop = BABYLON.MeshBuilder.CreateBox("tableTop", {
        width: 30 * SCALE,
        depth: 12 * SCALE,
        height: 0.5 * SCALE
      }, scene);

      const tableY = 2.4 * SCALE;
      tableTop.position.y = tableY;
      const tMat = new BABYLON.StandardMaterial("tMat", scene);
      const lightWoodTex = new BABYLON.Texture("https://assets.babylonjs.com/environments/valleygrass.png", scene);
      lightWoodTex.uScale = 2;
      lightWoodTex.vScale = 1.5;
      tMat.diffuseTexture = lightWoodTex;
      tMat.diffuseColor = new BABYLON.Color3(0.95, 0.93, 0.88);
      tMat.specularColor = new BABYLON.Color3(0.8, 0.8, 0.85);
      tableTop.material = tMat;
      tableTop.isPickable = false;

      // ×¨×’×œ×™ ×”×©×•×œ×—×Ÿ
      for (let sx of [-1, 1]) {
        for (let sz of [-1, 1]) {
          const leg = BABYLON.MeshBuilder.CreateBox("leg", {
            width: 0.7 * SCALE,
            depth: 0.7 * SCALE,
            height: 2.4 * SCALE
          }, scene);
          leg.position = new BABYLON.Vector3(
            sx * 13.5 * SCALE,
            1.2 * SCALE,
            sz * 5.5 * SCALE
          );
          leg.material = tMat;
          leg.isPickable = false;
        }
      }

      // ===== ××“×¨×’×•×ª - ××“×¨×’×” ×©× ×™×™×” ×’×‘×•×”×” ×™×•×ª×¨ =====
      const itemsCenterX = -5 * SCALE;

      const stepMat = new BABYLON.StandardMaterial("stepMat", scene);
      stepMat.diffuseColor = new BABYLON.Color3(0.92, 0.94, 0.98);
      stepMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.95);

      const lowHeight = 0.35 * SCALE;
      const lowDepth  = 3.5 * SCALE;
      const width     = 18 * SCALE;

      // ××“×¨×’×” × ××•×›×”
      const stepLow = BABYLON.MeshBuilder.CreateBox("stepLow", {
        width,
        depth: lowDepth,
        height: lowHeight
      }, scene);
      stepLow.position = new BABYLON.Vector3(
        itemsCenterX,
        tableY + 0.25 * SCALE + lowHeight / 2,
        2.5 * SCALE
      );
      stepLow.material = stepMat;
      stepLow.isPickable = false;

      // ××“×¨×’×” ×’×‘×•×”×” - ×”×¨×‘×” ×™×•×ª×¨ ×’×‘×•×”×” ×›××• ××“×£
      const highHeight = 0.85 * SCALE;  // ×”×’×‘×”×” ××©××¢×•×ª×™×ª!
      const highDepth  = 5.2 * SCALE;

      const stepHigh = BABYLON.MeshBuilder.CreateBox("stepHigh", {
        width,
        depth: highDepth,
        height: highHeight
      }, scene);
      stepHigh.position = new BABYLON.Vector3(
        itemsCenterX,
        stepLow.position.y + lowHeight / 2 + 0.4 * SCALE + highHeight / 2,  // ××¨×•×•×— ×’×“×•×œ ×™×•×ª×¨
        -2.5 * SCALE
      );
      stepHigh.material = stepMat;
      stepHigh.isPickable = false;

      stepsInfo = {
        lowTopY:  stepLow.position.y + lowHeight / 2 + 0.1 * SCALE,
        highTopY: stepHigh.position.y + highHeight / 2 + 0.1 * SCALE,
        lowZ:     stepLow.position.z,
        highZ:    stepHigh.position.z,
        itemsCenterX
      };
    }

    function createBackpack(scene) {
      backpackBase = BABYLON.MeshBuilder.CreateBox("backpackBase", {
        width: 7 * SCALE,
        height: 0.5 * SCALE,
        depth: 5 * SCALE
      }, scene);
      backpackBase.position = new BABYLON.Vector3(11 * SCALE, 2.65 * SCALE, 0);
      const baseMat = new BABYLON.StandardMaterial("baseMat", scene);
      baseMat.diffuseColor = new BABYLON.Color3(0.85, 0.90, 0.97);
      baseMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.95);
      backpackBase.material = baseMat;
      backpackBase.isPickable = false;

      const body = BABYLON.MeshBuilder.CreateCylinder("packBody", {
        diameter: 7 * SCALE,
        height: 3.2 * SCALE,
        tessellation: 32
      }, scene);
      body.scaling.z = 0.7;
      body.position = backpackBase.position.add(new BABYLON.Vector3(0, 1.8 * SCALE, 0.1 * SCALE));
      const bodyMat = new BABYLON.StandardMaterial("bodyMat", scene);
      bodyMat.diffuseColor = new BABYLON.Color3(0.45, 0.62, 0.93);
      bodyMat.alpha = 0.55;
      body.material = bodyMat;
      body.isPickable = false;

      const lid = BABYLON.MeshBuilder.CreateCylinder("packLid", {
        diameter: 7 * SCALE,
        height: 0.4 * SCALE,
        tessellation: 32
      }, scene);
      lid.scaling.z = 0.7;
      lid.position = backpackBase.position.add(new BABYLON.Vector3(0, 3.3 * SCALE, 0.2 * SCALE));
      const lidMat = new BABYLON.StandardMaterial("lidMat", scene);
      lidMat.diffuseColor = new BABYLON.Color3(0.35, 0.52, 0.88);
      lid.material = lidMat;
      lid.isPickable = false;

      const handle = BABYLON.MeshBuilder.CreateTorus("handle", {
        diameter: 3 * SCALE,
        thickness: 0.3 * SCALE,
        tessellation: 32
      }, scene);
      handle.position = backpackBase.position.add(new BABYLON.Vector3(0, 3.9 * SCALE, 2 * SCALE));
      const handleMat = new BABYLON.StandardMaterial("handleMat", scene);
      handleMat.diffuseColor = new BABYLON.Color3(0.95, 0.95, 1);
      handleMat.specularColor = new BABYLON.Color3(0.9, 0.9, 1);
      handle.material = handleMat;
      handle.isPickable = false;

      const center = backpackBase.position.add(new BABYLON.Vector3(0, 0.6 * SCALE, 0));
      const dx = 2.2 * SCALE;

      for (let row = 0; row < 2; row++) {
        for (let col = 0; col < 3; col++) {
          const pos = new BABYLON.Vector3(
            center.x + (col - 1) * dx,
            center.y + row * 1.3 * SCALE,
            center.z + (row === 0 ? 0.6 * SCALE : -0.6 * SCALE)
          );
          backpackSlots.push(pos);

          const slot = BABYLON.MeshBuilder.CreateBox("slotViz", {
            width: 1.9 * SCALE,
            height: 0.03 * SCALE,
            depth: 1.3 * SCALE
          }, scene);
          slot.position = new BABYLON.Vector3(pos.x, backpackBase.position.y + 0.01 * SCALE, pos.z);
          const sMat = new BABYLON.StandardMaterial("slotMat", scene);
          sMat.diffuseColor = new BABYLON.Color3(0.7, 0.85, 1);
          sMat.alpha = 0.45;
          slot.material = sMat;
          slot.isPickable = false;
        }
      }

      const rect = new BABYLON.GUI.Rectangle();
      rect.width = IS_MOBILE ? "130px" : "140px";
      rect.height = "34px";
      rect.thickness = 0;
      rect.cornerRadius = 17;
      rect.background = "rgba(255,255,255,0.96)";
      ui.addControl(rect);
      rect.linkWithMesh(backpackBase);
      rect.linkOffsetY = -42;

      const txt = new BABYLON.GUI.TextBlock();
      txt.text = "ğŸ’ ××¨×’×– ×¦×™×•×“ ×ª×¢×©×™×™×ª×™";
      txt.color = "#1a237e";
      txt.fontSize = IS_MOBILE ? 13 : 14;
      txt.fontFamily = "Heebo";
      rect.addControl(txt);
    }

    function createItems(scene) {
      itemRoots = [];

      const startX = stepsInfo.itemsCenterX - 5 * SCALE;
      const gapX   = 5 * SCALE;

      const rowY = [stepsInfo.lowTopY, stepsInfo.highTopY];
      const rowZ = [stepsInfo.lowZ, stepsInfo.highZ];

      ITEMS.forEach((item, i) => {
        const row = i < 3 ? 0 : 1;
        const col = i % 3;

        const root = new BABYLON.TransformNode("itemRoot_" + i, scene);
        root.position = new BABYLON.Vector3(
          startX + col * gapX,
          rowY[row],
          rowZ[row]
        );

        buildItemModel(scene, root, item);

        root.metadata = {
          type: "itemRoot",
          index: i,
          selected: false,
          basePosition: root.position.clone(),
          slotIndex: null
        };

        const rect = new BABYLON.GUI.Rectangle();
        rect.width = IS_MOBILE ? "120px" : "150px";
        rect.height = IS_MOBILE ? "36px" : "44px";
        rect.thickness = 0;
        rect.cornerRadius = 14;
        rect.background = "rgba(255,255,255,0.95)";
        rect.alpha = 0.98;
        rect.isPointerBlocker = false;
        ui.addControl(rect);
        rect.linkWithMesh(root);
        rect.linkOffsetY = row === 0 ? -55 : -65;  // ×§×¦×ª ×™×•×ª×¨ ×’×‘×•×” ×›×“×™ ×©×”-HUD ×œ× ×™×¡×ª×™×¨

        const lbl = new BABYLON.GUI.TextBlock();
        lbl.text = `${item.name}\n××©×§×œ: ${item.weight} | ×¢×¨×š: ${item.value}`;
        lbl.fontFamily = "Heebo";
        lbl.color = "#263238";
        lbl.fontSize = IS_MOBILE ? 10 : 12;
        lbl.textWrapping = true;
        rect.addControl(lbl);

        itemRoots.push(root);
      });
    }

    function buildItemModel(scene, root, item) {
      const col = item.color;

      // ×—×•××¨ ××ª×›×ª ××©×•×¤×¨ - ×™×•×ª×¨ ×××™×ª×™
      const metalMat = new BABYLON.StandardMaterial("metalMat_" + item.type, scene);
      metalMat.diffuseColor = new BABYLON.Color3(0.25, 0.27, 0.30);
      metalMat.specularColor = new BABYLON.Color3(1, 1, 1);
      metalMat.specularPower = 128;

      if (item.type === "servo") {
        const base = BABYLON.MeshBuilder.CreateBox("servoBase", {
          width: 1.8 * SCALE,
          height: 0.6 * SCALE,
          depth: 1.4 * SCALE
        }, scene);
        base.parent = root;
        base.position.y = 0.3 * SCALE;
        base.material = metalMat;

        const body = BABYLON.MeshBuilder.CreateBox("servoBody", {
          width: 1.5 * SCALE,
          height: 0.9 * SCALE,
          depth: 1.1 * SCALE
        }, scene);
        body.parent = root;
        body.position.y = 0.9 * SCALE;
        const bodyMat = new BABYLON.StandardMaterial("servoBodyMat", scene);
        bodyMat.diffuseColor = col;
        bodyMat.specularColor = new BABYLON.Color3(1, 1, 1);
        bodyMat.specularPower = 64;
        body.material = bodyMat;

        const shaft = BABYLON.MeshBuilder.CreateCylinder("servoShaft", {
          diameter: 0.35 * SCALE,
          height: 0.4 * SCALE
        }, scene);
        shaft.parent = root;
        shaft.position = new BABYLON.Vector3(0, 1.4 * SCALE, 0);
        const shaftMat = new BABYLON.StandardMaterial("shaftMat", scene);
        shaftMat.diffuseColor = new BABYLON.Color3(0.95, 0.95, 0.98);
        shaftMat.specularColor = new BABYLON.Color3(1, 1, 1);
        shaftMat.specularPower = 128;
        shaft.material = shaftMat;

        const horn = BABYLON.MeshBuilder.CreateBox("servoHorn", {
          width: 1.6 * SCALE,
          height: 0.12 * SCALE,
          depth: 0.35 * SCALE
        }, scene);
        horn.parent = root;
        horn.position = new BABYLON.Vector3(0, 1.55 * SCALE, 0);
        horn.material = shaftMat;

      } else if (item.type === "laser") {
        const body = BABYLON.MeshBuilder.CreateBox("laserBody", {
          width: 1.6 * SCALE,
          height: 0.7 * SCALE,
          depth: 1.1 * SCALE
        }, scene);
        body.parent = root;
        body.position.y = 0.35 * SCALE;
        const bodyMat = new BABYLON.StandardMaterial("laserBodyMat", scene);
        bodyMat.diffuseColor = col;
        bodyMat.specularColor = new BABYLON.Color3(0.9, 0.9, 1);
        bodyMat.specularPower = 64;
        body.material = bodyMat;

        const lens = BABYLON.MeshBuilder.CreateCylinder("laserLens", {
          diameter: 0.6 * SCALE,
          height: 0.35 * SCALE,
          tessellation: 24
        }, scene);
        lens.parent = root;
        lens.position.z = 0.7 * SCALE;
        lens.position.y = 0.35 * SCALE;
        const lensMat = new BABYLON.StandardMaterial("lensMat", scene);
        lensMat.diffuseColor = new BABYLON.Color3(0.2, 0.6, 1);
        lensMat.emissiveColor = new BABYLON.Color3(0.15, 0.8, 1);
        lensMat.specularColor = new BABYLON.Color3(1, 1, 1);
        lensMat.specularPower = 128;
        lens.material = lensMat;

        const bracket = BABYLON.MeshBuilder.CreateBox("laserBracket", {
          width: 0.8 * SCALE,
          height: 0.2 * SCALE,
          depth: 1.2 * SCALE
        }, scene);
        bracket.parent = root;
        bracket.position.y = 0.1 * SCALE;
        bracket.material = metalMat;

      } else if (item.type === "plc") {
        const rack = BABYLON.MeshBuilder.CreateBox("plcRack", {
          width: 2.4 * SCALE,
          height: 1.4 * SCALE,
          depth: 0.9 * SCALE
        }, scene);
        rack.parent = root;
        rack.position.y = 0.8 * SCALE;
        rack.material = metalMat;

        for (let i = 0; i < 4; i++) {
          const mod = BABYLON.MeshBuilder.CreateBox("plcMod" + i, {
            width: 0.5 * SCALE,
            height: 1.1 * SCALE,
            depth: 0.7 * SCALE
          }, scene);
          mod.parent = root;
          mod.position = new BABYLON.Vector3(
            -0.75 * SCALE + i * 0.5 * SCALE,
            0.85 * SCALE,
            0
          );
          const mMat = new BABYLON.StandardMaterial("plcModMat" + i, scene);
          mMat.diffuseColor = new BABYLON.Color3(0.45 + 0.08 * i, 0.55, 0.75);
          mMat.specularColor = new BABYLON.Color3(0.9, 0.9, 1);
          mMat.specularPower = 64;
          mod.material = mMat;

          // LED ××™× ×“×™×§×˜×•×¨×™×
          const led = BABYLON.MeshBuilder.CreateSphere("led" + i, {
            diameter: 0.08 * SCALE
          }, scene);
          led.parent = root;
          led.position = new BABYLON.Vector3(
            -0.75 * SCALE + i * 0.5 * SCALE,
            1.35 * SCALE,
            0.4 * SCALE
          );
          const ledMat = new BABYLON.StandardMaterial("ledMat" + i, scene);
          ledMat.emissiveColor = i % 2 === 0 ? new BABYLON.Color3(0, 1, 0) : new BABYLON.Color3(1, 0.3, 0);
          led.material = ledMat;
        }

      } else if (item.type === "robotArm") {
        const base = BABYLON.MeshBuilder.CreateCylinder("armBase", {
          diameter: 1.3 * SCALE,
          height: 0.4 * SCALE
        }, scene);
        base.parent = root;
        base.position.y = 0.2 * SCALE;
        base.material = metalMat;

        const joint1 = BABYLON.MeshBuilder.CreateCylinder("joint1", {
          diameter: 0.9 * SCALE,
          height: 0.6 * SCALE
        }, scene);
        joint1.parent = root;
        joint1.position.y = 0.7 * SCALE;
        const jMat = new BABYLON.StandardMaterial("jMat", scene);
        jMat.diffuseColor = col;
        jMat.specularColor = new BABYLON.Color3(1, 1, 0.95);
        jMat.specularPower = 64;
        joint1.material = jMat;

        const arm1 = BABYLON.MeshBuilder.CreateBox("arm1", {
          width: 0.4 * SCALE,
          height: 1.6 * SCALE,
          depth: 0.4 * SCALE
        }, scene);
        arm1.parent = root;
        arm1.position = new BABYLON.Vector3(0, 1.6 * SCALE, 0.2 * SCALE);
        arm1.rotation.z = -0.3;
        arm1.material = jMat;

        const joint2 = BABYLON.MeshBuilder.CreateSphere("joint2", {
          diameter: 0.6 * SCALE
        }, scene);
        joint2.parent = root;
        joint2.position = new BABYLON.Vector3(0.3 * SCALE, 2.2 * SCALE, 0.4 * SCALE);
        joint2.material = jMat;

        const arm2 = BABYLON.MeshBuilder.CreateBox("arm2", {
          width: 0.35 * SCALE,
          height: 1.2 * SCALE,
          depth: 0.35 * SCALE
        }, scene);
        arm2.parent = root;
        arm2.position = new BABYLON.Vector3(0.4 * SCALE, 2.7 * SCALE, 0.7 * SCALE);
        arm2.rotation.z = 0.4;
        arm2.material = jMat;

        const gripper = BABYLON.MeshBuilder.CreateBox("gripper", {
          width: 0.7 * SCALE,
          height: 0.2 * SCALE,
          depth: 0.5 * SCALE
        }, scene);
        gripper.parent = root;
        gripper.position = new BABYLON.Vector3(0.6 * SCALE, 3.3 * SCALE, 0.9 * SCALE);
        gripper.material = metalMat;

      } else if (item.type === "camera") {
        const body = BABYLON.MeshBuilder.CreateBox("camBody", {
          width: 1.6 * SCALE,
          height: 0.9 * SCALE,
          depth: 0.9 * SCALE
        }, scene);
        body.parent = root;
        body.position.y = 0.45 * SCALE;
        body.material = metalMat;

        const lens = BABYLON.MeshBuilder.CreateCylinder("camLens", {
          diameter: 0.7 * SCALE,
          height: 0.6 * SCALE,
          tessellation: 24
        }, scene);
        lens.parent = root;
        lens.position.z = 0.7 * SCALE;
        lens.position.y = 0.45 * SCALE;
        const lMat = new BABYLON.StandardMaterial("camLensMat", scene);
        lMat.diffuseColor = new BABYLON.Color3(0.2, 0.6, 1);
        lMat.emissiveColor = new BABYLON.Color3(0.1, 0.7, 1);
        lMat.specularColor = new BABYLON.Color3(1, 1, 1);
        lMat.specularPower = 128;
        lens.material = lMat;

        const mount = BABYLON.MeshBuilder.CreateBox("camMount", {
          width: 0.8 * SCALE,
          height: 0.2 * SCALE,
          depth: 1.2 * SCALE
        }, scene);
        mount.parent = root;
        mount.position.y = 0.15 * SCALE;
        mount.material = metalMat;

      } else if (item.type === "rfid") {
        const body = BABYLON.MeshBuilder.CreateBox("rfidBody", {
          width: 1.9 * SCALE,
          height: 0.4 * SCALE,
          depth: 1.5 * SCALE
        }, scene);
        body.parent = root;
        body.position.y = 0.2 * SCALE;
        const bMat = new BABYLON.StandardMaterial("rfidMat", scene);
        bMat.diffuseColor = col;
        bMat.specularColor = new BABYLON.Color3(0.9, 0.9, 1);
        bMat.specularPower = 64;
        body.material = bMat;

        const frame = BABYLON.MeshBuilder.CreateTorus("rfidFrame", {
          diameter: 1.3 * SCALE,
          thickness: 0.1 * SCALE,
          tessellation: 32
        }, scene);
        frame.parent = root;
        frame.rotation.x = Math.PI / 2;
        frame.position.y = 0.5 * SCALE;
        const fMat = new BABYLON.StandardMaterial("rfidFrameMat", scene);
        fMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
        fMat.specularColor = new BABYLON.Color3(1, 1, 1);
        fMat.specularPower = 128;
        frame.material = fMat;
      }
    }

    function setupPicking(scene) {
      scene.onPointerDown = (evt, pickResult) => {
        if (!pickResult || !pickResult.hit || !pickResult.pickedMesh) return;

        let node = pickResult.pickedMesh;
        while (node && (!node.metadata || node.metadata.type !== "itemRoot")) {
          node = node.parent;
        }
        if (!node || !node.metadata) return;

        toggleItem(node);
      };

      checkBtn.addEventListener("click", checkSolution);
    }

    function moveNodeTo(node, newPos) {
      const from = node.position.clone();
      const to = newPos.clone();

      const anim = new BABYLON.Animation(
        "moveAnim_" + node.name,
        "position",
        60,
        BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
        BABYLON.AnimationLOOPMODE_CONSTANT
      );

      const keys = [
        { frame: 0,  value: from },
        { frame: 45, value: to }
      ];
      anim.setKeys(keys);

      node.animations = [anim];
      node.getScene().beginAnimation(node, 0, 45, false);
    }

    function toggleItem(root) {
      const idx = root.metadata.index;
      const item = ITEMS[idx];

      if (!root.metadata.selected) {
        root.metadata.selected = true;
        currentWeight += item.weight;
        currentValue  += item.value;

        let freeIndex = null;
        for (let i = 0; i < backpackSlots.length; i++) {
          let taken = false;
          for (const n of itemRoots) {
            if (n.metadata.selected && n.metadata.slotIndex === i) { taken = true; break; }
          }
          if (!taken) { freeIndex = i; break; }
        }

        if (freeIndex === null) {
          root.metadata.selected = false;
          currentWeight -= item.weight;
          currentValue  -= item.value;
          msgEl.textContent = "×”××¨×’×– ××œ× ×¤×™×–×™×ª â€“ ×©×—×¨×¨ ××•×¦×¨ ××—×“ ×›×“×™ ×œ×¤× ×•×ª ××§×•×.";
          msgEl.style.color = "#e53935";
        } else {
          root.metadata.slotIndex = freeIndex;
          moveNodeTo(root, backpackSlots[freeIndex]);
          playMoveSfx();
        }

      } else {
        root.metadata.selected = false;
        currentWeight -= item.weight;
        currentValue  -= item.value;
        root.metadata.slotIndex = null;
        moveNodeTo(root, root.metadata.basePosition.clone());
        playMoveSfx();
      }

      updateHUD();
    }

    function updateHUD() {
      weightEl.textContent = "××©×§×œ × ×•×›×—×™: " + currentWeight;
      valueEl.textContent  = "×¢×¨×š × ×•×›×—×™: " + currentValue;

      if (currentWeight > CAPACITY) {
        weightEl.style.color = "#ffeb3b";
        msgEl.textContent = "âš  ×”××¨×’×– ×›×¨×’×¢ ×—×•×¨×’ ××”×§×™×‘×•×œ×ª â€“ ×©×—×¨×¨ ××•×¦×¨ ××• ×©× ×™×™× ×•×ª× ×¡×” ×§×•××‘×™× ×¦×™×” ××—×¨×ª.";
        msgEl.style.color = "#ffeb3b";
      } else {
        weightEl.style.color = "white";
        msgEl.textContent = "×œ×—×¥ ×¢×œ ××•×¦×¨×™× ×›×“×™ ×œ×”×•×¡×™×£ / ×œ×”×•×¦×™×. × ×¡×” ×œ×”×’×™×¢ ×œ×¢×¨×š ×”×›×™ ×’×‘×•×” ×‘×œ×™ ×œ×—×¨×•×’ ××”×§×™×‘×•×œ×ª.";
        msgEl.style.color = "white";
      }
    }

    function checkSolution() {
      if (currentWeight > CAPACITY) {
        msgEl.textContent = "×”××©×§×œ ×¢×“×™×™×Ÿ ×—×•×¨×’ ××”×§×™×‘×•×œ×ª â€“ ×§×•×“× ×ª××–×Ÿ ××ª ×”××©×§×œ ×•××– ×‘×“×•×§ ×©×•×‘.";
        msgEl.style.color = "#ffeb3b";
        return;
      }

      const diff = bestPossibleValue - currentValue;

      if (diff === 0) {
        msgEl.textContent = "ğŸ‰ ×‘×•×¡ ×©×œ ×”×œ×•×’×™×¡×˜×™×§×”! ×”×’×¢×ª ×œ×¤×ª×¨×•×Ÿ ××•×¤×˜×™××œ×™ â€“ ××™×Ÿ ×§×•××‘×™× ×¦×™×” ×˜×•×‘×” ×™×•×ª×¨.";
        msgEl.style.color = "#76ff03";
      } else if (diff <= 2) {
        msgEl.textContent = "ğŸ‘ ××ª×” ×××© ×§×¨×•×‘! ××¤×©×¨ ×œ×©×¤×¨ ×¢×•×“ ×§×¦×ª ×•×œ×”×¢×œ×•×ª ××ª ×”×¢×¨×š ×”×›×•×œ×œ ×‘-" + diff + ".";
        msgEl.style.color = "#ffeb3b";
      } else {
        msgEl.textContent = "â„¹ ×™×© ×¤×ª×¨×•×Ÿ ×˜×•×‘ ×™×•×ª×¨ â€“ ×”×¢×¨×š ×”××§×¡×™××œ×™ ×”××¤×©×¨×™ ×”×•× " + bestPossibleValue + ". × ×¡×” ×§×•××‘×™× ×¦×™×” ××—×¨×ª.";
        msgEl.style.color = "white";
      }
    }

    bestPossibleValue = computeOptimalValue();
    scene = createScene();
    fitCanvasToWindow();

    engine.runRenderLoop(() => { scene.render(); });

    window.addEventListener("resize", fitCanvasToWindow);
    window.addEventListener("orientationchange", () => {
      setTimeout(fitCanvasToWindow, 300);
    });
  </script>
</body>
</html>