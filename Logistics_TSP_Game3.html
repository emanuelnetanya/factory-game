<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <title>××©×—×§ ××¡×œ×•×œ ×œ×•×’×™×¡×˜×™ ×ª×œ×ªÖ¾××™××“×™ - TSP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Heebo:wght@300;400;500;600;700;800;900&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Heebo', sans-serif;
      overflow: hidden;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-tap-highlight-color: transparent;
    }

    #renderCanvas {
      width: 100%;
      height: 100vh;
      display: block;
      outline: none;
    }

    .ui-container {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      z-index: 100;
    }

    /* HEADER */
    .header {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      padding: 10px 22px;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border-radius: 18px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.12);
      pointer-events: auto;
      max-width: 95vw;
      width: auto;
      flex-wrap: wrap;
      transition: all 0.3s ease;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .logo-icon {
      width: 42px;
      height: 42px;
      background: linear-gradient(135deg, #3b82f6, #22c55e);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      box-shadow: 0 6px 16px rgba(37,99,235,0.35);
      flex-shrink: 0;
    }

    .logo-text h1 {
      font-size: 17px;
      font-weight: 800;
      background: linear-gradient(135deg, #667eea, #1f2937);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      white-space: nowrap;
    }

    .logo-text p {
      font-size: 11px;
      color: #888;
      font-weight: 500;
      white-space: nowrap;
    }

    .header-stats {
      display: flex;
      gap: 10px;
    }

    .stat-box {
      text-align: center;
      padding: 6px 12px;
      background: linear-gradient(135deg, #f8f9ff, #fff);
      border-radius: 12px;
      border: 1px solid rgba(102,126,234,0.15);
      min-width: 80px;
    }

    .stat-value {
      font-size: 18px;
      font-weight: 900;
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      direction: ltr;
    }

    .stat-label {
      font-size: 10px;
      color: #888;
      font-weight: 600;
    }

    .header-buttons {
      display: flex;
      gap: 8px;
    }

    .btn {
      padding: 8px 14px;
      border: none;
      border-radius: 10px;
      font-family: 'Heebo', sans-serif;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      pointer-events: auto;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }

    .btn-undo {
      background: linear-gradient(135deg, #e5e7eb, #f9fafb);
      color: #111827;
      border: 1px solid rgba(148,163,184,0.7);
    }

    .btn-reset {
      background: linear-gradient(135deg, #FF6B6B, #FF8E53);
      color: white;
      box-shadow: 0 6px 16px rgba(255,107,107,0.25);
    }

    /* Help Toggle Button (Mobile) */
    .btn-help-toggle {
      display: none; /* Hidden on desktop */
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: white;
      color: #667eea;
      border: 1px solid rgba(102,126,234,0.3);
      font-size: 18px;
      font-weight: bold;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      cursor: pointer;
      pointer-events: auto;
    }

    /* SIDE PANEL */
    .side-panel {
      position: absolute;
      top: 90px;
      right: 15px;
      width: 260px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      pointer-events: auto;
      max-height: calc(100vh - 120px);
      overflow-y: auto;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }

    .panel-card {
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.08);
    }

    .panel-title {
      font-size: 14px;
      font-weight: 800;
      color: #333;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .instructions-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .instruction-item {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      font-size: 12px;
      font-weight: 500;
      color: #374151;
      line-height: 1.4;
    }

    .instruction-num {
      width: 20px;
      height: 20px;
      background: rgba(102,126,234,0.15);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 800;
      font-size: 11px;
      color: #667eea;
      flex-shrink: 0;
    }

    .status-message {
      position: absolute;
      bottom: 25px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 24px;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border-radius: 40px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.12);
      font-size: 13px;
      font-weight: 700;
      color: #333;
      pointer-events: auto;
      width: 90%;
      max-width: 400px;
      text-align: center;
    }

    /* POPUP ×ª×•×¦××” */
    .celebration-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(10px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
      pointer-events: auto;
    }

    .celebration-overlay.show { display: flex; }

    .celebration-card {
      background: white;
      padding: 24px 26px;
      border-radius: 22px;
      text-align: center;
      box-shadow: 0 25px 60px rgba(0,0,0,0.25);
      animation: celebrationPop 0.4s ease;
      max-width: 380px;
      width: 90%;
    }

    @keyframes celebrationPop {
      0% { transform: scale(0.5); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }

    .celebration-icon { font-size: 46px; margin-bottom: 8px; }

    .celebration-title {
      font-size: 22px;
      font-weight: 900;
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 4px;
    }

    .celebration-subtitle {
      font-size: 13px;
      color: #666;
      margin-bottom: 14px;
    }

    .results-box {
      padding: 12px 14px;
      background: linear-gradient(135deg, #f8f9ff, #fff);
      border-radius: 16px;
      border: 1px solid rgba(102,126,234,0.25);
      font-size: 13px;
      text-align: right;
      direction: rtl;
    }

    .results-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
    }

    .results-label { color: #666; font-weight: 700; }
    .results-value { font-weight: 900; color: #333; direction: ltr; text-align: left; }

    .result-message {
      margin-top: 8px;
      font-weight: 700;
      font-size: 13px;
    }
    .result-message.success { color: #16a34a; }
    .result-message.fail { color: #dc2626; }

    .modal-buttons {
      margin-top: 14px;
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .modal-btn {
      padding: 9px 20px;
      border-radius: 999px;
      border: none;
      font-family: 'Heebo', sans-serif;
      font-size: 13px;
      font-weight: 800;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .modal-btn.main { background: linear-gradient(135deg, #667eea, #764ba2); color: white; }
    .modal-btn.ghost { background: transparent; color: #555; border: 1px dashed #cbd5f5; }

    /* MOBILE STYLES */
    /* MOBILE STYLES */
    @media (max-width: 768px) {
    .header {
        top: 4px;
        left: 50%;
        transform: translateX(-50%);
        width: 96%;
        max-width: none;
        padding: 6px 10px;
        gap: 6px;
        border-radius: 12px;
        flex-wrap: nowrap;              /* ×œ× ×œ×¢×˜×•×£ ×œ×©×•×¨×•×ª × ×•×¡×¤×•×ª */
        justify-content: space-between; /* ×©×•×¨×” ××—×ª ×¦×¨×” */
    }

    .logo-text { 
        display: none;                  /* ×›×‘×¨ ×”×™×” â€“ ××©××™×¨ ××•×¡×ª×¨ ×‘××•×‘×™×™×œ */
    }

    .logo-icon {
        width: 30px;
        height: 30px;
        font-size: 18px;
    }

    .header-stats {
        display: flex;
        gap: 4px;
    }

    .stat-box {
        padding: 2px 6px;
        min-width: 56px;
    }

    .stat-value { 
        font-size: 13px; 
    }

    .stat-label { 
        font-size: 9px; 
    }

    .btn {
        padding: 4px 8px;
        font-size: 11px;
    }

    /* ×”×¡×ª×¨×ª ×”×¤×× ×œ ×›×‘×¨×™×¨×ª ××—×“×œ ×•×”×•×¡×¤×ª ×›×¤×ª×•×¨ ×¢×–×¨×” */
    .side-panel {
        display: none; /* × ×¤×ª×— ×¢× JS */
        top: 70px;
        right: 10px;
        left: 10px;
        width: auto;
        z-index: 101;
        max-height: calc(100vh - 100px);
    }
        
    .side-panel.open { 
        display: flex; 
    }

    .btn-help-toggle { 
        display: flex;  /* ×”×¦×’×ª ×›×¤×ª×•×¨ ×¢×–×¨×” ×§×˜×Ÿ ×‘××§×•× ×¤×× ×œ ×§×‘×•×¢ */
    }
        
    .status-message {
        bottom: 15px;
        width: 94%;
        padding: 8px 16px;
        font-size: 12px;
    }
    }

  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <div class="ui-container">
    <!-- HEADER -->
    <div class="header">
      <div class="header-left">
        <div class="logo">
          <div class="logo-icon">ğŸšš</div>
          <div class="logo-text">
            <h1>××¡×œ×•×œ ×œ×•×’×™×¡×˜×™</h1>
            <p>××©×—×§ ×”×•×‘×œ×•×ª</p>
          </div>
        </div>
        <!-- Help Toggle for Mobile -->
        <div class="btn-help-toggle" id="helpBtn">?</div>
      </div>

      <div class="header-stats">
        <div class="stat-box">
          <div class="stat-value"><span id="currentDistance">0</span></div>
          <div class="stat-label">× ×•×›×—×™</div>
        </div>
        <div class="stat-box">
          <div class="stat-value"><span id="optimalDistanceDisplay">?</span></div>
          <div class="stat-label">×™×¢×“</div>
        </div>
      </div>

      <div class="header-buttons">
        <button class="btn btn-undo" id="btn-undo">â†©ï¸</button>
        <button class="btn btn-reset" id="btn-reset">ğŸ”„</button>
      </div>
    </div>

    <!-- SIDE PANEL -->
    <div class="side-panel" id="sidePanel">
      <div class="panel-card instructions-card">
        <div class="panel-title">ğŸ’¡ ×”×•×¨××•×ª</div>
        <div class="instructions-list">
          <div class="instruction-item">
            <div class="instruction-num">1</div>
            <div>×”×ª×—×™×œ×™ ××”××¨×œ×•×’ ×”××¨×›×–×™ (×™×¨×•×§).</div>
          </div>
          <div class="instruction-item">
            <div class="instruction-num">2</div>
            <div>×œ×—×¦×™ ×¢×œ ×¡× ×™×¤×™× ×œ×‘×—×™×¨×ª ×”××¡×œ×•×œ.</div>
          </div>
          <div class="instruction-item">
            <div class="instruction-num">3</div>
            <div>××¡×•×¨ ×œ×—×–×•×¨ ×œ××¨×œ×•×’ ×œ×¤× ×™ ×¡×™×•× ×”×¡×‘×‘.</div>
          </div>
          <div class="instruction-item">
            <div class="instruction-num">4</div>
            <div>×—×–×¨×™ ×œ××¨×œ×•×’ ×‘×¡×•×£.</div>
          </div>
        </div>
      </div>
    </div>

    <!-- STATUS -->
    <div class="status-message" id="status-message">
      ğŸ‘† ×œ×—×¦×™ ×¢×œ ×”×¡× ×™×£ ×”×¨××©×•×Ÿ ×›×“×™ ×œ×”×ª×—×™×œ
    </div>
  </div>

  <!-- POPUP ×ª×•×¦××•×ª -->
  <div class="celebration-overlay" id="resultOverlay">
    <div class="celebration-card">
      <div class="celebration-icon">ğŸ“Š</div>
      <div class="celebration-title">×¡×™×•× ×”××¡×œ×•×œ</div>
      <div class="celebration-subtitle">×ª×•×¦××•×ª</div>

      <div class="results-box">
        <div class="results-row">
          <span class="results-label">×©×œ×š:</span>
          <span class="results-value" id="modalPlayerDistance">0 ×§&quot;×</span>
        </div>
        <div class="results-row">
          <span class="results-label">××•×¤×˜×™××œ×™:</span>
          <span class="results-value" id="modalOptimalDistance">0 ×§&quot;×</span>
        </div>
        <div class="result-message" id="modalResultMessage"></div>
      </div>

      <div class="modal-buttons">
        <button class="modal-btn main" id="playAgainBtn">ğŸ” ×©×—×§ ×©×•×‘</button>
        <button class="modal-btn ghost" id="closeModalBtn">×¡×’×•×¨</button>
      </div>
    </div>
  </div>

  <script>
    (function() {
    
    // ---- × ×ª×•× ×™× ----
    const nodes = [
      { id: 0, name: "××¨×œ×•×’ ××¨×›×–×™", type: "depot",  x: 0,   z: 0 },
      { id: 1, name: "×¦×¤×•×Ÿ-××¢×¨×‘", type: "branch", x: -30, z: -25 },
      { id: 2, name: "××¨×›×– ×”×¢×™×¨", type: "branch", x: -10,   z: -60 },
      { id: 3, name: "×¦×¤×•×Ÿ-××–×¨×—", type: "branch", x: 25,  z: -22 },
      { id: 4, name: "×“×¨×•×-××¢×¨×‘", type: "branch", x: -35, z: 25 },
      { id: 5, name: "×“×¨×•×-××–×¨×—", type: "branch", x: 20,  z: 25 },
      { id: 6, name: "××–×•×¨ ×ª×¢×©×™×™×”", type: "branch", x: 45,  z: 10 },
      { id: 7, name: "×¤×¨×™×¤×¨×™×”",   type: "branch", x: 0,   z: 45 }
    ];

    const roadDefinitions = [
      { a: 0, b: 1, d: 4 }, { a: 0, b: 2, d: 5 }, { a: 0, b: 4, d: 5 },
      { a: 0, b: 5, d: 6 }, { a: 0, b: 7, d: 6 },
      { a: 1, b: 2, d: 3 }, { a: 1, b: 4, d: 4 },
      { a: 2, b: 3, d: 4 },
      //{ a: 2, b: 7, d: 3 },
      { a: 3, b: 6, d: 5 },
      //{ a: 4, b: 5, d: 3 }, 
      { a: 1, b: 3, d: 6 },
      { a: 4, b: 7, d: 4 },
      { a: 2, b: 5, d: 6 },
      { a: 5, b: 6, d: 4 }, { a: 5, b: 7, d: 3 }
    ];

    const INF = 999999;
    const N = nodes.length;
    const distances = Array.from({ length: N }, () => Array(N).fill(INF));
    const adjacency = Array.from({ length: N }, () => Array(N).fill(false));

    let visited = [];
    let playerPath = [];
    let totalDistance = 0;
    let gameOver = false;
    let isAnimating = false;
    let optimalDistance = null;

    let engine, scene, advancedTexture;
    let nodeTransforms = [];
    let truckParent;
    let playerSegments = [];

    // DOM
    let currentDistanceEl, optimalDistanceEl, statusMessageEl, undoBtn, resetBtn, resultOverlay, modalPlayerDistanceEl, modalOptimalDistanceEl, modalResultMessageEl, playAgainBtn, closeModalBtn, helpBtn, sidePanel;

    function buildGraph() {
      for (let i = 0; i < N; i++) {
        distances[i][i] = 0;
        adjacency[i][i] = false;
      }
      for (const r of roadDefinitions) {
        distances[r.a][r.b] = r.d;
        distances[r.b][r.a] = r.d;
        adjacency[r.a][r.b] = true;
        adjacency[r.b][r.a] = true;
      }
    }

    function allBranchesVisited() {
      for (let i = 1; i < N; i++) if (!visited[i]) return false;
      return true;
    }

    function computeOptimalRoute() {
      const branches = [1,2,3,4,5,6,7];
      let bestDist = INF;
      function backtrack(path) {
        if (path.length === branches.length) {
          let prev = 0;
          let d = 0;
          for (const idx of path) {
            if (!adjacency[prev][idx]) return;
            d += distances[prev][idx];
            prev = idx;
          }
          if (!adjacency[prev][0]) return;
          d += distances[prev][0];
          if (d < bestDist) bestDist = d;
          return;
        }
        for (const b of branches) {
          if (!path.includes(b)) {
            path.push(b);
            backtrack(path);
            path.pop();
          }
        }
      }
      backtrack([]);
      return bestDist;
    }

    function createScene(canvas) {
      // ×™×¦×™×¨×ª ×× ×•×¢ ×•×¡×¦× ×”
      engine = new BABYLON.Engine(canvas, true, { antialias: true });
      scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0.94, 0.96, 0.98, 1);

      // ×–×™×”×•×™ ××•×‘×™×™×œ ×œ×¤×™ ×¨×•×—×‘ ××• ×’×•×‘×” ×”××¡×š
      const isMobile = (window.innerWidth < 768) || (window.innerHeight < 700);

      // ×¤×¨××˜×¨×™× ×©×•× ×™× ×œ××•×‘×™×™×œ ×•×œ×“×¡×§×˜×•×¤
      const mobileRadius  = 250;           // ×–×•× ×‘××•×‘×™×™×œ â€“ × ×©××¨ ×›××• ×©××”×‘×ª
      const desktopRadius = 160;           // ×§×¦×ª ×§×¨×•×‘ ×™×•×ª×¨ ×‘×“×¡×§×˜×•×¤

      // beta = ×–×•×•×™×ª ×’×•×‘×”:
      // ×¢×¨×š ×’×“×•×œ ×™×•×ª×¨ (×§×¨×•×‘ ×œ- PI/2) = ×™×•×ª×¨ ××‘×˜-×¢×œ
      const mobileBeta  = Math.PI / 3.1;   // ×–×•×•×™×ª ×˜×•×‘×” ×œ××•×‘×™×™×œ
      const desktopBeta = Math.PI / 3;   // ×™×•×ª×¨ ××œ××¢×œ×” ×‘×“×¡×§×˜×•×¤ ×›×“×™ ×œ× ×œ×¨××•×ª ×”×›×œ ×‘×§×• ××—×“

      const fixedAlpha = -Math.PI / 2;     // ×›×™×•×•×Ÿ ××¦×“ "×¦×¤×•×Ÿ"
      
      const targetMobile  = new BABYLON.Vector3(0, 0, 10);
      const targetDesktop = new BABYLON.Vector3(0, 0, 8);

      const radius = isMobile ? mobileRadius : desktopRadius;
      const beta   = isMobile ? mobileBeta   : desktopBeta;
      const target = isMobile ? targetMobile : targetDesktop;

      const camera = new BABYLON.ArcRotateCamera(
        "camera",
        fixedAlpha,
        beta,
        radius,
        target,
        scene
      );

      // ğŸ”’ × ×•×¢×œ×™× ××ª ×”××¦×œ××” â€“ ××™×Ÿ ×¡×™×‘×•×‘, ××™×Ÿ ×–×•×
      camera.alpha  = fixedAlpha;
      camera.beta   = beta;
      camera.radius = radius;
      camera.target = target;

      camera.lowerAlphaLimit  = fixedAlpha;
      camera.upperAlphaLimit  = fixedAlpha;
      camera.lowerBetaLimit   = beta;
      camera.upperBetaLimit   = beta;
      camera.lowerRadiusLimit = radius;
      camera.upperRadiusLimit = radius;

      // ×œ× ××—×‘×¨×™× ×œ-attachControl ×›×“×™ ×©×œ× ×™×–×™×–×• ×¢× ×”×¢×›×‘×¨/××¦×‘×¢
      // camera.attachControl(canvas, true);

      // ×ª××•×¨×”
      const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
      hemi.intensity = 0.8;

      const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.5, -1, 0.4), scene);
      sun.position = new BABYLON.Vector3(50, 70, -50);
      sun.intensity = 0.95;

      const shadowGen = new BABYLON.ShadowGenerator(1024, sun);
      shadowGen.useBlurExponentialShadowMap = true;

      // ×§×¨×§×¢
      const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 180, height: 180 }, scene);
      const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
      groundMat.diffuseColor = new BABYLON.Color3(0.9, 0.93, 0.96);
      ground.material = groundMat;
      ground.receiveShadows = true;

      // Babylon GUI
      advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

      // ×›×‘×™×©×™×, ×¢×¦×™×, ×¡×‘×™×‘×”
      createRoads(scene);
      createEnvironment(scene, shadowGen);

      // ×™×¦×™×¨×ª ×”×¦××ª×™× (××¨×œ×•×’ + ×¡× ×™×¤×™×)
      nodes.forEach((node) => {
        if (node.type === "depot") {
          nodeTransforms[node.id] = createDepot(node, shadowGen);
        } else {
          nodeTransforms[node.id] = createBranch(node, shadowGen);
        }
      });

      // ×©×¨×˜×•×˜ ×›×œ ×”×§×©×ª×•×ª ×¢× ×”××¨×—×§×™×
      drawAllRoadEdges(scene);

      // ××©××™×ª
      truckParent = createTruckMesh(scene, shadowGen);
      setTruckToNode(0);

      // ×§×œ×™×§ ×¢×œ ×¡× ×™×£ â€“ ×¢×“×™×™×Ÿ ×¢×•×‘×“ ×›×¨×’×™×œ
      scene.onPointerDown = (evt, pickResult) => {
        if (!pickResult.hit || isAnimating || gameOver) return;

        let mesh = pickResult.pickedMesh;
        while (mesh && mesh.nodeId === undefined) {
          mesh = mesh.parent;
        }

        if (mesh && typeof mesh.nodeId === "number") {
          handleNodeClick(mesh.nodeId);
        }
      };

      return scene;
    }




    function createRoads(scene) {
      const roadMat = new BABYLON.StandardMaterial("roadMat", scene);
      roadMat.diffuseColor = new BABYLON.Color3(0.38,0.4,0.45);
      const lineMat = new BABYLON.StandardMaterial("lineMat", scene);
      lineMat.diffuseColor = new BABYLON.Color3(1,0.95,0.4);

      for (let i = -40; i <= 40; i += 20) {
        const roadH = BABYLON.MeshBuilder.CreateBox("roadH"+i, { width: 160, height: 0.05, depth: 12 }, scene);
        roadH.position.set(0,0.025,i);
        roadH.material = roadMat;
        const roadV = BABYLON.MeshBuilder.CreateBox("roadV"+i, { width: 12, height: 0.05, depth: 160 }, scene);
        roadV.position.set(i,0.025,0);
        roadV.material = roadMat;
      }
    }

    function createEnvironment(scene, shadowGen) {
      // ××•×¤×—×ª ×¢×¦×™× ×œ×‘×™×¦×•×¢×™×
      const treePositions = [[-50,-50],[50,-50],[-50,50],[50,50]];
      treePositions.forEach(([x,z]) => {
        const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk",{ height: 3.5, diameter: 0.9 },scene);
        trunk.position.set(x,1.75,z);
        const trunkMat = new BABYLON.StandardMaterial("trunkMat",scene);
        trunkMat.diffuseColor = new BABYLON.Color3(0.5,0.35,0.18);
        trunk.material = trunkMat;
        
        const leaves = BABYLON.MeshBuilder.CreateSphere("leaves",{ diameter:6, segments:4 },scene); // ×¤×—×•×ª ×¡×’×× ×˜×™×
        leaves.position.set(x,5.4,z);
        const leavesMat = new BABYLON.StandardMaterial("leavesMat",scene);
        leavesMat.diffuseColor = new BABYLON.Color3(0.35,0.72,0.38);
        leaves.material = leavesMat;
        shadowGen.addShadowCaster(leaves);
      });
    }

    function createDepot(node, shadowGen) {
      const parent = new BABYLON.TransformNode("depot_"+node.id, scene);
      parent.position = new BABYLON.Vector3(node.x,0,node.z);
      parent.nodeId = node.id;
      parent.scaling = new BABYLON.Vector3(1.4, 1.4, 1.4);


      const base = BABYLON.MeshBuilder.CreateBox("depotBase", { width:6, height:4, depth:6 }, scene);
      base.position.y = 3;
      base.parent = parent;
      const baseMat = new BABYLON.StandardMaterial("depotBaseMat",scene);
      baseMat.diffuseColor = new BABYLON.Color3(0.3,0.8,0.5);
      base.material = baseMat;
      shadowGen.addShadowCaster(base);

      addNodeLabel(parent, node.name, "#22c55e", node);
      return parent;
    }

    function createBranch(node, shadowGen) {
      const parent = new BABYLON.TransformNode("branch_"+node.id, scene);
      parent.position = new BABYLON.Vector3(node.x,0,node.z);
      parent.nodeId = node.id;
      parent.scaling = new BABYLON.Vector3(1.6, 1.6, 1.6);  // â† ×”×’×“×œ×ª ×”××‘× ×” ×‘Ö¾30%


      const base = BABYLON.MeshBuilder.CreateBox("branchBase",{width:4,height:3,depth:4},scene);
      base.position.y = 2.25;
      base.parent = parent;
      const baseMat = new BABYLON.StandardMaterial("branchBaseMat",scene);
      baseMat.diffuseColor = new BABYLON.Color3(0.4,0.55,0.9);
      base.material = baseMat;
      shadowGen.addShadowCaster(base);

      const roof = BABYLON.MeshBuilder.CreateCylinder("branchRoof",{diameterTop:0,diameterBottom:5,height:1.4,tessellation:4},scene);
      roof.position.y = 5;
      roof.rotation.y = Math.PI/4;
      roof.parent = parent;
      const roofMat = new BABYLON.StandardMaterial("branchRoofMat",scene);
      roofMat.diffuseColor = new BABYLON.Color3(0.6,0.3,0.3);
      roof.material = roofMat;
      shadowGen.addShadowCaster(roof);

      addNodeLabel(parent, node.name, "#3b82f6", node);
      return parent;
    }

    function addNodeLabel(parent, text, color, nodeData) {
      const rect = new BABYLON.GUI.Rectangle();
      rect.adaptWidthToChildren = true;
      rect.adaptHeightToChildren = true;
      rect.cornerRadius = 5;
      rect.thickness = 0;
      rect.background = "rgba(15, 23, 42, 0.75)";
      rect.paddingLeft = "0px";
      rect.paddingTop = "0px";
      advancedTexture.addControl(rect);
      rect.linkWithMesh(parent);

      rect.linkOffsetY = -20;  // ×”×˜×§×¡×˜ ×¢×•×œ×” ×œ××¢×œ×”
      rect.linkOffsetX = 0;


      const tb = new BABYLON.GUI.TextBlock();
      tb.text = text;
      tb.color = "white";
      tb.fontSize = 12; 
      tb.fontFamily = "Heebo";
      tb.resizeToFit = true;
      tb.paddingLeft = "1px";
      tb.paddingRight = "1px";
      tb.paddingTop = "1px";
      tb.paddingBottom = "1px";
      rect.addControl(tb);
    }

    function drawAllRoadEdges(scene) {
      const tubeMat = new BABYLON.StandardMaterial("edgeMat",scene);
      tubeMat.diffuseColor = new BABYLON.Color3(0.7,0.72,0.78);
      tubeMat.alpha = 0.65;

      roadDefinitions.forEach((r, idx) => {
        const a = nodes[r.a];
        const b = nodes[r.b];
        const path = [new BABYLON.Vector3(a.x, 0.4, a.z), new BABYLON.Vector3(b.x, 0.4, b.z)];

        const tube = BABYLON.MeshBuilder.CreateTube("edge_"+idx,{
          path, radius: 0.25, tessellation: 8, cap: BABYLON.Mesh.CAP_ALL
        },scene);
        tube.material = tubeMat;

        // --- ×—×™×©×•×‘ ××™×§×•× ×”×ª×•×•×™×ª (××¢×•×“×›×Ÿ) ---
        let position;

        // 1. ×›×‘×™×© ×¦×¤×•×Ÿ-××¢×¨×‘ (1) ×œ×¦×¤×•×Ÿ-××–×¨×— (3) -> ×§×¨×•×‘ ×œ-3
        if ((r.a === 1 && r.b === 3) || (r.a === 3 && r.b === 1)) {
            position = BABYLON.Vector3.Lerp(path[0], path[1], 0.8);
            position.z -= 3; 
        } 
        // 2. ×›×‘×™×© ××¨×œ×•×’ (0) ×œ××¨×›×– ×”×¢×™×¨ (2) -> ×§×¨×•×‘ ×œ-2 (××¨×›×– ×”×¢×™×¨)
        else if ((r.a === 0 && r.b === 2) || (r.a === 2 && r.b === 0)) {
            // ×× a ×”×•× 0 ×•-b ×”×•× 2, ××– path[1] ×”×•× ××¨×›×– ×”×¢×™×¨. 0.75 ×™×§×¨×‘ ××•×ª×• ×œ×©×.
            position = BABYLON.Vector3.Lerp(path[0], path[1], 0.6);
        }
        // ×›×œ ×”×©××¨ - ×‘×××¦×¢
        else {
            position = BABYLON.Vector3.Center(path[0], path[1]);
        }

        const anchor = new BABYLON.TransformNode("edgeAnchor_"+idx,scene);
        anchor.position = new BABYLON.Vector3(position.x, 2.5, position.z);
        // ---------------------------------

        const rect = new BABYLON.GUI.Rectangle();
        rect.adaptWidthToChildren = true;
        rect.adaptHeightToChildren = true;
        rect.cornerRadius = 8;
        rect.background = "rgba(220, 225, 230, 0.85)";
        rect.thickness = 0;
        advancedTexture.addControl(rect);
        rect.linkWithMesh(anchor);

        const tb = new BABYLON.GUI.TextBlock();
        tb.text = r.d + " ×§\"×";
        tb.color = "black";
        tb.fontSize = 11;
        tb.fontFamily = "Heebo";
        tb.resizeToFit = true;
        tb.paddingLeft = "2px";
        tb.paddingRight = "2px";
        tb.paddingTop = "2px";
        tb.paddingBottom = "2px";
        rect.addControl(tb);
      });
    }

    function createTruckMesh(scene, shadowGen) {
      // × ×§×•×“×ª ×”××‘ (×”×‘×œ×ª×™ × ×¨××™×ª) ×©××—×–×™×§×” ××ª ×”×›×œ
      const parent = new BABYLON.TransformNode("truckParent", scene);
      parent.position.y = 0.1;

      // --- ×—×•××¨×™× ---
      // ×¦×‘×¢ ×›×ª×•× ×œ××¨×’×– ×”××˜×¢×Ÿ
      const cargoMat = new BABYLON.StandardMaterial("cargoMat", scene);
      cargoMat.diffuseColor = new BABYLON.Color3(0.98, 0.6, 0.2); 
      
      // ×¦×‘×¢ ×›×—×•×œ/××¤×•×¨ ×œ×§×‘×™× ×”
      const cabinMat = new BABYLON.StandardMaterial("cabinMat", scene);
      cabinMat.diffuseColor = new BABYLON.Color3(0.2, 0.3, 0.4);
      
      // ×¦×‘×¢ ×©×—×•×¨ ×œ×’×œ×’×œ×™×
      const wheelMat = new BABYLON.StandardMaterial("wheelMat", scene);
      wheelMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);

      // --- ×—×œ×§ 1: ××¨×’×– ×”××˜×¢×Ÿ (×”×—×œ×§ ×”××—×•×¨×™) ---
      const cargo = BABYLON.MeshBuilder.CreateBox("truckCargo", { width: 3.2, height: 2, depth: 4 }, scene);
      cargo.position.y = 1.5; // ×’×•×‘×”
      cargo.position.z = -1;  // ×”×–×–×” ××—×•×¨×”
      cargo.parent = parent;
      cargo.material = cargoMat;
      shadowGen.addShadowCaster(cargo);

      // --- ×—×œ×§ 2: ×”×§×‘×™× ×” (×”×—×œ×§ ×”×§×“××™) ---
      const cabin = BABYLON.MeshBuilder.CreateBox("truckCabin", { width: 3.2, height: 2.5, depth: 2 }, scene);
      cabin.position.y = 1.75; // ×§×¦×ª ×™×•×ª×¨ ×’×‘×•×” ××”××˜×¢×Ÿ
      cabin.position.z = 2;    // ×”×–×–×” ×§×“×™××”
      cabin.parent = parent;
      cabin.material = cabinMat;
      shadowGen.addShadowCaster(cabin);

      // --- ×—×œ×§ 3: ×’×œ×’×œ×™× ---
      // ×¤×•× ×§×¦×™×” ×œ×¢×–×¨ ×œ×™×¦×™×¨×ª ×’×œ×’×œ
      const createWheel = (name, x, z) => {
          // ×’×œ×’×œ ×”×•× ×’×œ×™×œ (Cylinder) ××¡×•×‘×‘
          const wheel = BABYLON.MeshBuilder.CreateCylinder(name, { diameter: 1.5, height: 0.8, tessellation: 12 }, scene);
          wheel.rotation.z = Math.PI / 2; // ×¡×™×‘×•×‘ ×©×•×›×‘
          wheel.position.set(x, 0.75, z); // ××™×§×•×
          wheel.parent = parent;
          wheel.material = wheelMat;
          shadowGen.addShadowCaster(wheel);
      };

      // ×™×¦×™×¨×ª 4 ×’×œ×’×œ×™×
      createWheel("w_fr",  1.8,  2); // ×§×“××™ ×™×× ×™
      createWheel("w_fl", -1.8,  2); // ×§×“××™ ×©×××œ×™
      createWheel("w_br",  1.8, -1.5); // ××—×•×¨×™ ×™×× ×™
      createWheel("w_bl", -1.8, -1.5); // ××—×•×¨×™ ×©×××œ×™

      // ×”×’×“×œ×” ×›×œ×œ×™×ª (×©×›×‘×¨ ×”×•×¡×¤× ×• ×§×•×“×)
      parent.scaling = new BABYLON.Vector3(1.4, 1.4, 1.4);

      return parent;
    }

    function setTruckToNode(nodeId) {
      const t = nodeTransforms[nodeId];
      if (!t) return;
      
      // ×× ×–×” ×”××¨×œ×•×’ (0), × ××§× ××ª ×”××©××™×ª ×§×¦×ª ×‘×—×•×¥ (Z=6) ×›×“×™ ×©×œ× ×ª×”×™×” ×‘×ª×•×š ×”××‘× ×”
      if (nodeId === 0) {
          truckParent.position.x = t.position.x;
          truckParent.position.z = t.position.z - 8; // ×”×•×¦××” ×”×—×•×¦×”
          truckParent.rotation.y = Math.PI; // ×©×ª×¤× ×” ×œ×›×™×•×•×Ÿ ×”×›×‘×™×©
      } else {
          // ×‘×¡× ×™×¤×™× ××—×¨×™× (×‘××§×¨×” ×©×œ Undo), × ××§× ×‘××¨×›×–
          truckParent.position.x = t.position.x;
          truckParent.position.z = t.position.z;
      }
    }

    function animateTruck(fromId, toId, cb) {
      const fromPos = nodeTransforms[fromId].position; // ××¨×›×– × ×§×•×“×ª ×”××•×¦×
      const toPos = nodeTransforms[toId].position;     // ××¨×›×– × ×§×•×“×ª ×”×™×¢×“ (×‘×ª×•×š ×”××‘× ×”)
      
      isAnimating = true;

      // 1. ×—×™×©×•×‘ ×•×§×˜×•×¨ ×”×›×™×•×•×Ÿ (×××™×¤×” ×œ××™×¤×”)
      const direction = toPos.subtract(fromPos).normalize();
      
      // 2. ×—×™×©×•×‘ ×–×•×•×™×ª ×”×¡×™×‘×•×‘ ×©×œ ×”××©××™×ª
      const dx = toPos.x - fromPos.x;
      const dz = toPos.z - fromPos.z;
      if (Math.abs(dx) > 0.01 || Math.abs(dz) > 0.01) {
        truckParent.rotation.y = Math.atan2(dx, dz);
      }

      // 3. ×—×™×©×•×‘ × ×§×•×“×ª ×”×¢×¦×™×¨×” ×”×—×“×©×” (Stop Point)
      // ×× ×—× ×• ×œ×•×§×—×™× ××ª ×”×™×¢×“ ×”×¡×•×¤×™, ×•××—×¡×™×¨×™× ××× ×• 5 ×™×—×™×“×•×ª ×‘×›×™×•×•×Ÿ ×©××× ×• ×‘×× ×•
      // ×–×” ×™×’×¨×•× ×œ××©××™×ª ×œ×¢×¦×•×¨ ×‘×›× ×™×¡×” ×œ××‘× ×” ×•×œ× ×‘×ª×•×›×•
      const stopOffset = 5.5; // ××¨×—×§ ×”×¢×¦×™×¨×” ××”××¨×›×–
      const targetX = toPos.x - (direction.x * stopOffset);
      const targetZ = toPos.z - (direction.z * stopOffset);

      // 4. ×× ×™××¦×™×” ×œ× ×§×•×“×” ×”×—×“×©×”
      gsap.to(truckParent.position, {
        x: targetX, 
        z: targetZ, 
        duration: 1.2, 
        ease: "power2.inOut",
        onComplete: () => {
          isAnimating = false;
          if (cb) cb();
        }
      });

      // ×©×¨×˜×•×˜ ×”×§×• ×”×›×—×•×œ (× ×©××¨ ××•×ª×• ×“×‘×¨, ××¦×•×™×¨ ×‘×™×Ÿ ×”××¨×›×–×™× ×›×“×™ ×©×™×¨××” ×™×¤×” ×¢×œ ×”×›×‘×™×©)
      if (playerPath.length > 0) {
        const path = [
            new BABYLON.Vector3(fromPos.x, 0.8, fromPos.z), 
            new BABYLON.Vector3(toPos.x, 0.8, toPos.z)
        ];
        const tube = BABYLON.MeshBuilder.CreateTube("playerSeg",{path, radius: 0.4, tessellation: 8},scene);
        const mat = new BABYLON.StandardMaterial("playerSegMat",scene);
        mat.diffuseColor = new BABYLON.Color3(0.37,0.67,1);
        tube.material = mat;
        playerSegments.push(tube);
      }
    }

    function resetGame() {
      visited = Array(N).fill(false);
      visited[0] = true;
      playerPath = [0];
      totalDistance = 0;
      gameOver = false;
      isAnimating = false;
      currentDistanceEl.textContent = "0";
      statusMessageEl.textContent = "ğŸ‘† ×œ×—×¦×™ ×¢×œ ×”×¡× ×™×£ ×”×¨××©×•×Ÿ ×‘××¡×œ×•×œ ×›×“×™ ×œ×”×ª×—×™×œ";
      playerSegments.forEach(m => m.dispose());
      playerSegments = [];
      setTruckToNode(0);
    }

    function undoLastMove() {
      if (isAnimating || playerPath.length <= 1) return;
      const last = playerPath.pop();
      const prev = playerPath[playerPath.length - 1];
      if (last !== 0) visited[last] = false;
      totalDistance -= distances[prev][last];
      if (totalDistance < 0) totalDistance = 0;
      const seg = playerSegments.pop();
      if (seg) seg.dispose();
      setTruckToNode(prev);
      currentDistanceEl.textContent = totalDistance.toString();
      gameOver = false;
      statusMessageEl.textContent = "â†©ï¸ ×”×¦×¢×“ ×”××—×¨×•×Ÿ ×”×•×¡×¨.";
    }

    function handleNodeClick(nodeId) {
      if (isAnimating || gameOver) return;
      const last = playerPath[playerPath.length - 1];
      if (!adjacency[last][nodeId]) return;
      if (nodeId === 0) {
        if (!allBranchesVisited()) {
          statusMessageEl.textContent = "âš ï¸ ××™ ××¤×©×¨ ×œ×—×–×•×¨ ×œ××¨×œ×•×’ ×œ×¤× ×™ ×‘×™×§×•×¨ ×‘×›×•×œ×.";
          return;
        }
        totalDistance += distances[last][0];
        playerPath.push(0);
        currentDistanceEl.textContent = totalDistance.toString();
        statusMessageEl.textContent = "ğŸšš ×”××©××™×ª ×—×•×–×¨×ª ×œ××¨×œ×•×’...";
        animateTruck(last, 0, () => {
          gameOver = true;
          showResultPopup();
        });
        return;
      }
      if (visited[nodeId]) {
        statusMessageEl.textContent = "âš ï¸ ×›×‘×¨ ×‘×™×§×¨×ª ×‘×¡× ×™×£ ×”×–×”.";
        return;
      }
      visited[nodeId] = true;
      playerPath.push(nodeId);
      totalDistance += distances[last][nodeId];
      currentDistanceEl.textContent = totalDistance.toString();
      statusMessageEl.textContent = "ğŸšš ×‘×“×¨×š ×œ" + nodes[nodeId].name;
      animateTruck(last, nodeId);
    }

    function showResultPopup() {
      modalPlayerDistanceEl.textContent = totalDistance + " ×§\"×";
      modalOptimalDistanceEl.textContent = optimalDistance + " ×§\"×";
      const diff = totalDistance - optimalDistance;
      if (diff === 0) {
        modalResultMessageEl.className = "result-message success";
        modalResultMessageEl.textContent = "ğŸ† ×›×œ ×”×›×‘×•×“! ×‘×—×¨×ª ×‘××¡×œ×•×œ ×”××•×¤×˜×™××œ×™!";
      } else {
        modalResultMessageEl.className = "result-message fail";
        modalResultMessageEl.textContent = "ğŸ¤ ×”××¡×œ×•×œ ×©×œ×š ××¨×•×š ×‘Ö¾" + diff + " ×§\"× ××”××•×¤×˜×™××œ×™.";
      }
      resultOverlay.classList.add("show");
    }

    function hideResultPopup() {
      resultOverlay.classList.remove("show");
    }

    // INIT
    window.addEventListener("DOMContentLoaded", () => {
      currentDistanceEl = document.getElementById("currentDistance");
      optimalDistanceEl = document.getElementById("optimalDistanceDisplay");
      statusMessageEl = document.getElementById("status-message");
      undoBtn = document.getElementById("btn-undo");
      resetBtn = document.getElementById("btn-reset");
      resultOverlay = document.getElementById("resultOverlay");
      modalPlayerDistanceEl = document.getElementById("modalPlayerDistance");
      modalOptimalDistanceEl = document.getElementById("modalOptimalDistance");
      modalResultMessageEl = document.getElementById("modalResultMessage");
      playAgainBtn = document.getElementById("playAgainBtn");
      closeModalBtn = document.getElementById("closeModalBtn");
      helpBtn = document.getElementById("helpBtn");
      sidePanel = document.getElementById("sidePanel");

      buildGraph();
      optimalDistance = computeOptimalRoute();
      optimalDistanceEl.textContent = optimalDistance.toString();

      const canvas = document.getElementById("renderCanvas");
      createScene(canvas);
      resetGame();

      undoBtn.addEventListener("click", undoLastMove);
      resetBtn.addEventListener("click", () => { hideResultPopup(); resetGame(); });
      playAgainBtn.addEventListener("click", () => { hideResultPopup(); resetGame(); });
      closeModalBtn.addEventListener("click", hideResultPopup);
      
      if(helpBtn) {
        helpBtn.addEventListener("click", () => {
          sidePanel.classList.toggle("open");
        });
      }

      engine.runRenderLoop(() => scene.render());
      window.addEventListener("resize", () => engine.resize());
    });

    })();
  </script>
</body>
</html>